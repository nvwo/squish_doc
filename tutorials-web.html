<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- Mirrored from tutorials-web.html by HTTrack Website Copier/3.x [XR&CO'2013], Wed, 06 Jul 2022 13:28:59 GMT -->
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>4.6. Squish for Web Tutorials</title><link rel="stylesheet" href="manual.css" type="text/css"></link><meta name="generator" content="DocBook XSL Stylesheets V1.73.2"></meta><link rel="start" href="index-noframes.html" title="Squish Manual"></link><link rel="up" href="tutorials.html" title="Chapter 4. Tutorials"></link><link rel="prev" href="tutorials-java-bdd.html" title="4.5.  Squish for Java BDD Tutorials"></link><link rel="next" href="tutorials-win.html" title="4.7. Squish for Windows Tutorials"></link><style xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" type="text/css" media="screen">
        div.toc * { margin-left: 6px; margin-right: auto; max-width: 75em; }
        div.toc span { margin-left: 0px; }
        * { margin-left: auto; margin-right: auto; max-width: 75em; }
        body { margin-left: 6px; margin-right: 6px; }
        table th { padding: .5ex }
        table td { padding: .5ex }
    </style><script xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format">
        function keyPress() {
            var e = window.event;
            if ( e == undefined ) {
                return;
            }
            /* ### does not properly scroll, yet
            if ( e.keyCode == 32 ) {
            var l = document.links;
            for ( var i = 0; i < l.length; i++ ) {
                if ( l[i].innerText == "Next" ) {
                location.href = l[i].href;
                }
            }
            } else
                */
                if ( e.keyCode == 0x08 ) {
            var l = document.links;
            for ( var i = 0; i < l.length; i++ ) {
                if ( l[i].innerText == "Prev" ) {
                location.href = l[i].href;
                }
            }
            }
        }
        document.onkeypress = keyPress;
    </script></head><body><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="tutorials-web"></a>4.6. Squish for Web Tutorials</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="tutorials-web.html#tutorial-getting-started-web">4.6.1. Tutorial: Starting to Test Web Applications</a></span></dt><dt><span class="section"><a href="tutorials-web.html#tutorial-bdd-web">4.6.2. Tutorial: Designing Behavior Driven Development (BDD) Tests</a></span></dt><dt><span class="section"><a href="tutorials-web.html#tutorial-migration-bdd-web">4.6.3. Tutorial: Migration of existing tests to BDD</a></span></dt></dl></div><p>
	Learn how to test web applications.
	</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-getting-started-web"></a>4.6.1. Tutorial: Starting to Test Web Applications</h3></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="tutorials-web.html#tgs-concepts-web">4.6.1.1. Squish Concepts</a></span></dt><dt><span class="section"><a href="tutorials-web.html#tut-web-creating-a-test-suite">4.6.1.2. Creating a Test Suite</a></span></dt><dt><span class="section"><a href="tutorials-web.html#tut-web-recording-tests">4.6.1.3. Recording Tests and Verification Points</a></span></dt><dt><span class="section"><a href="tutorials-web.html#tgs-vp-web">4.6.1.4. Inserting Additional Verification Points</a></span></dt><dt><span class="section"><a href="tutorials-web.html#tut-web-creating-manual-tests">4.6.1.5. Creating Tests by Hand</a></span></dt><dt><span class="section"><a href="tutorials-web.html#web-tut-learning-more">4.6.1.6. Learning More</a></span></dt></dl></div><p>
This tutorial will show you how to create, run, and modify tests for an
example web application. In the process you will learn about
<span class="emphasis"><em>Squish</em></span>'s most frequently used features so that by the end of the
tutorial you will be able to start writing your own tests for your own
applications.
</p><p>
This chapter presents most of the major concepts behind <span class="emphasis"><em>Squish</em></span> and
provides the information you need to get started using <span class="emphasis"><em>Squish</em></span> for
testing your own applications. This tutorial does not discuss all
of <span class="emphasis"><em>Squish</em></span>'s features, and those that it does cover are not covered in
full detail. After reading this tutorial we recommend reading the
<a class="xref" href="users-guide.html" title="Chapter 5. User Guide">User Guide (Chapter 5)</a>, and at least skimming the
<a class="xref" href="api.man.html" title="Chapter 6. API Reference Manual">API Reference Manual (Chapter 6)</a> and the
<a class="xref" href="ref.man.html" title="Chapter 7. Tools Reference Manual">Tools Reference Manual (Chapter 7)</a>, so that you are familiar with all the
features that <span class="emphasis"><em>Squish</em></span> has to offer, even if you don't need to use them
all straight away.
</p><p>
This tutorial is divided into several sections. If you are new to
<span class="emphasis"><em>Squish</em></span>, it is best
to read all of them. If you are already using <span class="emphasis"><em>Squish</em></span> you might want to
just skim the tutorial, stopping only to read those sections that cover
any new features that you haven't used before—or you could just
skip straight to the <a class="xref" href="users-guide.html" title="Chapter 5. User Guide">User Guide (Chapter 5)</a>.
</p><p>
<span class="emphasis"><em>Squish</em></span> comes with an IDE and command line tools. Using the IDE is the easiest
and best way to start, but once
you build up lots of tests you will want to automate them, (e.g., doing
nightly runs of your regression test suite), so it is worth knowing how
to use the command line tools since they can be run from batch files or
shell scripts.
</p><p>
For this chapter we will use a simple Address Book application as our
AUT. The application is shipped with <span class="emphasis"><em>Squish</em></span> in
<code class="filename">SQUISHDIR/examples/web/addressbook</code>. This is a very
basic application that allows users to interact with a fake existing address
book or create a new one, and add, edit, and remove entries.
Despite the application's simplicity,
it has all the key features that most standard web applications have:
buttons, radio buttons, line edits, pop-up dialogs, and a central area—in
this case showing a table. All the ideas and practices that you
learn to test this application can easily be adapted to your own
applications. And naturally, the <a class="xref" href="users-guide.html" title="Chapter 5. User Guide">User Guide (Chapter 5)</a> has many
more examples and shows how to test lots of web-specific features,
as well as all the standard
editing widgets.
</p><p>
The screenshots show the application in action.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/web-tut-addressbook1.png" align="middle"></img><div class="caption"><p>The Web <code class="code">AddressBook.html</code> example.
</p></div></div></div><div class="screenshot"><div class="mediaobject" align="center"><img src="images/web-tut-addressbook1a.png" align="middle"></img><div class="caption">Adding a new Address.</div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Using the Examples"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></img></td><th align="left">Using the Examples</th></tr><tr><td align="left" valign="top"><p> This tutorial's example is an HTML and JavaScript web application
contained in the file
<code class="filename">SQUISHDIR/examples/web/addressbook/AddressBook.html</code>.
<span class="emphasis"><em>Squish</em></span> for Web is designed to test real web applications served over http:
by a web server, and the AddressBook example requires being hosted on
one.</p><p> The server is written in Python; simply run it from the command
line using the Python interpreter on your system, or one under
<code class="filename">SQUISHDIR</code> (<code class="filename">python2</code> or
<code class="filename">python3</code>).
</p><pre class="screen">
$ <span class="bold"><strong>python SQUISHDIR/examples/web/addressbook/server.py</strong></span>
</pre><p>
If you are on windows:
</p><pre class="screen">
C:\&gt; <span class="bold"><strong>cd SQUISHDIR\examples\web\addressbook</strong></span>
C:\SQUISHDIR\examples\web\addressbook&gt; <span class="bold"><strong>..\..\..\python2\python server.py</strong></span>
</pre><p>
Once the server is running, you can access the web addressbook example application using
the URL <code class="code">http://localhost:9090/AddressBook.html</code>. (If port 9090
conflicts with anything else on your machine simply pass an unused port number
as a command line argument to <code class="code">server.py</code> and it will use that
instead. Naturally, if you use a different port you must use that port
throughout the tutorial.) </p></td></tr></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Windows Security Dialog"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></img></td><th align="left">Windows Security Dialog</th></tr><tr><td align="left" valign="top"><p>
When starting any TCP/IP server for the first time (including <span class="application">squishserver</span>, or
<code class="code">server.py</code>) on Windows, depending on your security
settings, Windows may pop up a dialog asking if you want to allow or
block the server from running. If you get this dialog, you
<span class="emphasis"><em>must</em></span> choose <span class="guibutton">Unblock</span> so that <span class="emphasis"><em>Squish</em></span>
can function correctly.
</p></td></tr></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Browsers on mobile platforms"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></img></td><th align="left">Browsers on mobile platforms</th></tr><tr><td align="left" valign="top"><p>
To test web applications running inside a browser (like <span class="application">Safari</span> or Chrome) on
iOS (e.g., iPhones and iPads) or Android devices, once <span class="emphasis"><em>Squish</em></span> for Web is
installed, some extra device-specific setup is required. See <a class="xref" href="installation.for.web.testing.html#installation.for.web.testing.on.mobile.devices" title="3.7.9. Browsers on mobile devices">Browsers on mobile devices (Section 3.7.9)</a>.
</p></td></tr></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Firefox Users"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></img></td><th align="left">Firefox Users</th></tr><tr><td align="left" valign="top"><p>
Due to a technical limitation, it is not possible to record
or play back tests on <span class="application">Firefox</span> if a browser process previously started by <span class="emphasis"><em>Squish</em></span>
is still running. (If you try, a new tab will appear in Firefox but the test
won't run.) The solution is to close Firefox; then, when you record or play back
a test, <span class="emphasis"><em>Squish</em></span> will start and close Firefox automatically as needed.
</p></td></tr></table></div><p>
In the following sections we will create a test suite and then create
some tests, but first we will very briefly review some key <span class="emphasis"><em>Squish</em></span>
concepts.
</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="tgs-concepts-web"></a>4.6.1.1. Squish Concepts</h4></div></div></div><p>
To perform web testing, two things are required:
</p><div class="orderedlist"><ol type="1"><li><p>
A web browser, and an initial URL to open, together form what we call
an Application Under Test (AUT)
</p></li><li><p>
a test script that exercises the AUT.
</p></li></ol></div><p>
<span class="emphasis"><em>Squish</em></span> runs a small server (<span class="application">squishserver</span>) that handles the
communication between the AUT and the test script. The test script is
executed by the <span class="application">squishrunner</span> tool, which in turn connects to the
<span class="application">squishserver</span>. The <span class="application">squishserver</span> starts the AUT and injects the
<span class="emphasis"><em>Squish</em></span> hook into it. The hook is a small library that makes the AUT's
live running objects accessible and that can communicate with the
<span class="application">squishserver</span>. With the hook in place, the <span class="application">squishserver</span> can query AUT
objects regarding their state and can execute commands—all on
behalf of the <span class="application">squishrunner</span>. And the <span class="application">squishrunner</span> itself requests
that the AUT performs whatever actions the test script specifies. All
the communication takes place using network sockets which means that
everything can be done on a single machine, or the test script can be
executed on one machine and the AUT can be tested over the network on
another machine.
</p><p>
The following diagram illustrates how the individual <span class="emphasis"><em>Squish</em></span> tools work
together.
</p><div class="mediaobject" align="center"><img src="images/design_network.png" align="middle"></img></div><p>
From the test engineer's perspective this separation is not noticeable,
since all the communication is handled transparently behind the scenes.
</p><p>
Tests can be written and executed using the <span class="application">Squish IDE</span>, in which case the
<span class="application">squishserver</span> is started and stopped automatically, and the test
results are displayed in the <span class="application">Squish IDE</span>'s <a class="xref" href="ide.views.html#ide.the-test-results.view" title="8.2.18. Test Results view">Test Results view (Section 8.2.18)</a>. The following diagram illustrates
what happens behind the scenes when the <span class="application">Squish IDE</span> is used.
</p><div class="mediaobject" align="center"><img src="images/design_ide.png" align="middle"></img></div><p>
The <span class="emphasis"><em>Squish</em></span> tools can also be used from the command line without the
<span class="application">Squish IDE</span>—this is useful for those testers who prefer to use their own
tools (for example, their favorite editor), and also for performing
automatic batch testing (for example, when running regression tests
overnight). In these cases, the <span class="application">squishserver</span> must be started manually,
and stopped when all the testing is complete (or, if preferred, started
and stopped for each test).
</p><p>
For <span class="emphasis"><em>Squish</em></span> to make it possible for test scripts to be able to query
and control an AUT, <span class="emphasis"><em>Squish</em></span> must be able to access the AUT's internals,
and this is made possible by the use of <span class="emphasis"><em>bindings</em></span>.
Bindings are in effect libraries that provide access to the
objects—and in turn to the objects' properties and
methods—that are available. The bindings for <a class="xref" href="rgs-webconvenience.html" title="6.10. Web Object API">Web Object API (Section 6.10)</a> is a fixed set of
properties and methods mostly for manipulating HTML objects in the loaded web
page.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: The Squish Directory"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></img></td><th align="left">The <span class="emphasis"><em>Squish</em></span> Directory</th></tr><tr><td align="left" valign="top"><p>
Throughout the manual, we often refer to the <code class="filename">SQUISHDIR/</code>
directory. This means the directory where <span class="emphasis"><em>Squish</em></span> is installed, which
might be <code class="filename">C:\Squish</code>,
<code class="filename">/usr/local/squish</code>,
<code class="filename">~/squish</code>, or somewhere else, depending on
where you installed it. The exact location doesn't matter, so long as
you mentally translate the <code class="filename">SQUISHDIR</code> directory to
whatever the directory really is when you see paths and filenames in
this manual.
</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="tut-web-creating-a-test-suite"></a>4.6.1.2. Creating a Test Suite</h4></div></div></div><p>
A test suite is a collection of one or more test cases
(<span class="emphasis"><em>tests</em></span>).
Using a test suite is convenient since it makes it easy to share tests
scripts and test data between tests.
</p><p>
Here, and throughout the tutorial, we will start by describing how to do
things using the IDE, with the information for command line users
following.
</p><p>
To begin with start up the <span class="application">Squish IDE</span>, either by clicking or double-clicking
the <span class="application">squishide</span> icon, or by launching <span class="application">squishide</span> from the taskbar menu
or by executing <span class="application">squishide</span> on the command line—whichever you
prefer and that is suitable for the platform you are using. Once
<span class="emphasis"><em>Squish</em></span> starts up you might be greeted with a <span class="emphasis"><em>Welcome Page</em></span>
in case you're starting the <span class="application">squishide</span> for the first time. Click the
<span class="emphasis"><em>Workbench</em></span> button in the upper right to dismiss it. Then, the
<span class="application">squishide</span> will look <span class="emphasis"><em>similar</em></span> to the screenshot—but probably
slightly different depending on the windowing system, colors, fonts, and
theme that you use, and so on.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/tut-web-squish1.png" align="middle"></img><div class="caption">The Squish IDE with no Test Suites
</div></div></div><p>
Once <span class="emphasis"><em>Squish</em></span> has started click
<span class="guimenu">File</span>|<span class="guimenuitem">New Test
Suite...</span> to
pop-up the <a class="xref" href="ide.dialogs.html#ide.new.squish.test.case.wizard" title="8.3.10. New Squish Test Case wizard">New Squish Test Case wizard (Section 8.3.10)</a> shown below.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/tut-squish-newtestsuite1-web.png" align="middle"></img><div class="caption">The New Test Suite wizard's Name &amp; Directory page
</div></div></div><p>
Enter a name for your test suite and choose the folder where you want
the test suite to be stored. In the screenshot we have called the test
suite <code class="filename">suite_js</code> and will put it inside the
<code class="filename">addressbook</code> folder. (For your own tests you might
use a more meaningful name such as <code class="filename">suite_addressbook</code>;
we chose <code class="filename">suite_js</code> because for the sake of the tutorial we
will create several suites, one for each scripting language that <span class="emphasis"><em>Squish</em></span> supports.)
Naturally, you can choose whatever name and folder you prefer. Once the
details are complete, click <span class="guibutton">Next</span> to go on to the
<span class="guilabel">Toolkit</span> (or <span class="guilabel">Scripting Language</span>) page.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/tut-squish-newtestsuite2-web.png" align="middle"></img><div class="caption">The New Test Suite wizard's Toolkit page
</div></div></div><p>
If you get this wizard page, click the toolkit your AUT uses. For this
example, we must click <span class="guilabel">Web</span> since we are testing a Web
application. Then click <span class="guibutton">Next</span> to go to the
<span class="guilabel">Scripting Language</span> page.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Scripting Languages"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></img></td><th align="left">Scripting Languages</th></tr><tr><td align="left" valign="top"><p>
<span class="emphasis"><em>Squish</em></span> supports several different scripting languages, and different
installations may include support for some or all of these—so the
scripting languages shown in the screenshot may be different from those
shown by your version of <span class="emphasis"><em>Squish</em></span>.
</p></td></tr></table></div><div class="screenshot"><div class="mediaobject" align="center"><img src="images/tut-web-squish-newtestsuite3.png" align="middle"></img><div class="caption">The New Test Suite wizard's Scripting Language page
</div></div></div><p>
Choose whichever scripting language you want—the only constraint
is that you can only use one scripting language per test suite. (So if
you want to use multiple scripting languages, just create multiple test
suites, one for each scripting language you want to use.) The
functionality offered by <span class="emphasis"><em>Squish</em></span> is the same for all languages.
</p><p>
Having chosen a scripting language, click <span class="guibutton">Finish</span> to
complete the creation of a new test suite. At this point
 <span class="emphasis"><em>Squish</em></span> will create a sub-folder with
the same name as the test suite, and will create a file inside that
folder called <code class="filename">suite.conf</code> that contains the test
suite's configuration details. The wizard will then close and <span class="emphasis"><em>Squish</em></span>'s IDE will
look similar to the screenshot below.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/tut-web-squish2.png" align="middle"></img><div class="caption">The Squish IDE with the suite_js test suite
</div></div></div><p>
We are now ready to start creating tests. Read on to learn how to create
test suites without using the IDE, or skip ahead to <a class="xref" href="tutorials-web.html#tut-web-recording-tests" title="4.6.1.3. Recording Tests and Verification Points">Recording Tests and Verification Points (Section 4.6.1.3)</a> if you prefer.
</p><p>
We are now ready to record our first test.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="tut-web-recording-tests"></a>4.6.1.3. Recording Tests and Verification Points</h4></div></div></div><p>
<span class="emphasis"><em>Squish</em></span> records tests using the scripting language that was specified
for the test suite. Once a
test has been recorded, we can <span class="emphasis"><em>run</em></span> the test and
<span class="emphasis"><em>Squish</em></span> will faithfully repeat all the actions that we performed when
recording the test, but without all the pauses that humans are prone to
but which computers don't need. It is also possible—and very
common—to edit recorded tests, or to copy parts of recorded tests
into manually created tests, as we will see later on in the tutorial.
</p><p>
Recordings are made into existing test cases. We begin by
creating a <span class="guilabel">New Script Test Case</span>.
There are two ways we can do this. One way
is to click <span class="guimenu">File</span>|<span class="guimenuitem">New Test
Case...</span>. This will pop up the <a class="xref" href="ide.dialogs.html#ide.new.squish.test.case.wizard" title="8.3.10. New Squish Test Case wizard">New Squish Test Case wizard (Section 8.3.10)</a>—simply enter the name
for the test case and then click <span class="guibutton">Finish</span>. Another
way is to click the <span class="guibutton">New Script Test Case</span> (<span class="guiicon"><img src="images/ide/new_test_case.png"></img></span>) button (to
the right of the <span class="guilabel">Test Cases</span> label in the
<span class="guilabel">Test Suites</span> view); this will create a new test
case with a default name (which you can easily change). Use one of these
methods and give the new test case the name “<span class="quote">tst_general</span>”.
<span class="emphasis"><em>Squish</em></span> automatically creates a sub-folder inside the test suite's
folder with this name and also a test file, for example
<code class="filename">test.js</code>. (If we had chosen Python as our
scripting language the file would be called
<code class="filename">test.py</code>, and correspondingly for Perl, Ruby, or Tcl.)
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/tut-web-squish3.png" align="middle"></img><div class="caption">The Squish IDE with the tst_general test case
</div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></img></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><div class="mediaobject" align="right"><img src="images/tut-squish-testcase-type.png" align="right"></img></div><p>
If you get a sample <code class="filename">.feature</code> file instead of a "Hello
World" script, then click on the arrow left of the <span class="guibutton">Run Test Suite</span> (<span class="guiicon"><img src="images/ide/run_test_suite.png"></img></span>)
and select <span class="guibutton">New Script Test Case</span> (<span class="guiicon"><img src="images/ide/new_test_case.png"></img></span>).
</p></td></tr></table></div><p>
To make the test script file (e.g., <code class="filename">test.js</code>) appear
in an <a class="xref" href="ide.views.html#ide.the-editor.view" title="8.2.6. Editor view">Editor view (Section 8.2.6)</a>, click—or double-click
depending on the <span class="guimenuitem">Preferences</span>|<span class="guimenuitem">General</span>|<span class="guimenuitem">Open mode</span>
setting—the test case. This selects the Script as the active one
and makes visible its corresponding <span class="guibutton">Record</span> (<span class="guiicon"><img src="images/ide/record.png"></img></span>) and <span class="guibutton">Run Test</span> (<span class="guiicon"><img src="images/ide/run.png"></img></span>) buttons.
</p><p>
The checkboxes are used to control which test cases are
run when the <span class="guibutton">Run Test Suite</span> (<span class="guiicon"><img src="images/ide/run_test_suite.png"></img></span>) toolbar button is clicked; we can also run
a single test case by clicking its <span class="guibutton">Run Test</span> (<span class="guiicon"><img src="images/ide/run.png"></img></span>) button. If the test case is not
currently active, the button may be invisible until the mouse is hovered over
it.
</p><p> Initially, the
script's <code class="function">main()</code> logs "Hello World" to the test results. If
we were to create a test manually (as we will do later on in the tutorial), we
<span class="emphasis"><em>must</em></span> create a <code class="function">main</code> function, and we
should import the same imports at the top.
The name "main" is special to <span class="emphasis"><em>Squish</em></span>. Tests may contain as many functions
and other code as we like (providing it is legal for the scripting language), but when the
test is executed (i.e., run), <span class="emphasis"><em>Squish</em></span> always executes the
<code class="function">main</code> function. It is also possible to share commonly used code
between test scripts—this is covered in the <a class="xref" href="users-guide.html" title="Chapter 5. User Guide">User Guide (Chapter 5)</a>. (In fact, two other function names are special
to <span class="emphasis"><em>Squish</em></span>, <code class="function">cleanup</code> and <code class="function">init</code>; see <a class="xref" href="api.special.functions.html" title="6.1. Tester-Created Special Functions">Tester-Created Special Functions (Section 6.1)</a> for details.)
</p><p>
Once the new test case has been created, we are free to write
test code manually, or to record a test. Clicking on the test case's
<span class="guibutton">Record</span> (<span class="guiicon"><img src="images/ide/record.png"></img></span>) replaces the test's code with a new recording.
It is also possible to record snippets and insert them into existing test
cases, covered in the Users Guide and not in this tutorial.
</p><p>
Before we dive into recording let's briefly review our very simple test scenario:
</p><div class="orderedlist"><ol type="1"><li><p>
Add a new name and address.
</p></li><li><p>
Change the fourth name and address's surname field.
</p></li><li><p>
Remove the second name and address
</p></li><li><p>
Verify that the last address is now the new one that was added.
</p></li></ol></div><p>
We are now ready to record our first test. Click <span class="guibutton">Record</span> (<span class="guiicon"><img src="images/ide/record.png"></img></span>) to the right of
the <code class="code">tst_general</code> test case shown in the <a class="xref" href="ide.views.html#ide.the-test-suites.view" title="8.2.19. Test Suites view">Test Suites view (Section 8.2.19)</a>'s Test Cases list.
For Web testing, <span class="emphasis"><em>Squish</em></span> will prompt for the browser's starting
URL. For this tutorial that should be
<code class="code">http://localhost:9090/AddressBook.html</code>
</p><p>
Once the browser is running and the page is loaded, perform the following
actions—and don't worry about how long it takes since <span class="emphasis"><em>Squish</em></span>
doesn't record idle time:
</p><div class="orderedlist"><ol type="1"><li><p>
Click the <span class="guibutton">Add</span> button and fill in the form with
forename, "Jane", surname "Doe", email address "jane.doe@nowhere.com",
and a phone number of "555 123 4567". Click or press the
<span class="keysym">Tab</span> key to navigate between fields.
Finally, click the <span class="guibutton">Save</span> button. There should now be a new
last address with the details you typed in.
</p></li><li><p>
Click the fourth row's checkbox to select that record and then
click the <span class="guibutton">Edit</span> button. In the form tab to or
click the surname field and change the surname to "Doe". Finally, click
the <span class="guibutton">Save</span> button. The change should be reflected
in the list of addresses.
</p></li><li><p>
Click the second row's checkbox to select that record and then
click the <span class="guibutton">Remove</span> button. Click the pop-up
confirmation dialog's <span class="guibutton">OK</span> button. The change
should be reflected in the list of addresses.
</p></li><li><p>
Click the <span class="guibutton">Verify</span> toolbar button in
the <span class="emphasis"><em>Squish</em></span> <a class="xref" href="ide.main.window.html#ide-the-controlbar-window" title="8.1.3. Control Bar Window">Control Bar Window (Section 8.1.3)</a> (the second
button from the left) and select <span class="guibutton">Properties</span>.</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/controlbar-verify-props.png" align="middle"></img></div></div><p>This will make the <span class="application">Squish IDE</span> appear. In the <span class="guilabel">Application
Objects</span> view click the <a class="xref" href="ide.views.html#object-picker">Object Picker</a> (<span class="guiicon"><img src="images/ide/pick-application-object.png"></img></span>) button, then in the
AUT move the mouse to the last forename (i.e., the "Jane" that you entered
earlier)—each web element you hover over should be highlighted with
a red outline. Once the correct table cell is highlighted (i.e.,
"Jane"), click it. Now go back to the <span class="application">Squish IDE</span> and check the <a class="xref" href="ide.views.html#ide.the-properties.view" title="8.2.12. Properties view">Properties view (Section 8.2.12)</a>'s <span class="property">innerText</span> property.
Now click the <a class="xref" href="ide.views.html#object-picker">Object Picker</a> (<span class="guiicon"><img src="images/ide/pick-application-object.png"></img></span>) button again, and this time
click the last surname showing in the AUT (i.e., "Doe"). Now go back to
the <span class="application">Squish IDE</span> and again check the <span class="property">innerText</span> property.
Finally, click the <span class="guibutton">Save and Insert Verifications</span> button (at the
bottom of the <a class="xref" href="ide.views.html#ide.verification.point.creator.view" title="8.2.22. Verification Point Creator view">Verification Point Creator view (Section 8.2.22)</a>)
to have the forename and surname verifications for the selected row
inserted into the recorded test script. (See the screenshot below.) Once
the verification points are inserted the <span class="application">Squish IDE</span>'s window will be hidden
again and the <a class="xref" href="ide.main.window.html#ide-the-controlbar-window" title="8.1.3. Control Bar Window">Control Bar Window (Section 8.1.3)</a> and the AUT
will be back in view. </p></li><li><p>
We've now completed the test, so click the <a class="xref" href="ide.main.window.html#ide-the-controlbar-window" title="8.1.3. Control Bar Window">Control Bar Window (Section 8.1.3)</a>'s <span class="guibutton">Stop
Recording</span> button (the left-most button).
</p></li></ol></div><div class="screenshot"><div class="mediaobject" align="center"><img src="images/web-tut-squishgui16.png" align="middle"></img><div class="caption">The Squish IDE showing two verification points about to be inserted
</div></div></div><p>
Once the recording is finished, the recorded test will appear in
<span class="emphasis"><em>Squish</em></span>'s IDE as the screenshot illustrates. (Note that the exact code
that is recorded will vary depending on how you interact. For example,
you might invoke menu options by clicking them or by using key
sequences—it doesn't matter which you use, but since they are
different, <span class="emphasis"><em>Squish</em></span> will record them differently.)
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/web-tut-squishgui6.png" align="middle"></img><div class="caption">The Squish IDE showing the recorded tst_general test
</div></div></div><p>
If the recorded test doesn't appear, click (or double-click depending on
your platform and settings) the <code class="filename">tst_general</code> test
case; this will make <span class="emphasis"><em>Squish</em></span> show the test's
<code class="filename">test.js</code> file in an editor window as shown in the
screenshot.
</p><p>
Now that we've recorded the test we can play it back, i.e.,
run it. This in itself is useful in that if the play back failed it
might mean that the application has been broken. Furthermore, the two
verifications we put in will be checked on play back as the screenshot
shows.
</p><p>
Inserting verification points during test recording is very convenient.
Here we inserted two in one go, but we can insert as many as we like as
often as we like during the test recording process. However, sometimes
we might forget to insert a verification, or later on we might want to
insert a new verification. We can easily insert additional verifications
into a recorded test script as we will see in the next section, <a class="xref" href="tutorials-web.html#tgs-vp-web" title="4.6.1.4. Inserting Additional Verification Points">Inserting Additional Verification Points (Section 4.6.1.4)</a>.
</p><h5><a id="idp40323944"></a> Running the Test </h5><p>
To run a test case in the IDE just click the <span class="guibutton">Run Test</span> (<span class="guiicon"><img src="images/ide/run.png"></img></span>) that appears
when the test case is hovered or selected in the <a class="xref" href="ide.views.html#ide.the-test-suites.view" title="8.2.19. Test Suites view">Test Suites view (Section 8.2.19)</a>.
When we have two or more test cases, we can run them all, one after another,
(or only those that are checked) by clicking <span class="guibutton">Run Test Suite</span> (<span class="guiicon"><img src="images/ide/run_test_suite.png"></img></span>).
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note:  Playback Failure "><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></img></td><th align="left"> Playback Failure </th></tr><tr><td align="left" valign="top"><p>
If you followed the instructions correctly, the test case will still fail to
play back. This is because the selection state of the HTML Input field was not
recorded/played back properly during the edit step,
so when <code class="function">typeText</code> played back,
the typed string was appended (or prepended, depending on the browser) to the
previous value. The recommended workaround is to
insert on the line above, a call to <a class="xref" href="rgs-webconvenience.html#web-HTML_TextBase.selectAll-function"><code class="function">HTML_TextBase.selectAll</code></a>
on the HTML element itself, from the <a class="xref" href="rgs-webconvenience.html" title="6.10. Web Object API">Web Object API (Section 6.10)</a>.
Examples in all script languages are shown below.
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

    clickButton(waitForObject(names.editButton_button))
    # manually inserted selectAll():
    waitForObject(names.oneitem_surnameEdit_text).selectAll()
    typeText(waitForObject(names.oneitem_surnameEdit_text), "Doe")
    clickButton(waitForObject(names.save_button))
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

    clickButton(waitForObject(names.froglogicAddressbookEditButtonButton));
    // manually inserted selectAll():
    waitForObject(names.froglogicAddressbookSurnameEditText).selectAll();
    typeText(waitForObject(names.froglogicAddressbookSurnameEditText), "Doe");
    clickButton(waitForObject(names.froglogicAddressbookSaveButton));
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

    clickButton(waitForObject($Names::editbutton_button));
    # manually inserted selectAll():
    waitForObject($Names::oneitem_surnameedit_text)-&gt;selectAll();
    typeText(waitForObject($Names::oneitem_surnameedit_text), "Doe");
    clickButton(waitForObject($Names::save_button));
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

    clickButton(waitForObject(Names::EditButton_button))
    # manually inserted selectAll() 
    waitForObject(Names::Oneitem_surnameEdit_text).selectAll()
    typeText(waitForObject(Names::Oneitem_surnameEdit_text), "Doe")
    clickButton(waitForObject(Names::Save_button))
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

    invoke clickButton [waitForObject $names::editButton_button]
    # manually inserted selectAll:
    invoke [waitForObject $names::oneitem_surnameEdit_text] selectAll
    invoke typeText [waitForObject $names::oneitem_surnameEdit_text] "Doe"
    invoke clickButton [waitForObject $names::Save_button]
</pre></div></td></tr></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: For command-line users"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></img></td><th align="left"><span class="emphasis"><em>For command-line users</em></span></th></tr><tr><td align="left" valign="top"><p>
As noted earlier, the <span class="application">squishserver</span> must always be running when
recording or running a test, or the <code class="code">--local</code> option
be provided to <span class="application">squishrunner</span>. (See <a class="xref" href="rg-cmdline.html#rgc-squishserver" title="7.4.4. squishserver">squishserver (Section 7.4.4)</a>
for further details.)
</p><p>
To play back a recorded test from the command line we execute the
<span class="application">squishrunner</span> program and specify the test suite our recorded script is
in and the test case we want to play. For example (assuming we are in
the directory that contains the test suite's directory):
</p><pre class="screen">
squishrunner --testsuite suite_js --testcase tst_general --local
</pre></td></tr></table></div><p>
If you look at the code in the screenshot (or the code snippet shown
below) you will see that it consists of lots of <a class="xref" href="rgs-squish.html#waitForObject-function"><code class="function">waitForObject</code></a> calls as parameters to various
other calls such as <a class="xref" href="rgs-webconvenience.html#web-typeText-function"><code class="function">typeText</code></a> and
<a class="xref" href="rgs-webconvenience.html#web-clickButton-function"><code class="function">clickButton</code></a>. The <a class="xref" href="rgs-squish.html#waitForObject-function"><code class="function">waitForObject</code></a> function waits until a GUI object
is ready to be interacted with (i.e., becomes visible and enabled), and
is then followed by some function that interacts with the object. The
typical interactions are activate (pop-up) a menu, click a menu option
or a button, or type in some text. (For a complete overview of
<span class="emphasis"><em>Squish</em></span>'s script commands see the <a class="xref" href="users-guide.html" title="Chapter 5. User Guide">User Guide (Chapter 5)</a>, the
<a class="xref" href="api.man.html" title="Chapter 6. API Reference Manual">API Reference Manual (Chapter 6)</a>, and the <a class="xref" href="ref.man.html" title="Chapter 7. Tools Reference Manual">Tools Reference Manual (Chapter 7)</a>. Objects are
identified by names that <span class="emphasis"><em>Squish</em></span> generates. (See <a class="xref" href="ug-accessing-objects.html" title="5.1. How to Identify and Access Objects">How to Identify and Access Objects (Section 5.1)</a> for full details.)
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Scripting Language Support"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></img></td><th align="left">Scripting Language Support</th></tr><tr><td align="left" valign="top"><p>
Although the screenshots only show the JavaScript test suite in action, for
the code snippets quoted here and throughout the tutorial, we show the
code for all the scripting languages that <span class="emphasis"><em>Squish</em></span> supports. In practice
you would normally only use one of them of course, so feel free to just
look at the snippets in the language you are interested in and skip the
others. (In the HTML version of this manual you can use the combobox at
the top of the page to select the language you use—this will hide
the code snippets in other languages.)
</p></td></tr></table></div><p>
The generated code is about 20 lines of code. Here's an extract that
just shows how <span class="emphasis"><em>Squish</em></span> records clicking the Add button,
typing in Jane Doe's details into the Add form, and clicking Save at the
end to close the form and update the table.
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

    clickButton(waitForObject(names.addButton_button))
    typeText(waitForObject(names.oneitem_forenameEdit_text), "Jane")
    typeText(waitForObject(names.oneitem_surnameEdit_text), "Doe")
    typeText(waitForObject(names.oneitem_emailEdit_text), "jane.doe@nowhere.com")
    typeText(waitForObject(names.oneitem_phoneEdit_text), "555 123 4567")
    clickButton(waitForObject(names.save_button))
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

    clickButton(waitForObject(names.addButtonButton));
    typeText(waitForObject(names.froglogicAddressbookForenameEditText), "Jane");
    typeText(waitForObject(names.froglogicAddressbookSurnameEditText), "Doe");
    typeText(waitForObject(names.froglogicAddressbookEmailEditText), "jane.doe@nowhere.com");
    typeText(waitForObject(names.froglogicAddressbookPhoneEditText), "123 555 4567");
    clickButton(waitForObject(names.froglogicAddressbookSaveButton));
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

    clickButton(waitForObject($Names::addbutton_button));
    typeText(waitForObject($Names::oneitem_forenameedit_text), "Jane");
    typeText(waitForObject($Names::oneitem_surnameedit_text), "Doe");
    typeText(waitForObject($Names::oneitem_emailedit_text), "jane.doe\@nowhere.com");
    typeText(waitForObject($Names::oneitem_phoneedit_text), "555 123 4567");
    clickButton(waitForObject($Names::save_button));
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

    clickButton(waitForObject(Names::AddButton_button))
    typeText(waitForObject(Names::Oneitem_forenameEdit_text), "Jane")
    typeText(waitForObject(Names::Oneitem_surnameEdit_text), "Doe")
    typeText(waitForObject(Names::Oneitem_emailEdit_text), "jane.doe@nowhere.com")
    typeText(waitForObject(Names::Oneitem_phoneEdit_text), "555 123 4567")
    clickButton(waitForObject(Names::Save_button))
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

    invoke clickButton [waitForObject $names::addButton_button]
    invoke typeText [waitForObject $names::oneitem_forenameEdit_text] "Jane"
    invoke typeText [waitForObject $names::oneitem_surnameEdit_text] "Doe"
    invoke typeText [waitForObject $names::oneitem_emailEdit_text] "jane.doe@nowhere.com"
    invoke typeText [waitForObject $names::oneitem_phoneEdit_text] "555 123 4567"
    invoke clickButton [waitForObject $names::Save_button]
</pre></div><p>
The <span class="guibutton">Add</span> and <span class="guibutton">Edit</span> buttons are
visible when when the AUT is showing the list of addresses. When the
<span class="guibutton">Add</span> or <span class="guibutton">Edit</span>
button is clicked, the list is
hidden and instead a form is shown where a new address can be added, or
where the selected address can be edited. The form has
<span class="guibutton">Save</span> and <span class="guibutton">Cancel</span>
buttons—when either of these are clicked, the form is hidden and
the list of addresses is shown once more.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note:  Object Names "><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></img></td><th align="left"> Object Names </th></tr><tr><td align="left" valign="top"><p>
Squish recordings refer to AUT objects using variables that begin with a
<code class="code">names.</code> prefix. This identifies them as <em class="firstterm">Symbolic Names</em>.
</p><p>
Each variable contains, as a value, the corresponding
<em class="firstterm">Real Name</em>, which can be string-based, or
implemented as a key-value mapping of properties to values. <span class="emphasis"><em>Squish</em></span> supports
several naming schemes, all of which can be used—and mixed—in
scripts. The advantage of using Symbolic Names is that if the application
changes in a way that results in different names being needed, we can simply
update <span class="emphasis"><em>Squish</em></span>'s Object Map (which relates symbolic names to real
names), and thereby avoid the need to change our test scripts. (See the
<a class="xref" href="rg-objectmap.html" title="7.11. Object Map">Object Map (Section 7.11)</a> and the <a class="xref" href="ide.views.html#ide.the-object-map.view" title="8.2.10. Object Map view">Object Map view (Section 8.2.10)</a> for more about the Object Map.)
</p></td></tr></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note:  Squish/Web object names "><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></img></td><th align="left"> Squish/Web object names </th></tr><tr><td align="left" valign="top"><p>
If you look at the recorded test (<code class="filename">tst_general</code>) or
in the Object Map you will see that <span class="emphasis"><em>Squish</em></span> for Web sometimes uses
<em class="firstterm">Hierarchical Names</em> that describe a path in the
the DOM (Document Object Model) of the HTML page under test.
For more information about naming and finding of web objects in Squish,
see <a class="xref" href="rg-namingconfig.html#rg-namegen-web" title="7.12.4. Name Generation Algorithm used by Squish for Web">Name Generation Algorithm used by Squish for Web (Section 7.12.4)</a> and <a class="xref" href="ugs-webapi.html#ugsweb-objects" title="5.3.1. How to Find and Query Web Objects">How to Find and Query Web Objects (Section 5.3.1)</a>.
</p></td></tr></table></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip:  Editor Context Menu "><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></img></td><th align="left"> Editor Context Menu </th></tr><tr><td align="left" valign="top"><p> When a Symbolic Name is under the cursor, the editor's context menu
allows you to <span class="guimenuitem">Open Symbolic Name</span>, showing its
entry in the <span class="guilabel">Object Map</span>, or <span class="guimenuitem">Convert to Real
Name</span>, which places its inline key-value representation in your
desired script language at the cursor, allowing you to hand-edit the values and
properties in your script.
</p></td></tr></table></div><p>
Now that we have seen how to record and play back a test and have seen
the code that <span class="emphasis"><em>Squish</em></span> generates, let's go a step further and make sure
that at particular points in the test's execution certain conditions hold.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="tgs-vp-web"></a>4.6.1.4. Inserting Additional Verification Points</h4></div></div></div><p>
In the previous section we saw how easy it is to insert verification
points during the recording of test scripts. Verification points can
also be inserted into existing test scripts, either by setting a
breakpoint and using the <span class="application">Squish IDE</span>, or simply by editing a test script and
putting in calls to <span class="emphasis"><em>Squish</em></span>'s test functions such as <a class="xref" href="rgs-squish.html#test.compare-function"><code class="function">test.compare</code></a> and <a class="xref" href="rgs-squish.html#test.verify-function"><code class="function">test.verify</code></a>.
</p><p>
<span class="emphasis"><em>Squish</em></span> supports many kinds of verification points: those that verify
that object properties have particular values—known as "Object Property
Verifications"; those that verify that an entire table has the contents
we expect—known as "Table Verifications"; those that verify
that two images match—known as "Screenshot Verifications"; and
a hybrid verification type that includes properties and screenshots
from multiple objects, known as "Visual Verifications".
In addition, it is possible to verify that a search image exists somewhere
on the screen, or that certain text is found by OCR.
The most commonly used kind is object property verifications, and it is
these that we will cover in the tutorial. For further reading, see <a class="xref" href="ug-vps.html" title="5.22. How to Create and Use Verification Points">How to Create and Use Verification Points (Section 5.22)</a>).
</p><p>
<span class="emphasis"><em>Regular</em></span> (non-scriptified) property
verification points are stored as XML files in the test case or test suite
resources, and contain the value(s) that need to be passed to
<code class="code">test.compare()</code>. These verification points can be reused across test
cases, and can verify many values in a single line of script code. </p><p> <span class="emphasis"><em>Scriptified</em></span> property verification points are direct
calls to the <a class="xref" href="rgs-squish.html#test.compare-function"><code class="function">test.compare</code></a> function, with two
arguments—the value of a particular property for a particular
object, and an expected value. We can manually insert calls to the <a class="xref" href="rgs-squish.html#test.compare-function"><code class="function">test.compare</code></a> function in a recorded or hand
written script, or we can get <span class="emphasis"><em>Squish</em></span> to insert them for us using scriptified
verification points. In the previous section we showed how to use the <span class="application">Squish IDE</span> to insert
verifications during recording. Here we will first show how to use the
<span class="application">Squish IDE</span> to insert verifications into an existing test script, and then we
will show how to insert a verification by hand.
</p><p>
Before asking <span class="emphasis"><em>Squish</em></span> to insert verification points, it is best to make
sure that we have a list of what we want to verify and when. There are many
potential verifications we could add to the test case, but since our concern
here is simply to show how to do it, we will only do two—we will verify
that the "Jane Doe" entry's email address and phone number match the ones
entered, and put the verifications immediately before the ones we inserted
during recording.
</p><p>
To insert a verification point using the IDE we start by putting a break
point in the script (whether recorded or manually written—it
does not matter to <span class="emphasis"><em>Squish</em></span>), at the point where we want to verify.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/web-tut-squishgui8.png" align="middle"></img><div class="caption"><p>
The <span class="application">Squish IDE</span> showing the <code class="literal">tst_general</code> test case with a breakpoint
</p></div></div></div><p>
As the above screenshot shows, we have set a breakpoint at line 22.
This is done simply by double-clicking, or right-clicking in the gutter (next to
the line number in the editor) and selecting the
<span class="guimenuitem">Add Breakpoint</span> context menu item.
We chose this line because it is just before the previously
recorded verification points. The screenshot shows the verifications
that were entered using the <span class="application">Squish IDE</span> during recording. Our additional
verifications will precede them. (Note that your line number may be
different if you recorded the test in a different way, for example,
using keyboard shortcuts rather than clicking menu items.)
</p><p>
Having set the breakpoint, we now run the test as usual by clicking the
<span class="guibutton">Run Test</span> (<span class="guiicon"><img src="images/ide/run.png"></img></span>) or by clicking the
<span class="guimenu">Run</span>|<span class="guimenuitem">Run Test Case
</span> menu option. Unlike a normal test run the
test will stop when the breakpoint is reached (i.e., at line 12, or at
whatever line you set), and <span class="emphasis"><em>Squish</em></span>'s main window will reappear (which
will probably obscure the AUT). At this point the <span class="application">Squish IDE</span> will
automatically switch to the <a class="xref" href="ide.main.window.html#ide.squish.test.debugging.perspective" title="8.1.2.3. Squish Test Debugging Perspective">Squish Test Debugging Perspective (Section 8.1.2.3)</a>.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Perspectives and Views"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></img></td><th align="left"><a id="perspectives-and-views-web"></a>Perspectives and Views</th></tr><tr><td align="left" valign="top"><p>
The <span class="application">Squish IDE</span> works just like the <a class="ulink" href="https://en.wikipedia.org/wiki/Eclipse_(software)" target="_blank">
Eclipse IDE</a>. If you aren't used to
Eclipse it is crucial to understand one key concept:
<span class="emphasis"><em>Views</em></span> and <span class="emphasis"><em>Perspectives</em></span>. In
Eclipse (and therefore in the <span class="application">Squish IDE</span>), a
<span class="emphasis"><em>View</em></span> is essentially a child window (perhaps a dock
window, or a tab in an existing window). And a
<span class="emphasis"><em>Perspective</em></span> is a collection of Views arranged
together. Both are accessible through the
<span class="guimenuitem">Window</span> menu.
</p><p>
The <span class="application">Squish IDE</span> is supplied with three Perspectives—the <a class="xref" href="ide.main.window.html#ide.squish.test.management.perspective" title="8.1.2.2. Squish Test Management Perspective">Squish Test Management Perspective (Section 8.1.2.2)</a> (which is the
Perspective that the <span class="application">Squish IDE</span> starts with, and the one we have seen in all
previous screenshots), <a class="xref" href="ide.main.window.html#ide.squish.test.debugging.perspective" title="8.1.2.3. Squish Test Debugging Perspective">Squish Test Debugging Perspective (Section 8.1.2.3)</a>, and <a class="xref" href="ide.main.window.html#ide.squish.spy.perspective" title="8.1.2.1. Squish Spy Perspective">Squish Spy Perspective (Section 8.1.2.1)</a>. You can change these
Perspectives to include additional Views (or to get rid of any Views
that you don't want), and you can create your own Perspectives with
exactly the Views you want. So if your windows change dramatically it
just means that the Perspective changed; you can always use the
<span class="guimenuitem">Window</span> menu to change back to the Perspective
you want. In practice, <span class="emphasis"><em>Squish</em></span> will automatically change perspective to
reflect the current situation, so it isn't really necessary to change
perspective manually.
</p></td></tr></table></div><p><a id="tutorial-getting-started-web-breakpoint-hit"></a>
As the screenshot below shows, when <span class="emphasis"><em>Squish</em></span> stops at a breakpoint
the <span class="application">Squish IDE</span> automatically changes to the <a class="xref" href="ide.main.window.html#ide.squish.test.debugging.perspective" title="8.1.2.3. Squish Test Debugging Perspective">Squish Test Debugging Perspective (Section 8.1.2.3)</a>. The perspective shows
the <a class="xref" href="ide.views.html#ide.the-variables.view" title="8.2.21. Variables view">Variables view (Section 8.2.21)</a>, the <a class="xref" href="ide.views.html#ide.the-editor.view" title="8.2.6. Editor view">Editor view (Section 8.2.6)</a>, the <a class="xref" href="ide.views.html#ide.the-debug.view" title="8.2.5. Debug view">Debug view (Section 8.2.5)</a>, the <a class="xref" href="ide.views.html#ide.the-application-objects.view" title="8.2.1. Application Objects view">Application Objects view (Section 8.2.1)</a>, and the <a class="xref" href="ide.views.html#ide.the-properties.view" title="8.2.12. Properties view">Properties view (Section 8.2.12)</a>, <a class="xref" href="ide.views.html#ide.the-methods.view" title="8.2.9. Methods view">Methods view (Section 8.2.9)</a>, and <a class="xref" href="ide.views.html#ide.the-test-results.view" title="8.2.18. Test Results view">Test Results view (Section 8.2.18)</a>.
</p><p>
To insert a verification point, we can expand items in the <span class="guilabel">Application
Objects</span> view until we find the object we want to verify, or we can use
the <a class="xref" href="ide.views.html#object-picker">Object Picker</a> (<span class="guiicon"><img src="images/ide/pick-application-object.png"></img></span>) toolbar button to visually pick the relevant object in the AUT.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/web-tut-squishgui9.png" align="middle"></img><div class="caption">Picking an object to verify in the Application Objects view
</div></div></div><p>
The normal <a class="xref" href="ide.main.window.html#ide.squish.test.management.perspective" title="8.1.2.2. Squish Test Management Perspective">Squish Test Management Perspective (Section 8.1.2.2)</a> can
be returned to at any time by choosing it from the
<span class="guimenuitem">Window</span> menu (or by clicking its toolbar
button), although the <span class="application">Squish IDE</span> will automatically return to it if you stop
the script or run it to completion.
</p><p>
In this example we want to verify the new row's email address and
phone number (since we already have verifications for the forename and
surname). It is easiest to find them in the AUT rather than navigate the
<a class="xref" href="ide.views.html#ide.the-application-objects.view" title="8.2.1. Application Objects view">Application Objects view (Section 8.2.1)</a>. First click the
<a class="xref" href="ide.views.html#object-picker">Object Picker</a> (<span class="guiicon"><img src="images/ide/pick-application-object.png"></img></span>) toolbar button then click new row's
email entry (i.e., “<span class="quote">jane.doe@nowhere.com</span>”) in the AUT. Now
back in the <span class="application">Squish IDE</span> in the <a class="xref" href="ide.views.html#ide.the-properties.view" title="8.2.12. Properties view">Properties view (Section 8.2.12)</a> check
the <span class="property">innerText</span> property.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/tut-squish-vp2-web.png" align="middle"></img><div class="caption">Choosing a property value to verify
</div></div></div><p>
At this point the verification point has <span class="emphasis"><em>not</em></span> been
added to the test script. We could easily add it by clicking the
<span class="guibutton">Save and Insert Verifications</span> button.
But before doing that we'll add one more thing to be
verified.
</p><p>
Click the <a class="xref" href="ide.views.html#object-picker">Object Picker</a> (<span class="guiicon"><img src="images/ide/pick-application-object.png"></img></span>) and then click the
new row's phone number. Now back in the <span class="application">Squish IDE</span> in the <a class="xref" href="ide.views.html#ide.the-properties.view" title="8.2.12. Properties view">Properties view (Section 8.2.12)</a> check the <span class="property">innerText</span>
property. Now both verifications will appear in the <a class="xref" href="ide.views.html#ide.verification.point.creator.view" title="8.2.22. Verification Point Creator view">Verification Point Creator view (Section 8.2.22)</a> as the screenshot shows.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/tut-squish-vp3-web.png" align="middle"></img><div class="caption">Choosing several property values to verify
</div></div></div><p>
We have now said that we expect these properties to have the values
shown, that is, an email address of “<span class="quote">jane.doe@nowhere.com</span>”
and phone number of “<span class="quote">555 123 4567</span>”. We
<span class="emphasis"><em>must</em></span> click the <span class="guibutton">Insert</span> button
to actually insert the verification point, so do that now.
</p><p>
We don't need to continue running the test now, so we can either stop
running the test at this point (by clicking the
<span class="guibutton">Stop</span> toolbar button), or we can continue (by
clicking the <span class="guibutton">Resume</span> button).
</p><p>
Once we have finished inserting verifications and stopped or finished
running the test we should now disable the break point. Just right click
the break point and click the <span class="guimenuitem">Disable
Breakpoint</span> menu option in the context menu. We are now
ready to run the test without any breakpoints but with the verification
points in place. Click the <span class="guibutton">Run Test</span> (<span class="guiicon"><img src="images/ide/run.png"></img></span>). This
time we will get some additional test results—as the screenshot
shows—one of which we have expanded to show its details. (We have
also selected the lines of code that <span class="emphasis"><em>Squish</em></span> inserted to perform the
verifications—notice that the code is structurally identical to
the code inserted during recording.)
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/tut-squish6-web.png" align="middle"></img><div class="caption">The newly inserted verification points in action
</div></div></div><p>
These particular verification points generate four tests comparing
the forename, surname, email, and phone number of the newly inserted
entry.
</p><p>
Another way to insert verification points is to write them in code.
In theory, we can just add our own calls to <span class="emphasis"><em>Squish</em></span>'s <code class="classname">test</code>
functions such as <a class="xref" href="rgs-squish.html#test.compare-function"><code class="function">test.compare</code></a> and <a class="xref" href="rgs-squish.html#test.verify-function"><code class="function">test.verify</code></a> anywhere we like in an existing
script. In practice, it is best to make sure that <span class="emphasis"><em>Squish</em></span> knows about
the objects we want to verify first so that it can find them when the
test is run. This involves a very similar procedure to inserting them using the <span class="application">Squish IDE</span>.

</p><div class="orderedlist"><ol type="1"><li><p>
Set a breakpoint where we intend to add verifications.
</p></li><li><p>
Run the test script until it stops.
</p></li><li><p>Navigate in the
<a class="xref" href="ide.views.html#ide.the-application-objects.view" title="8.2.1. Application Objects view">Application Objects view (Section 8.2.1)</a> until we find the
object we want to verify—or use the <a class="xref" href="ide.views.html#object-picker">Object Picker</a> (<span class="guiicon"><img src="images/ide/pick-application-object.png"></img></span>) to visually choose it
in the AUT.</p></li><li><p>
Right-click the
object we are interested in and click the <span class="guimenuitem">Add to Object
Map</span> context menu option. This will ensure that <span class="emphasis"><em>Squish</em></span>
can access the object. </p></li><li><p>Right click again and click the
<span class="guimenuitem">Copy Symbolic Name</span> context
menu option—this gives us the name of the object that <span class="emphasis"><em>Squish</em></span>
will use to identify it. </p></li></ol></div><p>
</p><p>
Now we can edit the test script to add our
own verification and finish or stop the execution. (Don't forget to
disable the break point once it isn't needed any more.)
</p><p>
Although we can write our test script code to be exactly the same style
as the automatically generated code, it is usually clearer and easier to
do things in a slightly different style, as we will explain in a moment.
</p><p>
For our manual verifications we want to check the number of addresses
present in the <code class="code">&lt;table&gt;</code> after loading the
initial addresses, then after the new address is
added, and finally after the second address is removed.
</p><p>
The original test recording does not store details of the
<code class="code">&lt;table&gt;</code> in <span class="emphasis"><em>Squish</em></span>'s Object Map because they aren't
needed for the test we recorded. But for us to count the number of rows
we must have access to the table. This is easily done. First we add a
breakpoint to one of the lines (it doesn't matter which—so long as
the list of addresses is showing at the time the breakpoint
happens—we used line 5). Then, we run the test and when it is
stopped by the breakpoint we click the <a class="xref" href="ide.views.html#ide.the-application-objects.view" title="8.2.1. Application Objects view">Application Objects view (Section 8.2.1)</a>'s
<a class="xref" href="ide.views.html#object-picker">Object Picker</a> (<span class="guiicon"><img src="images/ide/pick-application-object.png"></img></span>) toolbar button. Then we click the entire
table in the AUT. (This can be slightly tricky—just hover until
the red outline includes the whole table.) Back in the <span class="application">Squish IDE</span> we
right-click the table in the <span class="application">Squish IDE</span>'s <a class="xref" href="ide.views.html#ide.the-application-objects.view" title="8.2.1. Application Objects view">Application Objects view (Section 8.2.1)</a> and click the
<span class="guimenuitem">Add to Object Map</span> context menu option. Then
we right-click again and click the <span class="guimenuitem">Copy Symbolic Name</span>
context menu option—then paste this name into
the test script where it will become part of a <code class="function">numberOfRows</code>
function. (Don't forget to remove the breakpoint afterwards, since it
isn't needed anymore.)
</p><p>
The screenshot shows the line of code we entered to get one of these
three verifications; it also shows the results of running the test
script. (We will see the tiny custom <code class="function">numberOfRows</code> function
in a moment.)
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/tut-squish7-web.png" align="middle"></img><div class="caption">Manually entered verification points in action
</div></div></div><p>
Here is the code we entered manually for the first verification for all
the scripting languages that <span class="emphasis"><em>Squish</em></span> supports. Naturally, you only need
to look at the code for the language that you will be using for your own
tests. (For all the row count verifications we just did calls to the <a class="xref" href="rgs-squish.html#test.verify-function"><code class="function">test.verify</code></a> function—or to the <a class="xref" href="rgs-squish.html#test.compare-function"><code class="function">test.compare</code></a> function for Tcl since it's more
convenient.)
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

    test.compare(numberOfRows(), 125)
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

    test.compare(numberOfRows(), 125)
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

    test::compare(numberOfRows(), 125);
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

    Test.compare(numberOfRows, 125)
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

    test compare [numberOfRows] 125
</pre></div><p>
And here is the custom <code class="function">numberOfRows</code> function that our
verification depends upon.
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

def numberOfRows():
    table = waitForObject(names.dOCUMENT_HTML1_BODY1_DIV1_DIV2_DIV3_DIV3_DIV1_TABLE1)
    results = table.evaluateXPath(".//TR[contains(@class, 'jqgrow')]")
    return results.snapshotLength
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

function numberOfRows() {
    var table = waitForObject(names.dOCUMENTHTML1BODY1DIV1DIV2DIV3DIV3DIV1TABLE1);
    var results = table.evaluateXPath(".//TR[contains(@class, 'jqgrow')]");
    return results.snapshotLength;
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

sub numberOfRows
{
    my $table = waitForObject($Names::document_html1_body1_div1_div2_div3_div3_div1_table1);
    my $results = $table-&gt;evaluateXPath(".//TR[contains(\@class, 'jqgrow')]");
    return $results-&gt;snapshotLength;
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

def numberOfRows
    table = waitForObject(Names::DOCUMENT_HTML1_BODY1_DIV1_DIV2_DIV3_DIV3_DIV1_TABLE1)
    results = table.evaluateXPath(".//TR[contains(@class,'jqgrow')]")
    results.snapshotLength
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

proc numberOfRows {} {
    set table [waitForObject \
        $names::DOCUMENT_HTML1_BODY1_DIV1_DIV2_DIV3_DIV3_DIV1_TABLE1]
    set results [invoke $table evaluateXPath {.//TR[contains(@class,'jqgrow')]}]
    return [property get $results snapshotLength]
}
</pre></div><p>
When writing scripts by hand, we use <span class="emphasis"><em>Squish</em></span>'s <code class="code">test</code>
module's functions to verify conditions at certain points during our
test script's execution. As the screenshot (and the code snippets)
show, we begin by retrieving a reference to the object we are interested
in. Using the <a class="xref" href="rgs-squish.html#waitForObject-function"><code class="function">waitForObject</code></a> function is
standard practice for manually written test scripts. This function waits
for the object to be available (i.e., visible and enabled), and then
returns a reference to it. (Otherwise it times out and raises a
catchable exception.) We then use this reference to access the item's
properties. In this case we get a reference to the
<code class="code">&lt;table&gt;</code> and evaluate an XPath query (see <a class="xref" href="ugs-webapi.html#ugsweb-xpath" title="5.3.2. How to Use XPath">How to Use XPath (Section 5.3.2)</a>). The query used here says find all
<code class="code">&lt;tr&gt;</code> tags under the given element (i.e., in the
table) which have a <span class="property">class</span> property
that contains the value “<span class="quote">jqgrow</span>”. This produces an <a class="xref" href="rgs-webconvenience.html#web-HTML_XPathResult-class" title="6.10.41. HTML_XPathResult Class">HTML_XPathResult Class (Section 6.10.41)</a> object containing all the
matching <code class="code">&lt;tr&gt;</code>s. Since each address has a single
row we know that the number of <code class="code">&lt;tr&gt;</code> tags with class
“<span class="quote">jqgrow</span>” is equal to the number of rows, so we simply
return the number of items in the result using its <a class="xref" href="rgs-webconvenience.html#web-HTML_XPathResult.snapshotLength-property">HTML_XPathResult.snapshotLength</a> property.
</p><p>
We will see more examples of manually written code shortly, in the
<a class="xref" href="tutorials-web.html#tut-web-creating-manual-tests" title="4.6.1.5. Creating Tests by Hand">Creating Tests by Hand (Section 4.6.1.5)</a> section, and
further examples are in the <a class="xref" href="users-guide.html" title="Chapter 5. User Guide">User Guide (Chapter 5)</a>.
</p><p>
For complete coverage of verification points, see <a class="xref" href="ug-vps.html" title="5.22. How to Create and Use Verification Points">How to Create and Use Verification Points (Section 5.22)</a> in the <a class="xref" href="users-guide.html" title="Chapter 5. User Guide">User Guide (Chapter 5)</a>.
</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="test-results-web.1"></a>4.6.1.4.1. Test Results</h5></div></div></div><p>
After each test run finishes, the test results—including those
for the verification points—are shown in the Test Results view at
the bottom of the <span class="application">Squish IDE</span>.
</p><p>
This is a detailed report of the test run and would also contain details
of any failures or errors, etc. If you click on a Test Results item, the
<span class="application">Squish IDE</span> highlights the script line which generated the test result. And if
you expand a Test Results item, you can see additional details of the
test.
</p><div class="sidebar"><p class="title"><b>Processing Test Results</b></p><p>
<span class="emphasis"><em>Squish</em></span>'s interface for test results is very flexible. By implementing
custom report generators it is possible to process test results in many
different ways, for example to store them in a database, or to output
them as HTML files. The default report generator simply prints the
results to <code class="filename">stdout</code> when <span class="emphasis"><em>Squish</em></span> is run from the
command line, or to the Test Results view when <span class="emphasis"><em>Squish</em></span>'s IDE is being
used. You can save the test results from the <span class="emphasis"><em>Squish</em></span> IDE as XML by
right clicking on the Test Results and choosing the <span class="guimenuitem">Export
Results...</span> menu option. For a list of report generators,
see <a class="xref" href="rg-cmdline.html#rg-squishrunner-report-generators" title="7.4.3.6.  squishrunner --reportgen: Generating Reports"> <code class="option">squishrunner --reportgen</code>: Generating Reports (Section 7.4.3.6)</a>. It is also possible to
log test results directly to a database; see <a class="xref" href="how.to.access.databases.from.squish.test.scripts.html" title="5.18. How to Access Databases from Squish Test Scripts">How to Access Databases from Squish Test Scripts (Section 5.18)</a>.
</p><p>
If you run tests on the command line using <span class="application">squishrunner</span>, you can also
export the results in different formats and save them to files. See the
sections <a class="xref" href="rg-regressiontesting.html#rgr-processresults" title="7.1.3. Processing Test Results">Processing Test Results (Section 7.1.3)</a> and <a class="xref" href="ugs-teststatements.html" title="5.9. How to Use Test Statements">How to Use Test Statements (Section 5.9)</a> in the <a class="xref" href="users-guide.html" title="Chapter 5. User Guide">User Guide (Chapter 5)</a> for
more information.
</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="tut-web-creating-manual-tests"></a>4.6.1.5. Creating Tests by Hand</h4></div></div></div><p>
Now that we have seen how to record a test and modify it by inserting
verification points, we are ready to see how to create tests manually.
The easiest way to do this is to modify and refactor recorded tests,
although it is also perfectly possible to create manual tests from
scratch.
</p><p>
Potentially the most challenging part of writing manual tests is to use
the right object names, but in practice, this is rarely a problem. We
can either copy the symbolic names that <span class="emphasis"><em>Squish</em></span> has already added to
the Object Map when recording previous tests, or we can copy object
names directly from recorded tests. And if we haven't recorded any tests
and are starting from scratch we can use the <span class="application">Spy</span>. We do this by
clicking the <span class="guibutton">Launch AUT</span> toolbar button. This
starts the AUT and switches to the <a class="xref" href="ide.main.window.html#ide.squish.spy.perspective" title="8.1.2.1. Squish Spy Perspective">Squish Spy Perspective (Section 8.1.2.1)</a>. We can then interact with the
AUT until the object we are interested in is visible. Then, inside the
<span class="application">Squish IDE</span> we can navigate to the object in the Application Objects
view—or use the <a class="xref" href="ide.views.html#object-picker">Object Picker</a> (<span class="guiicon"><img src="images/ide/pick-application-object.png"></img></span>) toolbar button—and
use the context menu to both add the object to the Object Map (so that
<span class="emphasis"><em>Squish</em></span> will remember it) and to the clipboard (so that we can paste it
into our test script). And at the end we can click the <span class="guibutton">Quit
AUT</span> toolbar button to terminate the AUT and return <span class="emphasis"><em>Squish</em></span>
to the <a class="xref" href="ide.main.window.html#ide.squish.test.management.perspective" title="8.1.2.2. Squish Test Management Perspective">Squish Test Management Perspective (Section 8.1.2.2)</a>. (See <a class="xref" href="ug-editdebug.html#uged-spy" title="5.21.3. How to Use the Spy">How to Use the Spy (Section 5.21.3)</a> in the <a class="xref" href="users-guide.html" title="Chapter 5. User Guide">User Guide (Chapter 5)</a> for more
details on using the <span class="application">Spy</span>.)
</p><p>
We can view the Object Map by clicking the <span class="guibutton">Object
Map</span> toolbar button (see also, the <a class="xref" href="ide.views.html#ide.the-object-map.view" title="8.2.10. Object Map view">Object Map view (Section 8.2.10)</a>). Every application object that
<span class="emphasis"><em>Squish</em></span> interacts with is listed here, either as a top-level object, or
as a child object (the view is a tree view). We can retrieve the
symbolic name used by <span class="emphasis"><em>Squish</em></span> in recorded scripts by right-clicking the
object we are interested in and then clicking the context menu's Copy
item. This is useful for when we want to modify existing test scripts or
when we want to create test scripts from scratch, as we will see later
on in the tutorial.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/tut-squish-omap-web.png" align="middle"></img><div class="caption"><p><span class="emphasis"><em>Squish</em></span>'s Object Map
</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="tut-web-modifying-and-refactoring-recorded-tests"></a>4.6.1.5.1. Modifying and Refactoring Recorded Tests</h5></div></div></div><p>
Suppose we want to test the AUT's <span class="guilabel">Add</span> functionality by
adding three new names and addresses. We could record such a test but it is
just as easy to do everything in code. The steps we need the test script
to do are: start the application, then for each new name and address, click the
<span class="guilabel">Add</span> button, then fill in the details, and
click <span class="guilabel">Save</span>. We also want to
verify after clicking New that there are no rows of data and at the end that
there are three rows. We will also refactor as we go, to make our code
as neat and modular as possible.
</p><p>
First we must create a new test case. Click
<span class="guimenu">File</span>|<span class="guimenuitem">New Test
Case...</span> and set the test case's name to be
<code class="filename">tst_adding</code>. <span class="emphasis"><em>Squish</em></span> will automatically create a
<code class="filename">test.js</code> (or <code class="filename">test.py</code>, and
so on) file.
</p><p>
Command line users can simply create a <code class="filename">tst_adding</code>
directory inside the test suite's directory and create and edit the
<code class="filename">test.js</code> file (or <code class="filename">test.py</code> and
so on) within that directory.
</p><p>
The first thing we need is a way to start the AUT. Here are the first
few lines from the <span class="emphasis"><em>recorded</em></span>
<code class="filename">tst_general</code> script:
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

import names

def main():
    startBrowser("http://localhost:9090/AddressBook.html")
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

import * as names from 'names.js';

function main() {
    startBrowser("http://localhost:9090/AddressBook.html");
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

require 'names.pl';

sub main
{
    startBrowser("http://localhost:9090/AddressBook.html");
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

require 'squish'
require 'names'
include Squish

def main
    startBrowser("http://localhost:9090/AddressBook.html")
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

source [findFile "scripts" "names.tcl"]


proc main {} {
    invoke startBrowser "http://localhost:9090/AddressBook.html"
</pre></div><p>
Notice that the pattern in the code is simple: import the object map first,
and then in <code class="function">main</code>, start the AUT, then wait for the page to
be ready.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></img></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
It may seem a waste to put our functions in
<code class="filename">tst_adding</code> because we could also use them in
<code class="filename">tst_general</code> and in other test cases. However, to
keep the tutorial simple we will put the code in the
<code class="filename">tst_adding</code> test case. It is of course very easy to
create shared scripts, but we defer coverage of that to the user guide.
(See <a class="xref" href="ug-shareddata.html" title="5.23. How to Create and Use Shared Data and Shared Scripts">How to Create and Use Shared Data and Shared Scripts (Section 5.23)</a> for how to share scripts.)
</p></td></tr></table></div><p>
Sometimes the AUT will appear to freeze during test execution.
When this happens, just wait for <span class="emphasis"><em>Squish</em></span> to time out the AUT
(about 20 seconds), and then it will pop up an
<a class="xref" href="ide.dialogs.html#ide.object.not.found.dialog" title="8.3.14. Object Not Found dialog">Object Not Found dialog (Section 8.3.14)</a> indicating an error
like this:

</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/web-tut-object-not-found.png" align="middle"></img><div class="caption">Object Not Found Dialog</div></div></div><p>

don't worry! It just means that <span class="emphasis"><em>Squish</em></span> doesn't have an object with the
given name in the Object Map. From here, we can
<span class="guibutton">Pick New Object</span>, <span class="guibutton">Debug</span>
<span class="guibutton">Throw Error</span>, or after picking a new object,
<span class="guibutton">Retry</span>. Picking a new object will update the object
map entry for the symbolic name.
In addition to the <a class="xref" href="ide.views.html#object-picker">Object Picker</a> (<span class="guiicon"><img src="images/ide/pick-application-object.png"></img></span>), we can also use the <span class="application">Spy</span>'s <a class="xref" href="ide.views.html#ide.the-application-objects.view" title="8.2.1. Application Objects view">Application Objects view (Section 8.2.1)</a> to locate the objects we
are interested in and use the context menu to access real or symbolic names
of them.
</p><p>
We've spent a bit of time on the issue of naming since it is probably
the part of writing scripts that leads to the most error messages
(usually of the "object ... not found" kind shown above.) Once we have
identified the objects we are going to access in our tests, writing test
scripts using <span class="emphasis"><em>Squish</em></span> is very straightforward. And of course you can
almost certainly use the scripting language you are most familiar with
since <span class="emphasis"><em>Squish</em></span> supports the most popular ones available.
</p><p>
We are now almost ready to write our own test script. It is probably
easiest to begin by recording a dummy test. So click
<span class="guimenu">File</span>|<span class="guimenuitem">New Test
Case...</span> and set the test case's name to be
<code class="filename">tst_dummy</code>. Then click the dummy test case's
<span class="guibutton">Record</span> (<span class="guiicon"><img src="images/ide/record.png"></img></span>).
Once the AUT starts, click the <span class="guibutton">New</span> button then click
<span class="guibutton">OK</span>. This will clear
out the example data and leave the table empty and ready for new data.
Click the <a class="xref" href="ide.main.window.html#ide-the-controlbar-window" title="8.1.3. Control Bar Window">Control Bar Window (Section 8.1.3)</a>'s <span class="guibutton">Stop
Recording</span> button. Replay this test just to confirm that
everything works okay. The sole purpose of this is to make sure that
<span class="emphasis"><em>Squish</em></span> adds the necessary names to the Object Map since it is probably
quicker to do it this way than to use the <span class="application">Spy</span> for every object of
interest. After replaying the dummy test you can delete it if you want
to.
</p><p>
With all the object names we need in the Object Map, we can now write our
own test script completely from scratch. We will start with the
<code class="code">main</code> function, and then we will look at the supporting
functions that the <code class="code">main</code> function uses.
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

import names

def main():
    startBrowser("http://localhost:9090/AddressBook.html")
    confirmPopup(names.newButton_button)
    test.verify(numberOfRows() == 0, "%d" % numberOfRows())
    data = [("Andy", "Beach", "andy.beach@nowhere.com", "555 123 6786"),
            ("Candy", "Deane", "candy.deane@nowhere.com", "555 234 8765"),
            ("Ed", "Fernleaf", "ed.fernleaf@nowhere.com", "555 876 4654")]
    for oneNameAndAddress in data:
        addNameAndAddress(oneNameAndAddress)
    test.compare(numberOfRows(), 3)
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

import * as names from 'names.js';

function main() {
    startBrowser("http://localhost:9090/AddressBook.html");
    confirmPopup(names.newButtonButton);
    test.verify(numberOfRows() == 0);
    var data = new Array(
        new Array("Andy", "Beach", "andy.beach@nowhere.com", "555 123 6786"),
        new Array("Candy", "Deane", "candy.deane@nowhere.com", "555 234 8765"),
        new Array("Ed", "Fernleaf", "ed.fernleaf@nowhere.com", "555 876 4654"));
    for (var row = 0; row &lt; data.length; ++row)
        addNameAndAddress(data[row]);
    test.compare(numberOfRows(), 3);
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

require 'names.pl';

sub main
{
    startBrowser("http://localhost:9090/AddressBook.html");
    confirmPopup($Names::newbutton_button);
    test::verify(numberOfRows() == 0);
    my @data = (["Andy", "Beach", "andy.beach\@nowhere.com", "555 123 6786"],
                ["Candy", "Deane", "candy.deane\@nowhere.com", "555 234 8765"],
                ["Ed", "Fernleaf", "ed.fernleaf\@nowhere.com", "555 876 4654"]);
    foreach $oneNameAndAddress (@data) {
        addNameAndAddress(@{$oneNameAndAddress});
    }
    test::compare(numberOfRows(), 3);
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

require 'names';

# encoding: UTF-8
require 'squish'
include Squish

def main
    startBrowser("http://localhost:9090/AddressBook.html")
    confirmPopup(Names::NewButton_button)
    Test.verify(numberOfRows == 0)
    data = [["Andy", "Beach", "andy.beach@nowhere.com", "555 123 6786"],
          ["Candy", "Deane", "candy.deane@nowhere.com", "555 234 8765"],
          ["Ed", "Fernleaf", "ed.fernleaf@nowhere.com", "555 876 4654"]]
    data.each do |oneNameAndAddress|
        addNameAndAddress(oneNameAndAddress)
    end
    Test.compare(numberOfRows, 3)
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

source [findFile "scripts" "names.tcl"]


proc main {} {
    invoke startBrowser "http://localhost:9090/AddressBook.html"
    confirmPopup $names::newButton_button
    test compare [numberOfRows] 0
    set data [list \
        [list "Andy" "Beach" "andy.beach@nowhere.com" "555 123 6786"] \
        [list "Candy" "Deane" "candy.deane@nowhere.com" "555 234 8765"] \
        [list "Ed" "Fernleaf" "ed.fernleaf@nowhere.com" "555 876 4654"] ]
    for {set i 0} {$i &lt; [llength $data]} {incr i} {
        addNameAndAddress [lindex $data $i]
    }
    test compare [numberOfRows] 3
}
</pre></div><p>
We begin by starting the AUT with a call to the <a class="xref" href="rgs-webconvenience.html#web-startBrowser-function"><code class="function">startBrowser</code></a> function parametrized by the name of
the web page we want it to start with. This means that <span class="emphasis"><em>Squish</em></span> won't
ask us to confirm the page to load. Next we call a
custom <code class="function">confirmPopup</code> function that clicks
<span class="guibutton">New</span> (which in turn causes an OK/Cancel dialog to appear),
and confirms (i.e., clicks <span class="guibutton">OK</span>). This will empty the
table. (We copied the name of the New button from the Object Map—it was
put there by the dummy test we recorded.) Next we call the custom
<code class="function">numberOfRows</code> function
that we created earlier to verify that the table is empty.
</p><p>
Next, we create some sample data and call a custom
<code class="code">addNameAndAddress</code> function to populate the table with the
data using the AUT's Add dialog. And finally, we again compare the table's row
count, this time to the number of rows in our sample data.
</p><p>
We will now review two of the three supporting functions, so as to
cover all the code in the <code class="filename">tst_adding</code> test case,
starting with the <code class="function">confirmPopup</code> function. (The third
function, <code class="function">numberOfRows</code> was discussed earlier.)
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

def confirmPopup(button):
    clickButton(waitForObject(button))
    snooze(1.8)
    closeConfirm(names.confirmPopup, True)
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

function confirmPopup(button) {
    clickButton(waitForObject(button));
    snooze(1.8);
    closeConfirm(names.confirmPopup, true);
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

sub confirmPopup
{
    my ($button) = @_;
    clickButton(waitForObject($button));
    snooze(1.8);
    closeConfirm($Names::confirmpopup, 1);
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

def confirmPopup(button)
    clickButton(waitForObject(button))
    snooze(1.8)
    closeConfirm(Names::ConfirmPopup, true)
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

proc confirmPopup {button} {
    invoke clickButton [waitForObject $button]
    snooze 1.8
    invoke closeConfirm $names::ConfirmPopup true
}
</pre></div><p>
This function is called with the symbolic name of the button we want to
click and confirm. (The name was copied from the Object Map.) After
clicking we force <span class="emphasis"><em>Squish</em></span> to wait a short time (1.8 seconds using the
<a class="xref" href="rgs-squish.html#snooze-function"><code class="function">snooze</code></a> function) and then
close the dialog that popped up using the <a class="xref" href="rgs-webconvenience.html#web-closeConfirm-function"><code class="function">closeConfirm</code></a> function. The first argument can
be any text but the second must either be <code class="code">true</code> (which means
click <span class="guibutton">OK</span>) or <code class="code">false</code> (which means click
<span class="guibutton">Cancel</span>). So here we have clicked <span class="guibutton">OK</span>.
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

def addNameAndAddress(oneNameAndAddress):
    clickButton(waitForObject(names.addButton_button))
    typeText(waitForObject(names.oneitem_forenameEdit_text), oneNameAndAddress[0])
    typeText(waitForObject(names.oneitem_surnameEdit_text), oneNameAndAddress[1])
    typeText(waitForObject(names.oneitem_emailEdit_text), oneNameAndAddress[2])
    typeText(waitForObject(names.oneitem_phoneEdit_text), oneNameAndAddress[3])
    clickButton(waitForObject(names.save_button))
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

function addNameAndAddress(oneNameAndAddress) {
    clickButton(waitForObject(names.addButtonButton));
    typeText(waitForObject(names.froglogicAddressbookForenameEditText), oneNameAndAddress[0]);
    typeText(waitForObject(names.froglogicAddressbookSurnameEditText), oneNameAndAddress[1]);
    typeText(waitForObject(names.froglogicAddressbookEmailEditText), oneNameAndAddress[2]);
    typeText(waitForObject(names.froglogicAddressbookPhoneEditText), oneNameAndAddress[3]);
    clickButton(waitForObject(names.saveButton));
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

sub addNameAndAddress
{
    my (@oneNameAndAddress) = @_;
    clickButton(waitForObject($Names::addbutton_button));
    typeText(waitForObject($Names::oneitem_forenameedit_text), $oneNameAndAddress[0]);
    typeText(waitForObject($Names::oneitem_surnameedit_text), $oneNameAndAddress[1]);
    typeText(waitForObject($Names::oneitem_emailedit_text), $oneNameAndAddress[2]);
    typeText(waitForObject($Names::oneitem_phoneedit_text), $oneNameAndAddress[3]);
    clickButton(waitForObject($Names::save_button));
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

def addNameAndAddress(oneNameAndAddress)
    clickButton(waitForObject(Names::AddButton_button))
    typeText(waitForObject(Names::Oneitem_forenameEdit_text), oneNameAndAddress[0])
    typeText(waitForObject(Names::Oneitem_surnameEdit_text), oneNameAndAddress[1])
    typeText(waitForObject(Names::Oneitem_emailEdit_text), oneNameAndAddress[2])
    typeText(waitForObject(Names::Oneitem_phoneEdit_text), oneNameAndAddress[3])
    clickButton(waitForObject(Names::Save_button))
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

proc addNameAndAddress {oneNameAndAddress} {
    invoke clickButton [waitForObject $names::addButton_button]
    invoke typeText [waitForObject $names::oneitem_forenameEdit_text] [lindex $oneNameAndAddress 0]
    invoke typeText [waitForObject $names::oneitem_surnameEdit_text] [lindex $oneNameAndAddress 1]
    invoke typeText [waitForObject $names::oneitem_emailEdit_text] [lindex $oneNameAndAddress 2]
    invoke typeText [waitForObject $names::oneitem_phoneEdit_text] [lindex $oneNameAndAddress 3]
    invoke clickButton [waitForObject $names::Save_button]
}
</pre></div><p>
For each set of name and address data we click the <span class="guibutton">Add</span>
button to make
the <span class="guilabel">Add</span> form visible. Then for each value received we
populate the appropriate field by waiting for the relevant <code class="code">text</code>
field to be
ready and then typing in the text using the <a class="xref" href="rgs-webconvenience.html#web-setText-function"><code class="function">setText</code></a> function.
And at the end we click the form's Save button. We got the line at the
heart of the function by copying it from the recorded
<code class="filename">tst_general</code> test and simply parametrizing it by
the field name and text. Similarly, we copied the code for clicking the
Save button from the <code class="filename">tst_general</code> test case's code.
</p><p>
The entire test is around 35 lines of code—and would be even less
if we put some of the common functions (such as
<code class="function">confirmPopup</code> and <code class="function">numberOfRows</code>) in
a shared script. And much of the code was copied directly from the
recorded test, and in some cases parametrized.
</p><p>
This should be sufficient to give a flavor of writing test scripts for
an AUT. Keep in mind that <span class="emphasis"><em>Squish</em></span> provides far more functionality than
we used here, (all of which is covered in the <a class="xref" href="api.man.html" title="Chapter 6. API Reference Manual">API Reference Manual (Chapter 6)</a> and the <a class="xref" href="ref.man.html" title="Chapter 7. Tools Reference Manual">Tools Reference Manual (Chapter 7)</a>). And
<span class="emphasis"><em>Squish</em></span> also provides access to the entire public APIs of the AUT's
objects.
</p><p>
However, one aspect of the test case is not very satisfactory. Although
embedding test data as we did here is sensible for small amounts, it is
rather limiting, especially when we want to use a lot of test data.
Also, we didn't test any of the data that was added to see if it
correctly ended up in the table.
In the next section we will create a new version of this test, only this
time we will pull in the data from an external data source, and check
that the data we add to the table is
correct.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="tgs-datadriven-web"></a>4.6.1.5.2. Creating Data Driven Tests</h5></div></div></div><p>
In the previous section we put three hard-coded names and addresses in
our test. But what if we want to test <span class="emphasis"><em>lots</em></span> of data?
Or what if we want to change the data without having to change our test
script's source code. One approach is to import a dataset into <span class="emphasis"><em>Squish</em></span>
and use the dataset as the source of the values we insert into our
tests. <span class="emphasis"><em>Squish</em></span> can import data in <code class="filename">.tsv</code>
(tab-separated values format), <code class="filename">.csv</code>
(comma-separated values format), <code class="filename">.xls</code> or
<code class="filename">.xlsx</code> (<span class="trademark">Microsoft</span>® <span class="trademark">Excel</span>™ spreadsheet formats).
<sup>[<a id="idp40544192" href="#ftn.idp40544192" class="footnote">9</a>]</sup>
</p><p>
Test data can either be imported using the <span class="application">Squish IDE</span>, or manually using a
file manager or console commands. We will describe both approaches,
starting with using the <span class="application">Squish IDE</span>.
</p><p>
For the <span class="application">addressbook</span> application we want to
import the <code class="filename">MyAddresses.tsv</code> data file. To do this we
must start by clicking
<span class="guimenu">File</span>|<span class="guimenuitem">Import Test
Resource</span> to pop-up the <a class="xref" href="ide.dialogs.html#ide.import.squish.resource.dialog" title="8.3.7. Import Squish Resource dialog">Import Squish Resource dialog (Section 8.3.7)</a>. Inside the dialog click
the <span class="guibutton">Browse</span> button to choose the file to
import—in this case <code class="filename">MyAddresses.tsv</code>. Make
sure that the <span class="guilabel">Import As</span> combobox is set to
“<span class="quote">TestData</span>”. By default the <span class="application">Squish IDE</span> will import the test data
just for the current test case, but we want the test data to be
available to all the test suite's test cases: to do this check the
<span class="guibutton">Copy to Test Suite for Sharing</span> radio button. Now
click the <span class="guibutton">Finish</span> button. You can now see the file
listed in the Test Suite Resources view (in the Test Data tab), and if
you click the file's name it will be shown in an <a class="xref" href="ide.views.html#ide.the-editor.view" title="8.2.6. Editor view">Editor view (Section 8.2.6)</a>. The screenshot shows <span class="emphasis"><em>Squish</em></span> after the
test data has been added.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: For command-line users"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></img></td><th align="left"><span class="emphasis"><em>For command-line users</em></span></th></tr><tr><td align="left" valign="top"><p>
It is also possible to import test data outside the <span class="application">Squish IDE</span> using a file
manager (such as File Explorer) or console commands. To do this, create
a directory inside the test suite's directory called
<code class="filename">shared</code>. Now make a directory inside the
<code class="filename">shared</code> directory called
<code class="filename">testdata</code>. Now copy the data file (in this example,
<code class="filename">MyAddresses.tsv</code>) into the
<code class="filename">shared\testdata</code> directory. Now quit the <span class="application">Squish IDE</span> if it
is running and start it up again. If you click the Test Suite Resources
view's Test Data tab you should see the data file. Click the file's name
to see it in an <a class="xref" href="ide.views.html#ide.the-editor.view" title="8.2.6. Editor view">Editor view (Section 8.2.6)</a>.
</p></td></tr></table></div><div class="screenshot"><div class="mediaobject" align="center"><img src="images/tut-squish8-web.png" align="middle"></img><div class="caption"><p><span class="emphasis"><em>Squish</em></span> with some imported test data
</p></div></div></div><p>
Although in real life we would modify our
<code class="filename">tst_adding</code> test case to use the test data, for the
purpose of the tutorial we will make a new test case called
<code class="filename">tst_adding_data</code> that is a copy of
<code class="filename">tst_adding</code> and which we will modify to make use of
the test data.
</p><p>
The only function we have to change is <code class="function">main</code>, where
instead of iterating over hard-coded items of data, we iterate over all
the records in the dataset. We also need to update the expected row
count at the end since we are adding a lot more records now, and we will
also add a function to verify each record that's added.
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

import names

def main():
    startBrowser("http://localhost:9090/AddressBook.html")
    confirmPopup(names.newButton_button)
    test.verify(numberOfRows() == 0)
    limit = 10
    for row, record in enumerate(testData.dataset("MyAddresses.tsv")):
        forename = testData.field(record, "Forename")
        surname = testData.field(record, "Surname")
        email = testData.field(record, "Email")
        phone = testData.field(record, "Phone")
        addNameAndAddress((forename, surname, email, phone)) # pass as a single tuple
        checkNameAndAddress(record)
        if row &gt; limit:
            break
    test.compare(numberOfRows(), row + 1)
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

import * as names from 'names.js';

function main() {
    startBrowser("http://localhost:9090/AddressBook.html");
    confirmPopup(names.newButtonButton);
    test.verify(numberOfRows() == 0);
    var limit = 10;
    var records = testData.dataset("MyAddresses.tsv");
    for (var row = 0; row &lt; records.length; ++row) {
        var record = records[row];
        var forename = testData.field(record, "Forename");
        var surname = testData.field(record, "Surname");
        var email = testData.field(record, "Email");
        var phone = testData.field(record, "Phone");
        addNameAndAddress(new Array(forename, surname, email, phone));
        checkNameAndAddress(record);
        if (row &gt; limit)
            break;
    }
    test.compare(numberOfRows(), row + 1);
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

require 'names.pl';

sub main
{
    startBrowser("http://localhost:9090/AddressBook.html");
    confirmPopup($Names::newbutton_button);
    test::verify(numberOfRows() == 0);
    my @records = testData::dataset("MyAddresses.tsv");
    my $limit = 10;
    my $row = 0;
    for (; $row &lt; scalar(@records); ++$row) {
        my $record = $records[$row];
        my $forename = testData::field($record, "Forename");
        my $surname = testData::field($record, "Surname");
        my $email = testData::field($record, "Email");
        my $phone = testData::field($record, "Phone");
        addNameAndAddress(($forename, $surname, $email, $phone));
        checkNameAndAddress($record);
        if ($row &gt; $limit) {
            last;
        }
    }
    test::compare(numberOfRows(), $row + 1);
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

require 'squish'
require 'names';
include Squish

def main
    startBrowser("http://localhost:9090/AddressBook.html")
    confirmPopup(Names::NewButton_button)
    Test.verify(numberOfRows == 0)
    limit = 10
    rows = 0
    TestData.dataset("MyAddresses.tsv").each_with_index do
        |record, row|
        forename = TestData.field(record, "Forename")
        surname = TestData.field(record, "Surname")
        email = TestData.field(record, "Email")
        phone = TestData.field(record, "Phone")
        addNameAndAddress([forename, surname, email, phone]) # pass as an Array
        checkNameAndAddress(record)
        break if row &gt; limit
        rows += 1
    end
    Test.compare(numberOfRows, rows + 1)
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

source [findFile "scripts" "names.tcl"]

proc main {} {
    invoke startBrowser "http://localhost:9090/AddressBook.html"
    confirmPopup $names::newButton_button
    test compare [numberOfRows] 0
    set limit 10
    set data [testData dataset "MyAddresses.tsv"]
    set columns [llength [testData fieldNames [lindex $data 0]]]
    set row 0
    for {} {$row &lt; [llength $data]} {incr row} {
        set record [lindex $data $row]
        set forename [testData field $record "Forename"]
        set surname [testData field $record "Surname"]
        set email [testData field $record "Email"]
        set phone [testData field $record "Phone"]
        set details [list $forename $surname $email $phone]
        addNameAndAddress $details
        checkNameAndAddress $record
        if {$row &gt; $limit} {
            break
        }
    }
    test compare [numberOfRows] [expr $row + 1]
}
</pre></div><p>
<span class="emphasis"><em>Squish</em></span> provides access to test data through its <code class="code">testData</code>
module's functions—here we used the <a class="xref" href="rgs-squish.html#testData.dataset-function"><code class="function">testData.dataset</code></a> function to access the data file
and make its records available, and the <a class="xref" href="rgs-squish.html#testData.field-function"><code class="function">testData.field</code></a> function to retrieve each record's
individual fields.
</p><p>
Having used the test data to populate the HTML table we
want to be confident that the data in the table is the same as what we
have added, so that's why we added the
<code class="function">checkNameAndAddress</code> function. We also added a limit to
how many records we would compare, just to make the test run faster.
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

def checkNameAndAddress(record):
    table = waitForObject(names.dOCUMENT_HTML1_BODY1_DIV1_DIV2_DIV3_DIV3_DIV1_TABLE1)
    cells = (table.evaluateXPath(".//TR/TD[2]"),
             table.evaluateXPath(".//TR/TD[3]"),
             table.evaluateXPath(".//TR/TD[4]"),
             table.evaluateXPath(".//TR/TD[5]"))
    for column in range(len(testData.fieldNames(record))):
        cell = cells[column].snapshotItem(cells[column].snapshotLength-1).innerText
        field = testData.field(record, column)
        test.compare(cell, field)
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

function checkNameAndAddress(record)
{
    var table = waitForObject(names.dOCUMENTHTML1BODY1DIV1DIV2DIV3DIV3DIV1TABLE1);
    var cells = [table.evaluateXPath(".//TR/TD[2]"),
                 table.evaluateXPath(".//TR/TD[3]"),
                 table.evaluateXPath(".//TR/TD[4]"),
                 table.evaluateXPath(".//TR/TD[5]")];
    for (var column = 0; column &lt; testData.fieldNames(record).length;
            ++column) {
        var cell = cells[column].snapshotItem(cells[column].snapshotLength-1).innerText;
        var field = testData.field(record, column);
        test.compare(cell, field);
    }
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

sub checkNameAndAddress
{
    my ($record) = @_;
    my $table = waitForObject($Names::document_html1_body1_div1_div2_div3_div3_div1_table1);
    my @cells = ($table-&gt;evaluateXPath(".//TR/TD[2]"),
                 $table-&gt;evaluateXPath(".//TR/TD[3]"),
                 $table-&gt;evaluateXPath(".//TR/TD[4]"),
                 $table-&gt;evaluateXPath(".//TR/TD[5]"));
    my @columnNames = testData::fieldNames($record);
    for (my $column = 0; $column &lt; scalar(@columnNames); ++$column) {
        my $cell = $cells[$column]-&gt;snapshotItem($cells[$column]-&gt;snapshotLength - 1)-&gt;innerText;
        my $field = testData::field($record, $column);
        test::compare($cell, $field);
    }
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

def checkNameAndAddress(record)
    table = waitForObject(Names::DOCUMENT_HTML1_BODY1_DIV1_DIV2_DIV3_DIV3_DIV1_TABLE1)
    cells = [table.evaluateXPath(".//TR/TD[2]"),
           table.evaluateXPath(".//TR/TD[3]"),
           table.evaluateXPath(".//TR/TD[4]"),
           table.evaluateXPath(".//TR/TD[5]")]
    for column in 0...TestData.fieldNames(record).length
        cell = cells[column].snapshotItem(cells[column].snapshotLength-1).innerText
        field = TestData.field(record, column)
        Test.compare(cell, field)
    end
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

proc checkNameAndAddress {record} {
    set table [waitForObject $names::DOCUMENT_HTML1_BODY1_DIV1_DIV2_DIV3_DIV3_DIV1_TABLE1]
    set cells [list \
        [invoke $table evaluateXPath {.//TR/TD[2]}] \
        [invoke $table evaluateXPath {.//TR/TD[3]}] \
        [invoke $table evaluateXPath {.//TR/TD[4]}] \
        [invoke $table evaluateXPath {.//TR/TD[5]}]]
    set columns [llength [testData fieldNames $record]]
    for {set column 0} {$column &lt; $columns} {incr column} {
        set itemPos [expr [property get [lindex $cells $column] snapshotLength ] - 1 ]
        set cell [property get [invoke [lindex $cells $column] \
            snapshotItem $itemPos] innerText]
        set field [testData field $record $column]
        test compare $cell $field
    }
}
</pre></div><p>
The calls to the <a class="xref" href="rgs-webconvenience.html#web-HTML_Object.evaluateXPath-function"><code class="function">HTML_Object.evaluateXPath</code></a> function use XPath
queries to access the HTML table and find the first cells that match.
Since the addressbook application always adds new addresses at the end
the code needs to use the last item from the query. We use <span class="emphasis"><em>Squish</em></span>'s <a class="xref" href="rgs-squish.html#testData.fieldNames-function"><code class="function">testData.fieldNames</code></a> function to get a column count
and then use the <a class="xref" href="rgs-squish.html#test.compare-function"><code class="function">test.compare</code></a> function to
check that each value in the table is the same as the value in the test
data we used.
</p><p>
The screenshot show <span class="emphasis"><em>Squish</em></span>'s Test Summary log
after the data-driven tests have been run.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/web-tut-squishgui15.png" align="middle"></img><div class="caption"><p><span class="emphasis"><em>Squish</em></span> after a successful data-driven test run
</p></div></div></div><p>
<span class="emphasis"><em>Squish</em></span> can also do keyword-driven testing. This is a bit more
sophisticated than data-driven testing. See <a class="xref" href="how.to.do.keyword.driven.testing.html" title="5.16. How to Do Keyword-Driven Testing">How to Do Keyword-Driven Testing (Section 5.16)</a>.
</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="web-tut-learning-more"></a>4.6.1.6. Learning More</h4></div></div></div><p>
We have now completed the tutorial! <span class="emphasis"><em>Squish</em></span> can of course do
<span class="emphasis"><em>much</em></span> more than we have shown here, but the aim has
been to get you started with basic testing as quickly and easily as
possible. The <a class="xref" href="users-guide.html" title="Chapter 5. User Guide">User Guide (Chapter 5)</a> provides many more examples,
including those that show how tests can interact with particular input
elements such as selects, select-ones, texts, and text-areas.
</p><p>
The <a class="xref" href="api.man.html" title="Chapter 6. API Reference Manual">API Reference Manual (Chapter 6)</a> and <a class="xref" href="ref.man.html" title="Chapter 7. Tools Reference Manual">Tools Reference Manual (Chapter 7)</a> give full
details of <span class="emphasis"><em>Squish</em></span>'s testing API and the numerous functions it offers
to make testing as easy and efficient as possible. It is well worth
reading the <a class="xref" href="users-guide.html" title="Chapter 5. User Guide">User Guide (Chapter 5)</a> and at least skimming the
<a class="xref" href="api.man.html" title="Chapter 6. API Reference Manual">API Reference Manual (Chapter 6)</a> and <a class="xref" href="ref.man.html" title="Chapter 7. Tools Reference Manual">Tools Reference Manual (Chapter 7)</a>—especially
since the time invested will be repaid because you'll know what
functionality <span class="emphasis"><em>Squish</em></span> provides out of the box and can avoid reinventing
things that are already available.
</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-bdd-web"></a>4.6.2. Tutorial: Designing Behavior Driven Development (BDD) Tests</h3></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="tutorials-web.html#tut-bdd-web-intro">4.6.2.1. Introduction to Behavior Driven Development</a></span></dt><dt><span class="section"><a href="tutorials-web.html#tut-bdd-web-gherkin">4.6.2.2. Gherkin syntax</a></span></dt><dt><span class="section"><a href="tutorials-web.html#tut-bdd-web-test-impl">4.6.2.3. Test implementation</a></span></dt><dt><span class="section"><a href="tutorials-web.html#tut-bdd-web-test-exec">4.6.2.4. Test execution</a></span></dt><dt><span class="section"><a href="tutorials-web.html#tut-bdd-web-test-debug">4.6.2.5. Test debugging</a></span></dt><dt><span class="section"><a href="tutorials-web.html#tut-bdd-web-step-reuse">4.6.2.6. Re-using Step definitions</a></span></dt></dl></div><p>
This tutorial will show you how to create, run, and modify Behavior Driven Development (BDD)
tests for an example application. You will learn about Squish's most frequently used features.
By the end of the tutorial you will be able to write your own tests for your own applications.
</p><p>
For this chapter we will use a simple Address Book application as our
AUT. The application is shipped with <span class="emphasis"><em>Squish</em></span> in
<code class="filename">SQUISHDIR/examples/web/addressbook</code>. This is a very
basic application that allows users to interact with a fake existing address
book or create a new one, and add, edit, and remove entries.
Despite the application's simplicity,
it has all the key features that most standard web applications have:
buttons, radio buttons, line edits, pop-up dialogs, and a central area—in
this case showing a table. All the ideas and practices that you
learn to test this application can easily be adapted to your own
applications. And naturally, the <a class="xref" href="users-guide.html" title="Chapter 5. User Guide">User Guide (Chapter 5)</a> has many
more examples and shows how to test lots of web-specific features,
as well as all the standard
editing widgets.
</p><p>
The screenshots show the application in action.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/web-tut-addressbook1.png" align="middle"></img><div class="caption"><p>The Web <code class="code">AddressBook.html</code> example.
</p></div></div></div><div class="screenshot"><div class="mediaobject" align="center"><img src="images/web-tut-addressbook1a.png" align="middle"></img><div class="caption">Adding a new Address.</div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Using the Examples"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></img></td><th align="left">Using the Examples</th></tr><tr><td align="left" valign="top"><p> This tutorial's example is an HTML and JavaScript web application
contained in the file
<code class="filename">SQUISHDIR/examples/web/addressbook/AddressBook.html</code>.
<span class="emphasis"><em>Squish</em></span> for Web is designed to test real web applications served over http:
by a web server, and the AddressBook example requires being hosted on
one.</p><p> The server is written in Python; simply run it from the command
line using the Python interpreter on your system, or one under
<code class="filename">SQUISHDIR</code> (<code class="filename">python2</code> or
<code class="filename">python3</code>).
</p><pre class="screen">
$ <span class="bold"><strong>python SQUISHDIR/examples/web/addressbook/server.py</strong></span>
</pre><p>
If you are on windows:
</p><pre class="screen">
C:\&gt; <span class="bold"><strong>cd SQUISHDIR\examples\web\addressbook</strong></span>
C:\SQUISHDIR\examples\web\addressbook&gt; <span class="bold"><strong>..\..\..\python2\python server.py</strong></span>
</pre><p>
Once the server is running, you can access the web addressbook example application using
the URL <code class="code">http://localhost:9090/AddressBook.html</code>. (If port 9090
conflicts with anything else on your machine simply pass an unused port number
as a command line argument to <code class="code">server.py</code> and it will use that
instead. Naturally, if you use a different port you must use that port
throughout the tutorial.) </p></td></tr></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Windows Security Dialog"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></img></td><th align="left">Windows Security Dialog</th></tr><tr><td align="left" valign="top"><p>
When starting any TCP/IP server for the first time (including <span class="application">squishserver</span>, or
<code class="code">server.py</code>) on Windows, depending on your security
settings, Windows may pop up a dialog asking if you want to allow or
block the server from running. If you get this dialog, you
<span class="emphasis"><em>must</em></span> choose <span class="guibutton">Unblock</span> so that <span class="emphasis"><em>Squish</em></span>
can function correctly.
</p></td></tr></table></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="tut-bdd-web-intro"></a>4.6.2.1. Introduction to Behavior Driven Development</h4></div></div></div><p>
Behavior-Driven Development (BDD) is an extension of the Test-Driven Development approach
which puts the definition of acceptance criteria at the beginning of the development
process as opposed to writing tests after the software has been developed. With possible
cycles of code changes done after testing.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/bdd-tutorial-process.png" align="middle"></img><div class="caption">BDD process</div></div></div><p>
Behavior Driven Tests are built out of a set of <code class="literal">Feature</code> files, which
describe product features through the expected application behavior in one or many
<code class="literal">Scenarios</code>. Each <code class="literal">Scenario</code> is built out of a sequence
of steps which represent actions or verifications that need to be
tested for that <code class="literal">Scenario</code>.
</p><p>
BDD focuses on expected application behavior, not on implementation details. Therefore
BDD tests are described in a human-readable Domain Specific Language (DSL). As this
language is not technical, such tests can be created not only by programmers, but also by
product owners, testers or business analysts. Additionally, during the product
development, such tests serve as living product documentation. For <span class="emphasis"><em>Squish</em></span> usage, BDD
tests shall be created using Gherkin syntax. The previously written product specification
(BDD tests) can be turned into executable tests. This step by step tutorial presents
automating BDD tests with <span class="application">Squish IDE</span> support.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="tut-bdd-web-gherkin"></a>4.6.2.2. Gherkin syntax</h4></div></div></div><p>
Gherkin files describe product features through the expected application behavior
in one or many Scenarios. An example showing the "Filling of addressbook" feature
of the addressbook example application.
</p><pre class="screen">

Feature: Filling of addressbook
    As a user I want to fill the addressbook with entries

    Scenario: Initial state of created address book
        Given addressbook application is running
        When I create a new addressbook
        Then addressbook should have zero entries

    Scenario: State after adding one entry
        Given addressbook application is running
        When I create a new addressbook
        And I add a new person 'John','Doe','john@m.com','500600700' to address book
        Then '1' entries should be present

    Scenario: State after adding two entries
        Given addressbook application is running
        When I create a new addressbook
        And I add new persons to address book
            | forename  | surname  | email        | phone   |
            | John      | Smith    | john@m.com   | 1231231 |
            | Alice     | Thomson  | alice@m.com  | 2342342 |
        Then '2' entries should be present

    Scenario: Forename and surname is added to table
        Given addressbook application is running
        When I create a new addressbook
        When I add a new person 'Bob','Doe','Bob@m.com','123321231' to address book
        Then previously entered forename and surname shall be at the top
</pre><p>
Most of the above is free form text (does not have to be English). It's just the
<code class="literal">Feature</code>/<code class="literal">Scenario</code> structure and the leading keywords
like <code class="literal">Given</code>, <code class="literal">And</code>, <code class="literal">When</code>
and <code class="literal">Then</code> that are fixed. Each of those keywords
marks a step defining preconditions, user actions or expected results. The above
application behavior description can be passed to software developers to
implement these features and at the same time the same description can be used
by software testers to implement automated tests.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="tut-bdd-web-test-impl"></a>4.6.2.3. Test implementation</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="tut-bdd-web-create-testsuite"></a>4.6.2.3.1. Creating Test Suite</h5></div></div></div><p>
First, we need to create a Test Suite, which is a container for all Test Cases. Start the
<span class="application">squishide</span> and select <span class="guimenu">File</span>|<span class="guimenuitem">New Test
Suite...</span>. Please follow the New Test Suite wizard, provide a Test
Suite name, choose the Web Toolkit and scripting language of your choice. Please refer to
<a class="xref" href="tutorials-web.html#tut-web-creating-a-test-suite" title="4.6.1.2. Creating a Test Suite">Creating a Test Suite (Section 4.6.1.2)</a> for more details about creating new Test Suites.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="tut-bdd-web-create-testcase"></a>4.6.2.3.2. Creating Test Case</h5></div></div></div><p> <span class="emphasis"><em>Squish</em></span> offers two types of Test Cases: "Script Test Case" and "BDD Test
Case". As "Script Test Case" is the default one, in order to create new "BDD
Test Case" we need to use drop-down menu by clicking on the expander next to
<span class="guibutton">New Script Test Case</span> (<span class="guiicon"><img src="images/ide/new_test_case.png"></img></span>) and choosing the option <span class="guimenuitem">New BDD Test Case</span>.
The <span class="application">Squish IDE</span> will remember your choice and the "BDD Test Case" will
become the default when clicking on the button in the future. </p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/bdd-tutorial-new-testcase.png" align="middle"></img><div class="caption">Creating new BDD Test Case</div></div></div><p>
The newly created BDD Test Case consists of a <code class="filename">test.feature</code> file
(filled with a Gherkin template while creating a new BDD test case), a file named
<code class="filename">test.(py|js|pl)</code> which will drive the execution (there is no need
to edit this file), and a Test Suite Resources file named <code class="filename">steps/steps.(py|js|pl)</code> where
step implementation code will be placed.
</p><p>We need to replace the Gherkin template with a <code class="literal">Feature</code> for the addressbook example application. To do this, copy the <code class="literal">Feature</code>
description below and paste it into the <code class="literal">Feature</code> file.
</p><pre class="screen">

Feature: Filling of addressbook
    As a user I want to fill the addressbook with entries

    Scenario: Initial state of created address book
        Given addressbook application is running
        When I create a new addressbook
        Then addressbook should have zero entries
</pre><p>
When editing the <code class="filename">test.feature</code> file, a <code class="literal">Feature</code> file
warning <span class="errortext">No implementation found</span> is displayed for each
undefined step. The implementations are in the
<code class="filename">steps</code> subdirectory, in <span class="guilabel">Test Case Resources</span>,
or in <span class="guilabel">Test Suite Resources</span>. Running our
<code class="literal">Feature</code> test now will currently fail at the first step with a
<span class="errortext">No Matching Step Definition</span> and the following
steps will be skipped.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="tut-bdd-web-record-step"></a>4.6.2.3.3. Recording Step implementation</h5></div></div></div><p>
In order to record the <code class="literal">Scenario</code>, press the
<span class="guibutton">Record</span> button next to the respective <code class="literal">Scenario</code>
that is listed in the Scenarios tab in Test Case Resources view.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/bdd-tutorial-record-scenario.png" align="middle"></img><div class="caption">Record Scenario</div></div></div><p>
This will cause the IDE to go away, and a dialog to pop up asking you for the
starting URL of the web browser. Enter
<code class="code">http://localhost:9090/AddressBook.html</code> so the browser can start.
Additionally, the Control Bar is displayed with a list of all steps that need to be
recorded. Now all interaction with the AUT or any verification points added to
the script will be recorded under the first step <code class="code">Given addressbook application is
running</code> (which is bolded in the Step list on the Control Bar). In order to verify that
this precondition is met, we will add a Verification Point. To do this, click on
<span class="guibutton">Verify</span> in the Control Bar and select <span class="guibutton">Properties</span>.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/bdd-tutorial-control-bar.png" align="middle"></img><div class="caption">Control Bar</div></div></div><p>
As a result the <span class="application">Squish IDE</span> is put into Spy mode which displays all
<span class="guilabel">Application Objects</span> and <span class="guilabel">Properties</span>
in dockable Views near the bottom of the IDE. In the
<span class="guilabel">Application Objects</span>, select the <code class="literal">DOCUMENT</code>
object. Selecting it will update the <span class="guilabel">Properties</span> view to its
right. Next click on the checkbox in front of the property <span class="property">title</span> in the
<span class="guilabel">Properties</span> View. Finally, click on
the button <span class="guibutton">Save and Insert Verifications</span>. The <span class="application">Squish IDE</span> disappears and
the Control Bar is shown again.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/bdd-tutorial-squish-spy-web.png" align="middle"></img><div class="caption">Inserting Verification Point</div></div></div><p>
When we are done with each step, we can move to the next
undefined step (playing back the ones that were previously defined)
by clicking on the <span class="guibutton">Finish Recording Step...</span> (<span class="guiicon"><img src="images/bdd-tutorial-next-step-button.png"></img></span>) arrow button in the Control Bar that is
located to the left of the current step.
</p><p>
Next, for the step <code class="code">When I create a new addressbook</code> click on the
<span class="guibutton">New</span> button and click on the <span class="guibutton">Finish Recording Step...</span> (<span class="guiicon"><img src="images/bdd-tutorial-next-step-button.png"></img></span>).
</p><p>
Finally, for the step <code class="code">Then addressbook should have zero entries</code> verify that the table containing
the address entries is empty. To record this verification, click on
<span class="guibutton">Verify</span> while recording, select
<span class="guibutton">Properties</span> and then select the body of the table in the
<span class="guilabel">Application Objects</span> view.
See below for the location of the <code class="literal">tbody</code> element, since it is
deeply nested.
Check the <span class="property">numChildren</span> entry from the
<span class="guilabel">Properties</span> view (It has a value of 1 since there is always
an extra element in the table). Then, click on
<span class="guibutton">Save and Insert Verifications</span>. Finally, click on the
last <span class="guibutton">Finish Recording Step...</span> (<span class="guiicon"><img src="images/bdd-tutorial-next-step-button.png"></img></span>) arrow button in the Control Bar.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/bdd-tutorial-web-nesting.png" align="middle"></img><div class="caption">Location of the table</div></div></div><p>
As a result, <span class="emphasis"><em>Squish</em></span> will generate the following step
definitions in the <code class="filename">steps.*</code> file (at
<span class="guilabel">Test Suites</span>+<span class="guilabel">Test Suite
Resources</span>):
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

@Given("addressbook application is running")
def step(context):
    startBrowser("http://127.0.0.1:9090/AddressBook.html")
    test.compare(waitForObjectExists(names.dOCUMENT).title, "froglogic Addressbook")

@When("I create a new addressbook")
def step(context):
    clickButton(waitForObject(names.froglogic_Addressbook_newButton_button))
    snooze(2)
    closeConfirm(names.confirmPopup, True)

@Then("addressbook should have zero entries")
def step(context):
    test.compare(waitForObjectExists(names.dOCUMENT_HTML1_BODY1_DIV1_DIV2_DIV3_DIV3_DIV1_TABLE1_TBODY1).numChildren, 1)

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

Given("addressbook application is running", function(context) {
    startBrowser("http://127.0.0.1:9090/AddressBook.html");
    test.compare(waitForObjectExists(names.dOCUMENT).title, "froglogic Addressbook");
});

When("I create a new addressbook", function(context) {
    clickButton(waitForObject(names.froglogicAddressbookNewButtonButton));
    snooze(2);
    closeConfirm(names.confirmPopup, true);
});

Then("addressbook should have zero entries", function(context) {
    test.compare(waitForObjectExists(names.dOCUMENTHTML1BODY1DIV1DIV2DIV3DIV3DIV1TABLE1TBODY1).numChildren, 1);
});

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

Given("addressbook application is running", sub {
    my $context = shift;
    startBrowser("http://127.0.0.1:9090/AddressBook.html");
    test::compare(waitForObjectExists($Names::document)-&gt;title, "froglogic Addressbook");
});

When("I create a new addressbook", sub {
    my $context = shift;
    clickButton(waitForObject($Names::froglogic_addressbook_newbutton_button));
    snooze(2);
    closeConfirm($Names::confirmpopup, 1);
});

Then("addressbook should have zero entries", sub {
    my $context = shift;
    test::compare(waitForObjectExists($Names::document_html1_body1_div1_div2_div3_div3_div1_table1_tbody1)-&gt;numChildren, 1);
});

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

Given("addressbook application is running") do |context|
    startBrowser("http://127.0.0.1:9090/AddressBook.html")
    Test.compare(waitForObjectExists(Names::DOCUMENT).title, "froglogic Addressbook")
end

When("I create a new addressbook") do |context|
    clickButton(waitForObject(Names::Froglogic_Addressbook_newButton_button))
    snooze(2)
    closeConfirm(Names::ConfirmPopup, true)
end

Then("addressbook should have zero entries") do |context|
    Test.compare(waitForObjectExists(Names::DOCUMENT_HTML1_BODY1_DIV1_DIV2_DIV3_DIV3_DIV1_TABLE1_TBODY1).numChildren, 1)
end

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

Given "addressbook application is running" {context} {
    invoke startBrowser "http://127.0.0.1:9090/AddressBook.html"
    test compare [property get [waitForObject $names::DOCUMENT] title] "froglogic Addressbook"
}

When "I create a new addressbook" {context} {
    invoke clickButton [waitForObject $names::froglogic_Addressbook_newButton_button]
    snooze 2
    invoke closeConfirm $names::ConfirmPopup true
}

Then "addressbook should have zero entries" {context} {
    test compare [property get [waitForObjectExists $names::DOCUMENT_HTML1_BODY1_DIV1_DIV2_DIV3_DIV3_DIV1_TABLE1_TBODY1] numChildren] 1
}

</pre></div><p>
The application is automatically started at the beginning of the first step due
to the recorded <code class="function">startApplication()</code> call. At the end of each
Scenario, the <code class="function">onScenarioEnd</code> hook is called, causing
<code class="function">detach()</code> to be called on the application context.
Because the AUT was started with <code class="function">startApplication()</code>,
this causes it to terminate.
This hook function is found in the file <code class="filename">bdd_hooks.(py|js|pl|rb|tcl)</code>,
which is located in the <span class="guilabel">Scripts</span> tab of the <span class="guilabel">Test
Suite Resources</span> view. You can define additional hook functions here.
For a list of all available hooks, please refer to <a class="xref" href="api.bdt.functions.html#api.bdt.functions.hooks" title="6.19.10. Performing Actions During Test Execution Via Hooks">Performing Actions During Test Execution Via Hooks (Section 6.19.10)</a>.
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">
@OnScenarioEnd
def hook(context):
    closeWindow(":[Window]");
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">
OnScenarioEnd(function(context) {
    closeWindow(":[Window]");
});
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">
OnScenarioEnd(sub {
    closeWindow(":[Window]");
});
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">
OnScenarioEnd do |context|
  closeWindow(":[Window]");
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">
OnScenarioEnd { context } {
    invoke closeWindow ":\[Window\]"
    }
}
</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="tut-bdd-web-step-parametrization"></a>4.6.2.3.4. Step parametrization</h5></div></div></div><p>
So far, our steps did not use any parameters and all values were
hardcoded. <span class="emphasis"><em>Squish</em></span> has different types of parameters like
<code class="code">any</code>, <code class="code">integer</code> or <code class="code">word</code>, allowing our
step definitions to be more reusable. Let us add a
new <code class="literal">Scenario</code> to our <code class="literal">Feature</code> file which will provide
step parameters for both the Test Data and the expected results.
Copy the below section into your Feature file.

</p><pre class="screen">

    Scenario Outline: Adding single entries multiple time
        Given addressbook application is running
        When I create a new addressbook
        And I add a new person '&lt;forename&gt;','&lt;surname&gt;','&lt;email&gt;','&lt;phone&gt;' to address book
        Then '1' entries should be present
        Examples:
            | forename | surname  | email       | phone     |
            | John     | Doe      | john@m.com  | 500600700 |
            | Bob      | Koo      | bob@m.com   | 500600800 |
</pre><p>

After auto-saving
the <code class="literal">Feature</code> file, the <span class="application">Squish IDE</span> provides a hint that only 2
steps need to be implemented: <code class="code">When I add a new person 'John',
'Doe','john@m.com','500600700' to address book</code> and <code class="code">Then '1' entries should
be present</code>. The remaining steps already have a matching
step implementation.
</p><p>
To record the missing steps, hit the record button next to the
test case name in the Test Suites view. The script will play until it gets to the missing
step and then prompt you to implement it. If you select the Add
button, then you can type in the information for a new entry. Click on the
<span class="guibutton">Finish Recording Step...</span> (<span class="guiicon"><img src="images/bdd-tutorial-next-step-button.png"></img></span>) button to move to the next step. For the second missing
step, we could record an object property verification
like we did with the step <code class="code">Then addressbook should have zero entries</code>.
Or we could copy that step's implementation in the <code class="filename">steps.(py|js|pl|rb|tcl)</code> file
and increment the number
at the end of the <code class="code">test.compare</code> line. Instead of testing for zero items, we are
testing for one item.
</p><p>
Now we parametrize the generated step implementation by replacing the values with parameter types.
Since we want to be able to add different names, replace 'John' with '|word|'.
Note that each parameter will be passed to the step implementation function in the order of
appearance in the descriptive name of the step. Finish parametrizing by editing the typed values
into keywords, to look like this example step
<code class="code">When I add a new person 'John', 'Doe','john@m.com','500600700'</code> to address book:
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

@When("I add a new person '|word|','|word|','|any|','|integer|' to address book")
def step(context, forename, surname, email, phone):
    clickButton(waitForObject(names.froglogic_Addressbook_addButton_button))
    setText(waitForObject(names.froglogic_Addressbook_forenameEdit_text), forename)
    setText(waitForObject(names.froglogic_Addressbook_surnameEdit_text), surname)
    setText(waitForObject(names.froglogic_Addressbook_emailEdit_text), email)
    setText(waitForObject(names.froglogic_Addressbook_phoneEdit_text), phone)
    clickButton(waitForObject(names.froglogic_Addressbook_Save_button))
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

When("I add a new person '|word|','|word|','|any|','|integer|' to address book",
    function(context, forename, surname, email, phone) {
    clickButton(waitForObject(names.froglogicAddressbookAddButtonButton));
    mouseClick(waitForObject(names.froglogicAddressbookAddButtonButton));
    setText(waitForObject(names.froglogicAddressbookForenameEditText), forename);
    setText(waitForObject(names.froglogicAddressbookSurnameEditText), surname);
    setText(waitForObject(names.froglogicAddressbookEmailEditText), email);
    setText(waitForObject(names.froglogicAddressbookPhoneEditText), phone);
    clickButton(waitForObject(names.froglogicAddressbookSaveButton));
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

When("I add a new person '|word|','|word|','|any|','|integer|' to address book", sub {
    my $context = shift;
    my ($forename, $surname, $email, $phone) = @_;
    clickButton(waitForObject($Names::froglogic_addressbook_addbutton_button));
    setText(waitForObject($Names::froglogic_addressbook_forenameedit_text), $forename);
    setText(waitForObject($Names::froglogic_addressbook_surnameedit_text), $surname);
    setText(waitForObject($Names::froglogic_addressbook_emailedit_text), $email);
    setText(waitForObject($Names::froglogic_addressbook_phoneedit_text), $phone);
    clickButton(waitForObject($Names::froglogic_addressbook_save_button));
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

When("I add a new person '|word|','|word|','|any|','|integer|' to address book") do |context, forename, surname, email, phone|
    clickButton(waitForObject(Names::Froglogic_Addressbook_addButton_button))
    setText(waitForObject(Names::Froglogic_Addressbook_forenameEdit_text), forename)
    setText(waitForObject(Names::Froglogic_Addressbook_surnameEdit_text), surname)
    setText(waitForObject(Names::Froglogic_Addressbook_emailEdit_text), email)
    setText(waitForObject(Names::Froglogic_Addressbook_phoneEdit_text), phone)
    clickButton(waitForObject(Names::Froglogic_Addressbook_Save_button))
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

When "I add a new person '|word|','|word|','|any|','|integer|' to address book" {context forename surname email phone} {
    invoke clickButton [waitForObject $names::froglogic_Addressbook_addButton_button]
    invoke setText [waitForObject $names::froglogic_Addressbook_forenameEdit_text] $forename
    invoke setText [waitForObject $names::froglogic_Addressbook_surnameEdit_text] $surname
    invoke setText [waitForObject $names::froglogic_Addressbook_emailEdit_text] $email
    invoke setText [waitForObject $names::froglogic_Addressbook_phoneEdit_text] $phone
    invoke clickButton [waitForObject $names::froglogic_Addressbook_Save_button]
</pre></div><p> If we recorded the final <code class="literal">Then</code> as a missing step, and
verified the <span class="property">numChildren</span> is 1 in the
&lt;TBODY&gt;, we can modify the step so that it takes a parameter,
so it can verify other integer values later.
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

@Then("'|integer|' entries should be present")
def step(context, entries):
    test.compare(waitForObjectExists(names.dOCUMENT_HTML1_BODY1_DIV1_DIV2_DIV3_DIV3_DIV1_TABLE1_TBODY1).numChildren, entries + 1)

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

Then("'|integer|' entries should be present", function(context, entries) {
    test.compare(waitForObjectExists(names.dOCUMENTHTML1BODY1DIV1DIV2DIV3DIV3DIV1TABLE1TBODY1).numChildren, entries + 1);
});

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

Then("'|integer|' entries should be present", sub {
    my $context = shift;
    my $entries = shift;
    test::compare(waitForObjectExists($Names::document_html1_body1_div1_div2_div3_div3_div1_table1_tbody1)-&gt;numChildren, $entries + 1);
});

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

Then("'|integer|' entries should be present") do |context, entries|
    Test.compare(waitForObjectExists(Names::DOCUMENT_HTML1_BODY1_DIV1_DIV2_DIV3_DIV3_DIV1_TABLE1_TBODY1).numChildren, entries + 1)
end

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

Then "'|integer|' entries should be present" {context entries} {
    test compare [property get [waitForObjectExists $names::DOCUMENT_HTML1_BODY1_DIV1_DIV2_DIV3_DIV3_DIV1_TABLE1_TBODY1] numChildren] [expr $entries + 1]
}

</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="tut-bdd-web-provide-parameters"></a>4.6.2.3.5. Provide parameters for Step in table</h5></div></div></div><p>
The next <code class="literal">Scenario</code> will test adding multiple entries to the address
book. We could use step <code class="code">When I add a new person John','Doe','john@m.com','500600700'
to address book</code> multiple times just with different data. But lets instead define a
new step called <code class="code">When I add a new person to address book</code>
which will handle data from a table.
</p><pre class="screen">
Scenario: State after adding two entries
    Given addressbook application is running
    When I create a new addressbook
    And I add new persons to address book
        | forename  | surname  | email        | phone   |
        | John      | Smith    | john@m.com   | 1231231 |
        | Alice     | Thomson  | alice@m.com  | 2342342 |
    Then '2' entries should be present
</pre><p>
The step implementation to handle such tables looks like this:
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

@When("I add new persons to address book")
def step(context):
    table = context.table
    # Drop initial row with column headers
    table.pop(0)
    for (forename, surname, email, phone) in table:
        clickButton(waitForObject(names.froglogic_Addressbook_addButton_button))
        setText(waitForObject(names.froglogic_Addressbook_forenameEdit_text), forename)
        setText(waitForObject(names.froglogic_Addressbook_surnameEdit_text), surname)
        setText(waitForObject(names.froglogic_Addressbook_emailEdit_text), email)
        setText(waitForObject(names.froglogic_Addressbook_phoneEdit_text), phone)
        clickButton(waitForObject(names.froglogic_Addressbook_Save_button))

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

When("I add new persons to address book", function(context) {
    var table = context.table;
    // Skip initial row with column headers by starting at index 1
    for (var i = 1; i &lt; table.length; ++i) {
        var forename = table[i][0];
        var surname = table[i][1];
        var email = table[i][2];
        var phone = table[i][3];
        clickButton(waitForObject(names.froglogicAddressbookAddButtonButton));
        mouseClick(waitForObject(names.froglogicAddressbookAddButtonButton));
        setText(waitForObject(names.froglogicAddressbookForenameEditText), forename);
        setText(waitForObject(names.froglogicAddressbookSurnameEditText), surname);
        setText(waitForObject(names.froglogicAddressbookEmailEditText), email);
        setText(waitForObject(names.froglogicAddressbookPhoneEditText), phone);
        clickButton(waitForObject(names.froglogicAddressbookSaveButton));
    }
});

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

When("I add new persons to address book", sub {
    my %context = %{shift()};
    my @table = @{$context{'table'}};

    # Drop initial row with column headers
    shift(@table);

    for my $row (@table) {
        my ($forename, $surname, $email, $phone) = @{$row};
        clickButton(waitForObject($Names::froglogic_addressbook_addbutton_button));
        setText(waitForObject($Names::froglogic_addressbook_forenameedit_text), $forename);
        setText(waitForObject($Names::froglogic_addressbook_surnameedit_text), $surname);
        setText(waitForObject($Names::froglogic_addressbook_emailedit_text), $email);
        setText(waitForObject($Names::froglogic_addressbook_phoneedit_text), $phone);
        clickButton(waitForObject($Names::froglogic_addressbook_save_button));
    }
});

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

When("I add new persons to address book") do |context|
    table = context.table
    # Drop initial row with column headers
    table.shift
    for forename, surname, email, phone in table do
        clickButton(waitForObject(Names::Froglogic_Addressbook_addButton_button))
        setText(waitForObject(Names::Froglogic_Addressbook_forenameEdit_text), forename)
        setText(waitForObject(Names::Froglogic_Addressbook_surnameEdit_text), surname)
        setText(waitForObject(Names::Froglogic_Addressbook_emailEdit_text), email)
        setText(waitForObject(Names::Froglogic_Addressbook_phoneEdit_text), phone)
        clickButton(waitForObject(Names::Froglogic_Addressbook_Save_button))
    end
end

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

When "I add new persons to address book" {context} {
    set table [$context table]
    # Drop initial row with column headers
    foreach row [lreplace $table 0 0] {
        foreach {forename surname email phone} $row break
        invoke clickButton [waitForObject $names::froglogic_Addressbook_addButton_button]
        invoke setText [waitForObject $names::froglogic_Addressbook_forenameEdit_text] $forename
        invoke setText [waitForObject $names::froglogic_Addressbook_surnameEdit_text] $surname
        invoke setText [waitForObject $names::froglogic_Addressbook_emailEdit_text] $email
        invoke setText [waitForObject $names::froglogic_Addressbook_phoneEdit_text] $phone
        invoke clickButton [waitForObject $names::froglogic_Addressbook_Save_button]
    }
}

</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="tut-bdd-web-sharing"></a>4.6.2.3.6. Sharing data between Steps and Scenarios</h5></div></div></div><p>
Lets add a new <code class="literal">Scenario</code> to the <code class="literal">Feature</code> file. This
time we would like to check not the number of entries in address book list, but if this
list contains proper data. Because we enter data into the address book in one
step and verify them in another, we must share information about
entered data among those steps in order to perform a verification.
</p><pre class="screen">

    Scenario: Forename and surname is added to table
        Given addressbook application is running
        When I create a new addressbook
        When I add a new person 'Bob','Doe','Bob@m.com','123321231' to address book
        Then previously entered forename and surname shall be at the top
</pre><p>
To share this data, <span class="property">context.userData</span> can be used.
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

@When("I add a new person '|word|','|word|','|any|','|integer|' to address book")
def step(context, forename, surname, email, phone):
    clickButton(waitForObject(names.froglogic_Addressbook_addButton_button))
    setText(waitForObject(names.froglogic_Addressbook_forenameEdit_text), forename)
    setText(waitForObject(names.froglogic_Addressbook_surnameEdit_text), surname)
    setText(waitForObject(names.froglogic_Addressbook_emailEdit_text), email)
    setText(waitForObject(names.froglogic_Addressbook_phoneEdit_text), phone)
    clickButton(waitForObject(names.froglogic_Addressbook_Save_button))
    # save userData for last step
    context.userData = {}
    context.userData['forename'] = forename
    context.userData['surname'] = surname

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

When("I add a new person '|word|','|word|','|any|','|integer|' to address book",
    function(context, forename, surname, email, phone) {
    clickButton(waitForObject(names.froglogicAddressbookAddButtonButton));
    mouseClick(waitForObject(names.froglogicAddressbookAddButtonButton));
    setText(waitForObject(names.froglogicAddressbookForenameEditText), forename);
    setText(waitForObject(names.froglogicAddressbookSurnameEditText), surname);
    setText(waitForObject(names.froglogicAddressbookEmailEditText), email);
    setText(waitForObject(names.froglogicAddressbookPhoneEditText), phone);
    clickButton(waitForObject(names.froglogicAddressbookSaveButton));
    // save userData for last step
    context.userData["forename"] = forename;
    context.userData["surname"] = surname;
});

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

When("I add a new person '|word|','|word|','|any|','|integer|' to address book", sub {
    my $context = shift;
    my ($forename, $surname, $email, $phone) = @_;
    clickButton(waitForObject($Names::froglogic_addressbook_addbutton_button));
    setText(waitForObject($Names::froglogic_addressbook_forenameedit_text), $forename);
    setText(waitForObject($Names::froglogic_addressbook_surnameedit_text), $surname);
    setText(waitForObject($Names::froglogic_addressbook_emailedit_text), $email);
    setText(waitForObject($Names::froglogic_addressbook_phoneedit_text), $phone);
    clickButton(waitForObject($Names::froglogic_addressbook_save_button));
    # save userData for last step
    $context-&gt;{userData}{'forename'} = $forename;
    $context-&gt;{userData}{'surname'} = $surname;
});

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

When("I add a new person '|word|','|word|','|any|','|integer|' to address book") do |context, forename, surname, email, phone|
    clickButton(waitForObject(Names::Froglogic_Addressbook_addButton_button))
    setText(waitForObject(Names::Froglogic_Addressbook_forenameEdit_text), forename)
    setText(waitForObject(Names::Froglogic_Addressbook_surnameEdit_text), surname)
    setText(waitForObject(Names::Froglogic_Addressbook_emailEdit_text), email)
    setText(waitForObject(Names::Froglogic_Addressbook_phoneEdit_text), phone)
    clickButton(waitForObject(Names::Froglogic_Addressbook_Save_button))
    # save userData for last step
    context.userData = Hash.new
    context.userData[:forename] = forename
    context.userData[:surname] = surname
end

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

When "I add a new person '|word|','|word|','|any|','|integer|' to address book" {context forename surname email phone} {
    invoke clickButton [waitForObject $names::froglogic_Addressbook_addButton_button]
    invoke setText [waitForObject $names::froglogic_Addressbook_forenameEdit_text] $forename
    invoke setText [waitForObject $names::froglogic_Addressbook_surnameEdit_text] $surname
    invoke setText [waitForObject $names::froglogic_Addressbook_emailEdit_text] $email
    invoke setText [waitForObject $names::froglogic_Addressbook_phoneEdit_text] $phone
    invoke clickButton [waitForObject $names::froglogic_Addressbook_Save_button]
    # save userData for last step
    $context userData [dict create forename $forename surname $surname]
}

</pre></div><p>
All data stored in <span class="property">context.userData</span> can be accessed in all
steps and <code class="literal">Hooks</code> in all <code class="literal">Scenarios</code>
of the given <code class="literal">Feature</code>. Finally, we need to implement
the step <code class="code">Then previously entered forename and surname shall be at the top</code>.
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

@Then("previously entered forename and surname shall be at the top")
def step(context):
    test.compare(waitForObjectExists("DOCUMENT.HTML1.BODY1.DIV1.DIV2.DIV3.DIV3.DIV1.TABLE1.TBODY1.TR2.TD2").innerText,
                 context.userData['forename'])
    test.compare(waitForObjectExists("DOCUMENT.HTML1.BODY1.DIV1.DIV2.DIV3.DIV3.DIV1.TABLE1.TBODY1.TR2.TD3").innerText,
                 context.userData['surname'])
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

Then("previously entered forename and surname shall be at the top", function(context) {
    test.compare(waitForObjectExists("DOCUMENT.HTML1.BODY1.DIV1.DIV2.DIV3.DIV3.DIV1.TABLE1.TBODY1.TR2.TD2").innerText,
        context.userData["forename"], "forename?");
    test.compare(waitForObjectExists("DOCUMENT.HTML1.BODY1.DIV1.DIV2.DIV3.DIV3.DIV1.TABLE1.TBODY1.TR2.TD3").innerText,
        context.userData["surname"], "surname?");
});
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

Then("previously entered forename and surname shall be at the top", sub {
    my $context = shift;
    test::compare( waitForObject("DOCUMENT.HTML1.BODY1.DIV1.DIV2.DIV3.DIV3.DIV1.TABLE1.TBODY1.TR2.TD2")-&gt;innerText,
        $context-&gt;{userData}{'forename'}, "forename?" );
    test::compare( waitForObject("DOCUMENT.HTML1.BODY1.DIV1.DIV2.DIV3.DIV3.DIV1.TABLE1.TBODY1.TR2.TD3")-&gt;innerText,
        $context-&gt;{userData}{'surname'}, "surname?" );
});
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

Then("previously entered forename and surname shall be at the top") do |context|
    Test.compare(waitForObjectExists("DOCUMENT.HTML1.BODY1.DIV1.DIV2.DIV3.DIV3.DIV1.TABLE1.TBODY1.TR2.TD2").innerText,
        context.userData[:forename], "forename?")
    Test.compare(waitForObjectExists("DOCUMENT.HTML1.BODY1.DIV1.DIV2.DIV3.DIV3.DIV1.TABLE1.TBODY1.TR2.TD3").innerText,
        context.userData[:surname], "surname?")
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

Then "previously entered forename and surname shall be at the top" {context} {
    test compare [property get [waitForObjectExists "DOCUMENT.HTML1.BODY1.DIV1.DIV2.DIV3.DIV3.DIV1.TABLE1.TBODY1.TR2.TD2"] innerText] [dict get [$context userData] forename]
    test compare [property get [waitForObjectExists "DOCUMENT.HTML1.BODY1.DIV1.DIV2.DIV3.DIV3.DIV1.TABLE1.TBODY1.TR2.TD3"] innerText] [dict get [$context userData] surname]
}
</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="tut-bdd-web-scenario-outline"></a>4.6.2.3.7. Scenario Outline</h5></div></div></div><p>
Assume our <code class="literal">Feature</code> contains the following two <code class="literal">Scenarios</code>:
</p><pre class="screen">
Scenario: State after adding one entry
    Given addressbook application is running
    When I create a new addressbook
    And I add a new person 'John','Doe','john@m.com','500600700' to address book
    Then "1" entries should be present

Scenario: State after adding one entry
    Given addressbook application is running
    When I create a new addressbook
    And I add a new person 'Bob','Koo','bob@m.com','500600800' to address book
    Then "1" entries should be present
</pre><p>
As we can see, those <code class="literal">Scenarios</code> perform the same actions using different
test data. The same can be achieved by using a <code class="literal">Scenario Outline</code> (a
<code class="literal">Scenario</code> template with placeholders) and Examples (a table with
parameters).
</p><pre class="screen">

    Scenario Outline: Adding single entries multiple time
        Given addressbook application is running
        When I create a new addressbook
        And I add a new person '&lt;forename&gt;','&lt;surname&gt;','&lt;email&gt;','&lt;phone&gt;' to address book
        Then '1' entries should be present
        Examples:
            | forename | surname  | email       | phone     |
            | John     | Doe      | john@m.com  | 500600700 |
            | Bob      | Koo      | bob@m.com   | 500600800 |
</pre><p>
Please note that the <code class="code">OnScenarioEnd</code> hook will be executed at the end of
each loop iteration in a <code class="literal">Scenario Outline</code>.
</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="tut-bdd-web-test-exec"></a>4.6.2.4. Test execution</h4></div></div></div><p>
In the <span class="application">Squish IDE</span>, users can execute all <code class="literal">Scenarios</code> in a
<code class="literal">Feature</code>, or execute only one selected <code class="literal">Scenario</code>. In
order to execute all <code class="literal">Scenarios</code>, the proper Test Case has to be
executed by clicking on the <span class="guibutton">Play</span> button in the Test Suites view.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/bdd-tutorial-execute-all.png" align="middle"></img><div class="caption">Execute all Scenarios from Feature</div></div></div><p>
In order to execute only one <code class="literal">Scenario</code>, you need to open the
<code class="literal">Feature</code> file, right-click on the given <code class="literal">Scenario</code> and
choose <span class="guibutton">Run Scenario</span>. An alternative approach is to click on the
<span class="guibutton">Play</span> button next to the respective
<code class="literal">Scenario</code> in the Scenarios tab in Test Case Resources.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/bdd-tutorial-execute-one.png" align="middle"></img><div class="caption">Execute one Scenario from Feature</div></div></div><p>
After a <code class="literal">Scenario</code> is executed, the <code class="literal">Feature</code> file is
colored according to the execution results. More detailed information (like logs) can
be found in the Test Results View.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/bdd-tutorial-results.png" align="middle"></img><div class="caption">Execution results in Feature file</div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="tut-bdd-web-test-debug"></a>4.6.2.5. Test debugging</h4></div></div></div><p>
<span class="emphasis"><em>Squish</em></span> offers the possibility to pause an execution of a Test Case at any point in
order to check script variables, spy application objects or run custom
code in the <span class="emphasis"><em>Squish</em></span> script console. To do this, a breakpoint has to be placed before
starting the execution, either in the <code class="literal">Feature</code> file at any line
containing a step or at any line of executed code (i.e. in middle of
step definition code).
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/bdd-tutorial-breakpoint.png" align="middle"></img><div class="caption">Breakpoint in Feature file</div></div></div><p>
After the breakpoint is reached, you can inspect all application objects and their
properties. If a breakpoint is placed at a step definition or a hook
is reached, then you can additionally add Verification Points or record code snippets.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="tut-bdd-web-step-reuse"></a>4.6.2.6. Re-using Step definitions</h4></div></div></div><p>
BDD test maintainability can be increased by reusing step definitions
in test cases located in another directory. For more information, see
<a class="xref" href="api.bdt.functions.html#api.bdt.functions.collectstepdefinitions">collectStepDefinitions()</a>.
</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-migration-bdd-web"></a>4.6.3. Tutorial: Migration of existing tests to BDD</h3></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="tutorials-web.html#bdd-migration-web-extend">4.6.3.1. Extend existing tests to BDD</a></span></dt><dt><span class="section"><a href="tutorials-web.html#bdd-migration-web-convert">4.6.3.2. Convert existing tests to BDD</a></span></dt></dl></div><p>
This chapter for users that have existing script-based tests and who would like to
introduce Behavior Driven Testing. The first section describes how to keep the
existing tests and simply add new tests with the BDD approach. The second section
describes how to convert existing tests to BDD.
</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="bdd-migration-web-extend"></a>4.6.3.1. Extend existing tests to BDD</h4></div></div></div><p>
The first option is to keep any existing script-based <span class="emphasis"><em>Squish</em></span> tests and extend them by
adding new BDD tests. It's possible to have a <code class="literal">Test Suite</code> containing
both script-based and BDD Test Cases. Simply open an existing
<code class="literal">Test Suite</code> with and choose <span class="guimenuitem">New BDD Test Case</span>
from the drop down menu of the down-arrow button to the right of <span class="guibutton">New Script Test Case</span> (<span class="guiicon"><img src="images/ide/new_test_case.png"></img></span>)
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/bdd-tutorial-new-testcase.png" align="middle"></img><div class="caption">Creating new BDD Test Case</div></div></div><p>
Assuming your existing Test Cases make use of a library and you are calling
shared functions to interact with the AUT, those functions can still be used
from BDD Test Cases. In the example below, these functions are used from
multiple script-based Test Cases:
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">
def numberOfRows():
    table = waitForObject(names.dOCUMENT_HTML1_BODY1_DIV1_DIV2_DIV3_DIV3_DIV1_TABLE1)
    results = table.evaluateXPath(".//TR[contains(@class, 'jqgrow')]")
    return results.snapshotLength

def createNewAddressBook():
    clickButton(waitForObject(names.froglogic_Addressbook_newButton_button))
    closeConfirm(names.confirmPopup, True)
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">
function numberOfRows() {
    var table = waitForObject("DOCUMENT.HTML1.BODY1.DIV1.DIV2.DIV3.DIV3.DIV1.TABLE1");
    var results = table.evaluateXPath(".//TR[contains(@class, 'jqgrow')]");
    return results.snapshotLength;
}

function createNewAddressBook(){
    clickButton(waitForObject(names.froglogicAddressbookNewButtonButton));
    closeConfirm(names.confirmPopup, true);
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">
sub numberOfRows
{
    my $table = waitForObject($Names::document_html1_body1_div1_div2_div3_div3_div1_table1);
    my $results = $table-&gt;evaluateXPath(".//TR[contains(\@class, 'jqgrow')]");
    return $results-&gt;snapshotLength;
}

sub createNewAddressBook{
    clickButton(waitForObject($Names::froglogic_addressbook_newbutton_button));
    closeConfirm($Names::confirmpopup, 1);
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">
def numberOfRows
    table = waitForObject(Names::DOCUMENT_HTML1_BODY1_DIV1_DIV2_DIV3_DIV3_DIV1_TABLE1)
    results = table.evaluateXPath(".//TR[contains(@class,'jqgrow')]")
    results.snapshotLength
end

def createNewAddressBook
    clickButton(waitForObject(Names::Froglogic_Addressbook_newButton_button))
    closeConfirm(Names::ConfirmPopup, true)
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">
proc numberOfRows {} {
    set table [waitForObject \
        $names::DOCUMENT_HTML1_BODY1_DIV1_DIV2_DIV3_DIV3_DIV1_TABLE1]
    set results [invoke $table evaluateXPath {.//TR[contains(@class,'jqgrow')]}]
    return [property get $results snapshotLength]
}

proc createNewAddressBook {} {
    invoke clickButton [waitForObject $names::froglogic_Addressbook_newButton_button]
    invoke closeConfirm $names::ConfirmPopup true
}
</pre></div><p>
New BDD Test Cases can easily use the same function:
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">
@When("I create a new addressbook")
def step(context):
    createNewAddressBook()
    test.verify(numberOfRows() == 0)

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">
When("I create a new addressbook", function(context){
    createNewAddressBook()
    test.verify(numberOfRows() == 0);
});
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">
When("I create a new addressbook", sub {
    createNewAddressBook();
    test::verify(numberOfRows() == 0);
});
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">
When("I create a new addressbook") do |context|
    createNewAddressBook
    Test.verify(numberOfRows == 0)
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">
When "I create a new addressbook" {context} {
    	createNewAddressBook
    	test compare [numberOfRows] 0
}
</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="bdd-migration-web-convert"></a>4.6.3.2. Convert existing tests to BDD</h4></div></div></div><p>
The second option is to convert script-based test cases from an existing
<code class="literal">Test Suite</code> into behavior driven tests. Since a <code class="literal">Test
Suite</code> can contain script-based and BDD Test Cases, migration can
be done gradually. A <code class="literal">Test Suite</code> containing a mix
of both Test Case types can be executed and results analyzed without
any extra effort required.
</p><p>
The first step is to review all Test Cases of the existing <code class="literal">Test Suite</code>
and group them by the <code class="literal">Feature</code> they test. Each script-based
Test Case will be transformed into a <code class="literal">Scenario</code>, which is a part of a
<code class="literal">Feature</code>. For example, assume we have 5 script-based Test Cases. After
review, we realize that they examine two <code class="literal">Features</code>.
Therefore, when migration is completed, our Test Suite will contain two BDD Test Cases,
each of them containing one <code class="literal">Feature</code>. Each <code class="literal">Feature</code>
will contain multiple <code class="literal">Scenarios</code>. In our example the first
<code class="literal">Feature</code> contains three <code class="literal">Scenarios</code> and the second
<code class="literal">Feature</code> contains two <code class="literal">Scenarios</code>.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/bdd-tutorial-migration.png" align="middle"></img><div class="caption">Conversion Chart</div></div></div><p>
At the beginning, open a <code class="literal">Test Suite</code> in the <span class="application">Squish IDE</span> that contains
<span class="emphasis"><em>Squish</em></span> tests that are planned to be migrated to BDD. Next, create a
<span class="guibutton">New Script Test Case</span> (<span class="guiicon"><img src="images/ide/new_test_case.png"></img></span>) by choosing <span class="guibutton">New BDD Test Case</span> option from its
context menu. Each BDD Test Case contains a <code class="filename">test.feature</code> file
that can be filled with maximum one <code class="literal">Feature</code>. Next, open the
<code class="filename">test.feature</code> file to describe the <code class="literal">Features</code>
using the Gherkin language. Following the syntax from the template, edit the
<code class="literal">Feature</code> name and optionally provide a short description. Next,
analyze which actions and verifications are performed in the Test Case that
are going to be migrated. This is how an example Test Case for the addressbook
application might start:
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">
def main():
    startBrowser("http://127.0.0.1:9090/AddressBook.html")
    confirmPopup(names.newButton_button)
    test.verify(numberOfRows() == 0, "%d" % numberOfRows())
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">
function main(){
    startBrowser("http://localhost:9090/AddressBook.html");
    confirmPopup(names.newButtonButton);
    test.verify(numberOfRows() == 0);
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">
sub main {
    startBrowser("http://127.0.0.1:9090/AddressBook.html");
    confirmPopup($Names::newbutton_button);
    test::verify(numberOfRows() == 0);
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">
def main
    startBrowser("http://127.0.0.1:9090/AddressBook.html")
    confirmPopup(Names::NewButton_button)
    Test.verify(numberOfRows == 0)
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">
proc main {} {
    invoke startBrowser "http://127.0.0.1:9090/AddressBook.html"
    confirmPopup $names::newButton_button
    test compare [numberOfRows] 0
}
</pre></div><p>
After analyzing the above Test Case we can create
the following  <code class="literal">Scenario</code> and add it to <code class="filename">test.feature</code> file:
</p><pre class="screen">
Scenario: Initial state of created address book
      Given addressbook application is running
      When I create a new addressbook
      Then addressbook should have zero entries
</pre><p>
Next, right-click on the <code class="literal">Scenario</code> and choose the option
<span class="guibutton">Create Missing Step Implementations</span> from the context menu. This
will create a skeleton of steps definitions:
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">
@Given("addressbook application is running")
def step(context):
    test.warning("TODO implement addressbook application is running")

@When("I create a new addressbook")
def step(context):
    test.warning("TODO implement I create a new addressbook")

@Then("addressbook should have zero entries")
def step(context):
    test.warning("TODO implement addressbook should have zero entries")
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">
Given("addressbook application is running", function(context) {
    test.warning("TODO implement addressbook application is running");
});

When("I create a new addressbook", function(context) {
    test.warning("TODO implement I create a new addressbook");
});

Then("addressbook should have zero entries", function(context) {
    test.warning("TODO implement addressbook should have zero entries");
});
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">
Given("addressbook application is running", sub {
    my $context = shift;
    test::warning("TODO implement addressbook application is running");
});

When("I create a new addressbook", sub {
    my $context = shift;
    test::warning("TODO implement I create a new addressbook");
});

Then("addressbook should have zero entries", sub {
    my $context = shift;
    test::warning("TODO implement addressbook should have zero entries");
});
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">
Given("addressbook application is running") do |context|
    Test.warning "TODO implement addressbook application is running"
end

When("I create a new addressbook") do |context|
    Test.warning "TODO implement I create a new addressbook"
end

Then("addressbook should have zero entries") do |context|
    Test.warning "TODO implement addressbook should have zero entries"
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">
Given "addressbook application is running" {context} {
    test warning "TODO implement addressbook application is running"
}

When "I create a new addressbook" {context} {
    test warning "TODO implement I create a new addressbook"
}

Then "addressbook should have zero entries" {context} {
    test warning "TODO implement addressbook should have zero entries"
}
</pre></div><p>
Now we put code snippets from the script-based Test Case into respective
step definitions and remove the lines containing
<code class="code">test.warning</code>. If your Test Cases make use of shared scripts, you
can call those functions from the step definitions as well. For
example, the final result could look like this:
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">
@Given("addressbook application is running")
def step(context):
    startBrowser("http://127.0.0.1:9090/AddressBook.html")
    test.compare(waitForObjectExists("DOCUMENT").title, "froglogic Addressbook")

@When("I create a new addressbook")
def step(context):
    confirmPopup(names.newButton_button)

@Then("addressbook should have zero entries")
def step(context):
    test.verify(numberOfRows() == 0)
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">
Given("addressbook application is running", function(context) {
    startBrowser("http://127.0.0.1:9090/AddressBook.html");
    test.compare(waitForObjectExists("DOCUMENT").title, "froglogic Addressbook");
});

When("I create a new addressbook", function(context) {
    confirmPopup(names.newButtonButton);
});

Then("addressbook should have zero entries", function(context) {
    test.verify(numberOfRows() == 0);
});
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">
Given("addressbook application is running", sub {
    my $context = shift;
    startBrowser("http://127.0.0.1:9090/AddressBook.html");
    test::compare(waitForObjectExists("DOCUMENT")-&gt;title, "froglogic Addressbook");
});

When("I create a new addressbook", sub {
    my $context = shift;
    confirmPopup($Names::newbutton_button);
});

Then("addressbook should have zero entries", sub {
    my $context = shift;
    test::verify(numberOfRows() == 0);
});
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">
Given("addressbook application is running") do |context|
    startBrowser("http://127.0.0.1:9090/AddressBook.html")
    Test.compare(waitForObjectExists("DOCUMENT").title, "froglogic Addressbook")
end

When("I create a new addressbook") do |context|
    confirmPopup(Names::NewButton_button)
end

Then("addressbook should have zero entries") do |context|
    Test.verify(numberOfRows == 0)
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">
Given "addressbook application is running" {context} {
    invoke startBrowser "http://127.0.0.1:9090/AddressBook.html"
    test compare [property get [waitForObjectExists "DOCUMENT"] title] "froglogic Addressbook"
}

When "I create a new addressbook" {context} {
    confirmPopup $names::newButton_button
}

Then "addressbook should have zero entries" {context} {
    test compare [numberOfRows] 0
}
</pre></div><p>
Note that the <code class="code">test.log("Create new addressbook”)</code> got removed while migrating
this Test Case to BDD. When the step
<code class="code">I create a new addressbook</code> is executed, the
step name will be logged into Test Results, so the
<code class="code">test.log</code> call would have been redundant.
</p><p>
Additionally, when a script-based Test Case execution ends, <span class="emphasis"><em>Squish</em></span> terminates
the AUT. Squish ensures that the AUT is terminated at the end of each
<code class="literal">Scenario</code> as well. This is done by the auto-generated
<code class="code">OnScenarioEnd</code> hook, shown below.
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">
@OnScenarioEnd
def hook(context):
    closeWindow(":[Window]");
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">
OnScenarioEnd(function(context) {
    closeWindow(":[Window]");
});
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">
OnScenarioEnd(sub {
    closeWindow(":[Window]");
});
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">
OnScenarioEnd do |context|
  closeWindow(":[Window]");
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">
OnScenarioEnd { context } {
    invoke closeWindow ":\[Window\]"
}
</pre></div><p>
The above example was simplified for this tutorial. In order to take full
advantage of Behavior Driven Testing in <span class="emphasis"><em>Squish</em></span>, please familiarize yourself
with the section <a class="xref" href="api.bdt.functions.html" title="6.19. Behavior Driven Testing">Behavior Driven Testing (Section 6.19)</a> in <a class="xref" href="api.man.html" title="Chapter 6. API Reference Manual">API Reference Manual (Chapter 6)</a>.
</p></div></div><div class="footnotes"><br></br><hr width="100" align="left"></hr><div class="footnote"><p><sup>[<a id="ftn.idp40544192" href="#idp40544192" class="para">9</a>] </sup>
Both <code class="filename">.csv</code> and <code class="filename">.tsv</code> files are
assumed to use the Unicode UTF-8 encoding—the same encoding used
for all test scripts.
</p></div></div></div><script xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" type="text/javascript" src="ScriptingLanguage.js"></script><script xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format">setScriptingLanguage();</script><div class="navfooter"><hr></hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="tutorials-java-bdd.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="tutorials.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="tutorials-win.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">4.5.  Squish for Java BDD Tutorials  </td><td width="20%" align="center"><a accesskey="h" href="index-noframes.html">Home</a></td><td width="40%" align="right" valign="top"> 4.7. Squish for Windows Tutorials</td></tr></table></div></body>
<!-- Mirrored from tutorials-web.html by HTTrack Website Copier/3.x [XR&CO'2013], Wed, 06 Jul 2022 13:28:59 GMT -->
</html>
