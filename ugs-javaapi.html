<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- Mirrored from ugs-javaapi.html by HTTrack Website Copier/3.x [XR&CO'2013], Wed, 06 Jul 2022 13:29:03 GMT -->
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>5.4. How to Use the Java™ API</title><link rel="stylesheet" href="manual.css" type="text/css"></link><meta name="generator" content="DocBook XSL Stylesheets V1.73.2"></meta><link rel="start" href="index-noframes.html" title="Squish Manual"></link><link rel="up" href="users-guide.html" title="Chapter 5. User Guide"></link><link rel="prev" href="ugs-webapi.html" title="5.3. How to Use the Web API"></link><link rel="next" href="ug-how.to.use.the.windows.nativeobject.html" title="5.5. How to Use the Windows nativeObject API"></link><style xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" type="text/css" media="screen">
        div.toc * { margin-left: 6px; margin-right: auto; max-width: 75em; }
        div.toc span { margin-left: 0px; }
        * { margin-left: auto; margin-right: auto; max-width: 75em; }
        body { margin-left: 6px; margin-right: 6px; }
        table th { padding: .5ex }
        table td { padding: .5ex }
    </style><script xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format">
        function keyPress() {
            var e = window.event;
            if ( e == undefined ) {
                return;
            }
            /* ### does not properly scroll, yet
            if ( e.keyCode == 32 ) {
            var l = document.links;
            for ( var i = 0; i < l.length; i++ ) {
                if ( l[i].innerText == "Next" ) {
                location.href = l[i].href;
                }
            }
            } else
                */
                if ( e.keyCode == 0x08 ) {
            var l = document.links;
            for ( var i = 0; i < l.length; i++ ) {
                if ( l[i].innerText == "Prev" ) {
                location.href = l[i].href;
                }
            }
            }
        }
        document.onkeypress = keyPress;
    </script></head><body><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ugs-javaapi"></a>5.4. How to Use the <span class="trademark">Java</span>™ API</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="ugs-javaapi.html#ugsjava-objects">5.4.1. How to Find and Query <span class="trademark">Java</span>™ Objects</a></span></dt><dt><span class="section"><a href="ugs-javaapi.html#ugsjava-methods">5.4.2. How to Call Functions on Java Objects</a></span></dt><dt><span class="section"><a href="ugs-javaapi.html#ugsjava-properties">5.4.3. How to Access <span class="trademark">Java</span>™ Object Properties</a></span></dt><dt><span class="section"><a href="ugs-javaapi.html#ugsjava-convenience">5.4.4. How to Use the <span class="trademark">Java</span>™ Convenience API</a></span></dt><dt><span class="section"><a href="ugs-javaapi.html#ugsjava-arrays">5.4.5. How to Create and Access <span class="trademark">Java</span>™ Arrays</a></span></dt><dt><span class="section"><a href="ugs-javaapi.html#ugs-javawidgets">5.4.6. How to Test <span class="trademark">Java</span>™ Applications</a></span></dt><dt><span class="section"><a href="ugs-javaapi.html#ug-how.to.use.the.java.GestureBuilder">5.4.7. How to Use the GestureBuilder class</a></span></dt></dl></div><p>
One of <span class="emphasis"><em>Squish</em></span>'s most useful features is its ability to access the
toolkit's API from within test scripts. This gives test engineers
sufficient flexibility to allow them to test just about anything in the
AUT.
</p><p>
With <span class="emphasis"><em>Squish</em></span>'s <span class="trademark">Java</span>™-specific API, it is possible to find and query
objects, and to access properties and methods. When we talk about
properties, we mean fields in <span class="trademark">Java</span>™—these are classes that have
methods which follow a particular naming scheme, for example:

</p><pre class="programlisting">
SomeType getSomething();
boolean isSomething();
void setSomething(SomeType someValue);
</pre><p>

When <span class="emphasis"><em>Squish</em></span> sees methods with names of the form
<code class="code">get<span class="emphasis"><em>Xyz</em></span></code> or
<code class="code">is<span class="emphasis"><em>Xyz</em></span></code>, it creates a property called
<code class="code">xyz</code>. The property is read-only unless there is a method
with a name of the form <code class="code">set<span class="emphasis"><em>Xyz</em></span></code>, in
which case the property is read–write. (<span class="emphasis"><em>Squish</em></span> never creates
write-only properties, so if only a setter is present it is treated as a
normal method.) So in the example shown here (and assuming only one of
<code class="code">getSomething</code> or <code class="code">isSomething</code> is defined),
<span class="emphasis"><em>Squish</em></span> will create a property called <code class="code">something</code>.
</p><p>
In addition, <span class="emphasis"><em>Squish</em></span> provides a convenience API—see <a class="xref" href="ugs-javaapi.html#ugsjava-convenience" title="5.4.4. How to Use the Java™ Convenience API">How to Use the <span class="trademark">Java</span>™ Convenience API (Section 5.4.4)</a> for an introduction, and <a class="xref" href="rgs-javaconvenience.html" title="6.7. Java™ Convenience API"><span class="trademark">Java</span>™ Convenience API (Section 6.7)</a> for the whole API. The convenience API
makes it easy to execute common actions on <acronym class="acronym">GUI</acronym>
applications such as clicking a button or entering some text.
</p><p>
The <a class="xref" href="ugs-javaapi.html#ugs-javawidgets" title="5.4.6. How to Test Java™ Applications">How to Test <span class="trademark">Java</span>™ Applications (Section 5.4.6)</a> section later in this manual
provides a wide range of examples that show how to use the scripting
<span class="trademark">Java</span>™ API to access and test complex <span class="trademark">Java</span>™ <acronym class="acronym">GUI</acronym>
elements, including list, table, and tree widgets. Separate examples are
given for AWT/Swing and for SWT applications (although the principles
that apply are the same for both).
</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ugsjava-objects"></a>5.4.1. How to Find and Query <span class="trademark">Java</span>™ Objects</h3></div></div></div><p>
Squish provides the <a class="xref" href="rgs-squish.html#waitForObject-function"><code class="function">waitForObject</code></a> function
which returns the object for a given qualified object name as soon as it
becomes available—for example, when it becomes visible. (For hidden
objects use the <a class="xref" href="rgs-squish.html#findObject-function"><code class="function">findObject</code></a> function
instead).
</p><p>
<span class="emphasis"><em>Squish</em></span> supports three notations for identifying an object by name:
</p><div class="itemizedlist"><ul type="disc"><li><p>
<span class="emphasis"><em>Symbolic name</em></span>—these names are generated
algorithmically and used in the <span class="emphasis"><em>Squish</em></span> <a class="xref" href="rg-objectmap.html" title="7.11. Object Map">Object Map (Section 7.11)</a>
to make it easier to create tests that are robust in the face of changes
to the AUT's object hierarchy. These names are similar to hierarchical
names in that they begin with a colon and consist of one or more
period-separated texts—for example, <code class="code">:Payment
Form.Pay_javax.swing.JButton</code>. Symbolic names are preferred for
test scripts (and are the ones <span class="emphasis"><em>Squish</em></span> uses when recording scripts),
since they make test script maintenance easier. (See <a class="xref" href="rg-objectmap.html#rgos-edit" title="7.11.3. Editing an Object Map">Editing an Object Map (Section 7.11.3)</a> for more about handling object hierarchy changes.)
</p></li><li><p>
<span class="emphasis"><em>Multiple property (real) name</em></span>—a list of
property-name=value pairs in curly braces that uniquely identifies the
object. <span class="emphasis"><em>Squish</em></span> will search the <acronym class="acronym">GUI</acronym>
parent–child hierarchy until it finds a matching object. Here is
an example of such a name: <code class="code">{caption='Pay'
type='javax.swing.JButton' visible='true' window=':Payment
Form_PaymentForm'}</code>. To be valid for most GUI toolkits a
multi-property name (also called a “<span class="quote">real name</span>”) must
include a <code class="code">type</code> property. However, <span class="emphasis"><em>Squish</em></span> for Web and
<span class="emphasis"><em>Squish</em></span> for Windows don't need a <code class="code">type</code> property
specified—but will use it if it is present of course. Notice also
that in this example another object was referred to (the
<code class="code">window</code>); and in this case the reference used a symbolic
name. In general using symbolic names is more robust, but if we need to
identify an object with a variable property (for example, a caption that
might change), then we must use a multi-property name, since this naming
scheme supports wildcards. (See <a class="xref" href="rg-namelookup.html" title="7.10. Improving Object Identification">Improving Object Identification (Section 7.10)</a> for more
about wildcards.)
</p></li><li><p>
<span class="emphasis"><em>Hierarchical name</em></span>—from the top Frame (or
Shell in <acronym class="acronym">SWT</acronym>) the “<span class="quote">path</span>” to the object,
where all parent <acronym class="acronym">GUI</acronym> elements are included with each
one separated by a period. Here is an example of such a name:
<code class="code">:frame0.JRootPane.null_layeredPane.null_contentPane.JLabel</code>.
These names are supported for backwards compatibility but should not be
used in new tests.
</p></li></ul></div><p>
To find the name of an object, you can use the <span class="application">Spy</span> tool to introspect
the AUT. See the <a class="xref" href="ug-editdebug.html#uged-spy" title="5.21.3. How to Use the Spy">How to Use the Spy (Section 5.21.3)</a> section for details.
</p><p>
It is perfectly okay to use both real and symbolic names in tests. The
most common scenario is to use symbolic names (often cut and pasted from
the <a class="xref" href="rg-objectmap.html" title="7.11. Object Map">Object Map (Section 7.11)</a> or from a recorded script), and to
only use real names when the wildcard functionality is required.
</p><p>
To get a reference to an object you can use either a symbolic name or a
real (multi-property) name—or even a hierarchical name. The name
is passed to the <a class="xref" href="rgs-squish.html#waitForObject-function"><code class="function">waitForObject</code></a> function.
For example:
</p><pre class="programlisting">
forenameTextField = waitForObject(":Address Book - " +
    "Add.Forename:_javax.swing.JTextField")
</pre><p>
There are four basic idioms that can be used to access objects. The
first is simply to use the <a class="xref" href="rgs-squish.html#waitForObject-function"><code class="function">waitForObject</code></a>
function as shown here. This is ideal for most situations where the
object in question is expected to be visible. For situations where the
object may not be visible (for example, an object on a Tab page widget
that isn't currently shown), or may not even exist (for example, an
object that is only created by the AUT in certain circumstances), there
are three approaches we can use, depending on our needs.
</p><p>
If we expect the object to be present and visible, but want to account
for rare occasions when it isn't we can use code like this:
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">
try:
    textField = waitForObject(
        ":Credit Card.Account Name:_javax.swing.JTextField")
    # here we can use the textField object reference
except LookupError, err:
    test.fail("Could not find the account name text field")
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">
try {
    var textField = waitForObject(
        ":Credit Card.Account Name:_javax.swing.JTextField");
    // here we can use the textField object reference
} catch(err) {
    test.fail("Could not find the account name text field");
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">
eval {
    my $textField = waitForObject(
        ":Credit Card.Account Name:_javax.swing.JTextField");
    # here we can use the textField object reference
} or do {
    test::fail("Could not find the account name text field");
};
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">
begin
    textField = waitForObject(
        ":Credit Card.Account Name:_javax.swing.JTextField")
    # here we can use the textField object reference
rescue LookupError =&gt; err
    Test.fail("Could not find the account name text field")
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">
catch {
    set textField [waitForObject \
        ":Credit Card.Account Name:_javax.swing.JTextField"]
    # here we can use the textField object reference
} result options
if {[dict get $options -code]} {
    test fail "Could not find the account name text field"
}
</pre></div><p>
If we expect an object to be <span class="emphasis"><em>absent</em></span> (for example, a
button that should disappear in some situations), we can check like this:
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">
code = ('waitForObject(":Credit ' +
        'Card.Account Name:_javax.swing.JTextField")')
test.exception(code, "Correctly didn't find the text field")
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">
var code = 'waitForObject(":Credit ' +
        'Card.Account Name:_javax.swing.JTextField")';
test.exception(code, "Correctly didn't find the text field");
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">
my $code = 'waitForObject(":Credit ' .
        'Card.Account Name:_javax.swing.JTextField")';
test::exception($code, "Correctly didn't find the text field");
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">
code = 'waitForObject(":Credit ' +
       'Card.Account Name:_javax.swing.JTextField")'
Test.exception(code, "Correctly didn't find the text field")
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">
set code = {[waitForObject \
        ":Credit Card.Account Name:_javax.swing.JTextField"]}
test exception $code "Correctly didn't find the text field"
</pre></div><p>
The <a class="xref" href="rgs-squish.html#test.exception-function"><code class="function">test.exception</code></a> function executes the
given code and <span class="emphasis"><em>expects</em></span> the code to throw an
exception.
</p><p>
If we expect an object to be hidden but nonetheless, present (for
example, on a Tab page that isn't the current one), we can still access
it, but this time we cannot use the <a class="xref" href="rgs-squish.html#waitForObject-function"><code class="function">waitForObject</code></a> function—which only works for
visible objects—but instead must use the <a class="xref" href="rgs-squish.html#object.exists-function"><code class="function">object.exists</code></a> function in conjunction with the
<a class="xref" href="rgs-squish.html#findObject-function"><code class="function">findObject</code></a> function:
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">
if object.exists(":Credit Card.Account Name:_javax.swing.JTextField"):
    textField = findObject(
        ":Credit Card.Account Name:_javax.swing.JTextField")
    if textField:
	test.passes("Correctly found the hidden object")
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">
if (object.exists(":Credit Card.Account Name:_javax.swing.JTextField")) {
    var textField = findObject(
        ":Credit Card.Account Name:_javax.swing.JTextField");
    if (textField)
	test.pass("Correctly found the hidden object");
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">
if (object::exists(":Credit Card.Account Name:_javax.swing.JTextField")) {
    my $textField = findObject(
        ":Credit Card.Account Name:_javax.swing.JTextField");
    if ($textField) {
	test::pass("Correctly found the hidden object");
    }
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">
if object.exists(":Credit Card.Account Name:_javax.swing.JTextField")
    textField = findObject(
        ":Credit Card.Account Name:_javax.swing.JTextField")
    if textField
	Test.pass("Correctly found the hidden object")
    end
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">
if {[object exists ":Credit Card.Account Name:_javax.swing.JTextField"]} {
    set textField [findObject \
        ":Credit Card.Account Name:_javax.swing.JTextField"]
    if {![isNull $textField]} {
	test pass "Correctly found the hidden object"
    }
}
</pre></div><p>
Using these techniques it is possible to query and access every object
in the AUT's object hierarchy, regardless of whether they are visible.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ugsjava-methods"></a>5.4.2. How to Call Functions on Java Objects</h3></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="ugs-javaapi.html#ugsjava-passing-null">5.4.2.1. Passing a <code class="code">null</code> value</a></span></dt></dl></div><p>
<span class="emphasis"><em>Squish</em></span> makes it possible to call any public function on any Java
object. (See <a class="xref" href="ugs-javaapi.html#ugsjava-objects" title="5.4.1. How to Find and Query Java™ Objects">How to Find and Query <span class="trademark">Java</span>™ Objects (Section 5.4.1)</a> for details about finding
objects). The following example shows how you can create a <span class="trademark">Java</span>™
object:
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">
s = java_lang_String("A string")
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">
var s = new java_lang_String("A string");
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">
my $s = java_lang_String-&gt;new("A string"); # "old"-style
my $s = new java_lang_String("A string");  # "new"-style
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">
s = java_lang_String.new("A string")
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">
set s [construct java_lang_String "A string"]
</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Java Package Names"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></img></td><th align="left"><a id="java.package.names"></a>Java Package Names</th></tr><tr><td align="left" valign="top"><p>
When referring to <span class="trademark">Java</span>™ objects which are qualified by package names in
<span class="emphasis"><em>Squish</em></span> scripts, the normal periods (“<span class="quote">.</span>”) are replaced with
underscores (“<span class="quote">_</span>”). This is done because period is not allowed
in identifier names (and in some cases has a special meaning)
in most of the scripting languages that <span class="emphasis"><em>Squish</em></span> supports.
See also, <a class="xref" href="rg-autsettings.html#rgas-javawrapping" title="7.3.8.2. Wrapping custom Java™ classes">Wrapping custom <span class="trademark">Java</span>™ classes (Section 7.3.8.2)</a>.
</p></td></tr></table></div><p>
The example below uses the calculator demo application as the AUT. The
tiny JavaScript test script changes the multiply button's text from
<code class="code">*</code> to <code class="code">x</code>:
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">
button = waitForObject(":frame0.*_javax.swing.JButton")
button.setText("x")
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">
var button = waitForObject(":frame0.*_javax.swing.JButton");
button.setText("x");
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">
my $button = waitForObject(":frame0.*_javax.swing.JButton");
$button-&gt;setText("x");
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">
button = waitForObject(":frame0.*_javax.swing.JButton")
button.setText("x")
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">
set button [waitForObject ":frame0.*_javax.swing.JButton"]
invoke $button setText "x"
</pre></div><p>
It is also possible to call static functions. Here is an example that
uses <span class="trademark">Java</span>™'s static <code class="code">Integer.parseInt(String)</code> function:
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">
i = java_lang_Integer.parseInt("12")
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">
var i = java_lang_Integer.parseInt("12");
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">
my $i = java_lang_Integer::parseInt("12");
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">
i = java_lang_Integer.parseInt("12")
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">
set i [invoke java_lang_Integer parseInt "12"]
</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ugsjava-passing-null"></a>5.4.2.1. Passing a <code class="code">null</code> value</h4></div></div></div><p>
A <span class="trademark">Java</span>™ <code class="code">null</code> can be created as follows. Assume a <span class="trademark">Java</span>™ method
call that needs a <code class="code">java.lang.Object</code> as an argument.
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">
obj.doFoo(object.createNull(java_lang_Object))
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">
obj.doFoo(object.createNull(java_lang_Object));
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">
$obj-&gt;doFoo(object::createNull(java_lang_Object));
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">
obj.doFoo(Object.createNull(LC::Java_lang_Object))
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">
invoke $obj doFoo [object createNull java_lang_Object]
</pre></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ugsjava-properties"></a>5.4.3. How to Access <span class="trademark">Java</span>™ Object Properties</h3></div></div></div><p>
<span class="trademark">Java</span>™ objects can have fields (sometimes called properties). Public
fields are accessible in <span class="emphasis"><em>Squish</em></span> as the following example demonstrates:
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">
point = java_awt_Point(5, 8)
test.log(point.x)
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">
var point = new java_awt_Point(5, 8);
test.log(point.x);
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">
my $point = java_awt_Point-&gt;new(5, 8); # "old"-style
my $point = new java_awt_Point(5, 8);  # "new"-style
test::log($point-&gt;x);
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">
point = java_awt_Point.new(5, 8)
Test.log(point.x)
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">
set point [construct java_awt_Point 5 8]
test log [toString [property get $point x]]
</pre></div><p>
In addition to public fields, <span class="emphasis"><em>Squish</em></span> adds synthetic properties derived
from method names with the <code class="function">SomeType getSomething()</code>,
<code class="function">boolean isSomething()</code> and <code class="function">void
setSomething(SomeType someValue)</code> pattern (see <a class="xref" href="ugs-javaapi.html" title="5.4. How to Use the Java™ API">How to Use the <span class="trademark">Java</span>™ API (Section 5.4)</a> for details). In the example where we changed
the button text with <code class="code">setText("x")</code>, we could have achieved
the same thing using property syntax. Here's the example again:
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">
button = waitForObject(":frame0.*_javax.swing.JButton")
button.text = "New Text"
test.log(button.text)
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">
var button = waitForObject(":frame0.*_javax.swing.JButton");
button.text = "New Text";
test.log(button.text);
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">
my $button = waitForObject(":frame0.*_javax.swing.JButton");
$button-&gt;text = "New Text";
test::log($button-&gt;text);
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">
button = waitForObject(":frame0.*_javax.swing.JButton")
button.text = "New Text"
Test.log(button.text)
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">
set button [waitForObject ":frame0.*_javax.swing.JButton"]
property set $button text "New Text"
test log [property get $button text]
</pre></div><p>
When <span class="emphasis"><em>Squish</em></span> encounters code that sets a property it automatically does
the appropriate call. For example, using JavaScript,
<code class="code">button.setText("x")</code>. Similarly, if we try to read a value
using property syntax, <span class="emphasis"><em>Squish</em></span> will use the appropriate getter syntax,
for example (and again using JavaScript), <code class="code">var text =
button.text</code> will be treated as <code class="code">var text =
button.getText()</code>.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Java Synthetic
Properties"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></img></td><th align="left"><a id="java.synthetic.properties"></a>Java Synthetic
Properties</th></tr><tr><td align="left" valign="top"><p>
Synthetic properties—that is, properties created by <span class="emphasis"><em>Squish</em></span> based
on function signatures—make it easier to add more verification
points to test scripts. (See <a class="xref" href="ug-vps.html" title="5.22. How to Create and Use Verification Points">How to Create and Use Verification Points (Section 5.22)</a> for more details.)
</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ugsjava-convenience"></a>5.4.4. How to Use the <span class="trademark">Java</span>™ Convenience API</h3></div></div></div><p>
This section describes the script API <span class="emphasis"><em>Squish</em></span> offers on top of <span class="trademark">Java</span>™'s
API to make it easy to perform common user actions such as clicking a
button, entering text, etc. A complete list of the API is available in
the <a class="xref" href="rgs-javaconvenience.html" title="6.7. Java™ Convenience API"><span class="trademark">Java</span>™ Convenience API (Section 6.7)</a> section in the <a class="xref" href="ref.man.html" title="Chapter 7. Tools Reference Manual">Tools Reference Manual (Chapter 7)</a>. Below are a few examples to give a flavor
of how the API's functions are used.
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">
clickButton(":frame0_Notepad$1")
type(":frame0_javax.swing.JTextArea", "Some text")
activateItem(":frame0_javax.swing.JMenuBar", "File")
activateItem(":frame0.File_javax.swing.JMenu", "Exit")
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">
clickButton(":frame0_Notepad$1");
type(":frame0_javax.swing.JTextArea", "Some text");
activateItem(":frame0_javax.swing.JMenuBar", "File");
activateItem(":frame0.File_javax.swing.JMenu", "Exit");
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">
clickButton(":frame0_Notepad$1");
type(":frame0_javax.swing.JTextArea", "Some text");
activateItem(":frame0_javax.swing.JMenuBar", "File");
activateItem(":frame0.File_javax.swing.JMenu", "Exit");
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">
clickButton(":frame0_Notepad$1")
type(":frame0_javax.swing.JTextArea", "Some text")
activateItem(":frame0_javax.swing.JMenuBar", "File")
activateItem(":frame0.File_javax.swing.JMenu", "Exit")
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">
invoke clickButton ":frame0_Notepad$1"
invoke type ":frame0_javax.swing.JTextArea" "Some text"
invoke activateItem ":frame0_javax.swing.JMenuBar" "File"
invoke activateItem ":frame0.File_javax.swing.JMenu" "Exit"
</pre></div><p>
Here, we have clicked a button, typed in some text, and activated a menu
and a menu item. Many more examples are given later on in the
manual—they cover both AWT/Swing and SWT, including interactions
with many different widgets such as line edits, spinners, lists, tables,
and trees—see <a class="xref" href="ugs-javaapi.html#ugs-javawidgets" title="5.4.6. How to Test Java™ Applications">How to Test <span class="trademark">Java</span>™ Applications (Section 5.4.6)</a>.
</p><p>
The complete API contains a <span class="emphasis"><em>lot</em></span> more functions than
the three we have shown here. Note also, that the same API works for
both AWT/Swing applications and for SWT applications—the only
difference is that they have different widgets and different object
names.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ugsjava-arrays"></a>5.4.5. How to Create and Access <span class="trademark">Java</span>™ Arrays</h3></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="ugs-javaapi.html#accessing.java.arrays">5.4.5.1. Accessing Java Arrays</a></span></dt><dt><span class="section"><a href="ugs-javaapi.html#creating.and.using.javaarrays">5.4.5.2. Creating and Using JavaArrays</a></span></dt></dl></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="accessing.java.arrays"></a>5.4.5.1. Accessing Java Arrays</h4></div></div></div><p>
Some of the methods in the <span class="trademark">Java</span>™ API return <code class="code">Array</code>s (called
<code class="code">JavaArray</code>s in <span class="emphasis"><em>Squish</em></span>) rather than single objects. The
number of elements in such an array is accessible using the <a class="xref" href="rgs-javaconvenience.html#java-JavaArray.length-property">JavaArray.length</a> property, and individual
elements can be accessed using the <a class="xref" href="rgs-javaconvenience.html#java-JavaArray.at-function"><code class="function">JavaArray.at</code></a> method parametrized by the
array index. Here is an example that lists the JPanel's in a
JTabbedPane:
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">
tabPane = waitForObject(":Payment Form_javax.swing.JTabbedPane")
components = tabPane.getComponents()
for i in range(components.length):
    test.log("Component #%d: %s" % (i, components.at(i)))
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">
var tabPane = waitForObject(":Payment Form_javax.swing.JTabbedPane");
var components = tabPane.getComponents();
for (var i = 0; i &lt; components.length; ++i)
    test.log("Component #" + i + ": " + components.at(i));
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">
my $tabPane = waitForObject(":Payment Form_javax.swing.JTabbedPane");
my $components = $tabPane-&gt;getComponents();
for (my $i = 0; $i &lt; $components-&gt;length; ++$i) {
    test::log("Component #$i: ". $components-&gt;at($i) . "\n");
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">
tabPane = waitForObject(":Payment Form_javax.swing.JTabbedPane")
components = tabPane.getComponents()
for i in 0...components.length
    Test.log("Component ##{i}: #{components.at(i)}")
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">
set tabPane [waitForObject ":Payment Form_javax.swing.JTabbedPane"]
set components [invoke $tabPane getComponents]
for {set i 0} {$i &lt; [property get $components length]} {incr i} {
    test log [concat "Component #$i: " \
        [toString [invoke $components at $i]]]
}
</pre></div><p>
Another example is shown in the <a class="xref" href="ugs-javaapi.html#testing-tree-widget-java-swt" title="5.4.6.2.2.3. How to Test Tree">How to Test Tree (Section 5.4.6.2.2.3)</a>'s <code class="filename">tst_tree</code>
test script.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="creating.and.using.javaarrays"></a>5.4.5.2. Creating and Using JavaArrays</h4></div></div></div><p>
In addition to accessing the <span class="trademark">Java</span>™ arrays returned by <span class="emphasis"><em>Squish</em></span>
functions as shown above, it is also possible to create your own <a class="xref" href="rgs-javaconvenience.html#native.java.arrays" title="6.7.1. Native Java Arrays">Native Java Arrays (Section 6.7.1)</a>. Here are some examples to give a flavor
of how JavaArrays are used. Notice that if we store items as
<code class="code">java.lang.Object</code>s, then we can store pretty well any kind
of data we like.
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

    variousObjects = JavaArray(5) # creates a java.lang.Object[5] array
    variousObjects.set(0, waitForObject(":Payment Form.Cancel_javax.swing.JButton"))
    variousObjects.set(1, java_lang_Object())
    variousObjects.set(2, 4)           # converted to java.lang.Integer
    variousObjects.set(3, "some text") # converted to java.lang.String
    test.compare(variousObjects.at(0).text, "Cancel")
    test.compare(variousObjects.at(1).getClass().getName(), "java.lang.Object")
    test.compare(variousObjects.at(2), 4)
    test.compare(variousObjects.at(3), "some text")
    test.verify(variousObjects.length == 5)
    
    integers = JavaArray(42, "int") # creates an int[42] array
    integers.set(23, -71)
    test.compare(integers.at(23), -71)
    test.verify(integers.length == 42)
    
    strings = JavaArray(10, "java.lang.String") # java.lang.String[10]
    strings.set(4, "more text")
    test.compare(strings.at(4), "more text")
    test.verify(strings.length == 10)
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

    var variousObjects = new JavaArray(5); // creates a java.lang.Object[5] array
    variousObjects.set(0, waitForObject(":Payment Form.Cancel_javax.swing.JButton"));
    variousObjects.set(1, new java_lang_Object());
    variousObjects.set(2, 4);           // converted to java.lang.Integer
    variousObjects.set(3, "some text"); // converted to java.lang.String
    test.compare(variousObjects.at(0).text, "Cancel");
    test.compare(variousObjects.at(1).getClass().getName(), "java.lang.Object");
    test.compare(variousObjects.at(2), 4);
    test.compare(variousObjects.at(3), "some text");
    test.verify(variousObjects.length == 5);
    
    var integers = new JavaArray(42, "int"); // creates an int[42] array
    integers.set(23, -71);
    test.compare(integers.at(23), -71);
    test.verify(integers.length == 42);
    
    var strings = new JavaArray(10, "java.lang.String"); // java.lang.String[10]
    strings.set(4, "more text");
    test.compare(strings.at(4), "more text");
    test.verify(strings.length == 10);
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

    my $variousObjects = JavaArray-&gt;new(5); # creates a java.lang.Object[5] array
    $variousObjects-&gt;set(0, waitForObject(":Payment Form.Cancel_javax.swing.JButton"));
    $variousObjects-&gt;set(1, java_lang_Object-&gt;new());
    $variousObjects-&gt;set(2, 4);           # converted to java.lang.Integer
    $variousObjects-&gt;set(3, "some text"); # converted to java.lang.String
    #test::compare($variousObjects-&gt;at(0)-&gt;text, "Cancel");
    test::compare($variousObjects-&gt;at(1)-&gt;getClass()-&gt;getName(), "java.lang.Object");
    test::compare($variousObjects-&gt;at(2), 4);
    test::compare($variousObjects-&gt;at(3), "some text");
    test::verify($variousObjects-&gt;length == 5);
    
    my $integers = JavaArray-&gt;new(42, "int"); # creates an int[42] array
    $integers-&gt;set(23, -71);
    test::compare($integers-&gt;at(23), -71);
    test::verify($integers-&gt;length == 42);
    
    my $strings = JavaArray-&gt;new(10, "java.lang.String"); # java.lang.String[10]
    $strings-&gt;set(4, "more text");
    test::compare($strings-&gt;at(4), "more text");
    test::verify($strings-&gt;length == 10);
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

    variousObjects = JavaArray.new(5) # creates a java.lang.Object[5] array
    variousObjects.set(0, waitForObject(":Payment Form.Cancel_javax.swing.JButton"))
    variousObjects.set(1, LC::Java_lang_Object.new)
    variousObjects.set(2, 4)					 # converted to java.lang.Integer
    variousObjects.set(3, "some text") # converted to java.lang.String
    Test.compare(variousObjects.at(0).text, "Cancel")
    Test.compare(variousObjects.at(1).getClass().getName(), "java.lang.Object")
    Test.compare(variousObjects.at(2), 4)
    Test.compare(variousObjects.at(3), "some text")
    Test.verify(variousObjects.length == 5)

    integers = JavaArray.new(42, "int") # creates an int[42] array
    integers.set(23, -71)
    Test.compare(integers.at(23), -71)
    Test.verify(integers.length == 42)

    strings = JavaArray.new(10, "java.lang.String") # java.lang.String[10]
    strings.set(4, "more text")
    Test.compare(strings.at(4), "more text")
    Test.verify(strings.length == 10)
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

    set variousObjects [construct JavaArray 5]
    invoke $variousObjects set 0 [waitForObject ":Payment Form.Cancel_javax.swing.JButton"]
    invoke $variousObjects set 1 [construct java_lang_Object]
    # converted to java.lang.Integer
    invoke $variousObjects set 2 4
    # converted to java.lang.String
    invoke $variousObjects set 3 "some text"
    test compare [property get [invoke $variousObjects at 0] text] "Cancel"
    test compare [invoke [invoke [invoke $variousObjects at 1] getClass] getName] "java.lang.Object"
    test compare [invoke $variousObjects at 2] 4
    test compare [invoke $variousObjects at 3] "some text"
    test compare [property get $variousObjects length] 5
    
    # creates an int[42] array
    set integers [construct JavaArray 42 "int"]
    invoke $integers set 23 [expr -71]
    test compare [invoke $integers at 23] -71
    test compare [property get $integers length] 42
    
    # java.lang.String[10]
    set strings [construct JavaArray 10 "java.lang.String"]
    invoke $strings set 4 "more text"
    test compare [invoke $strings at 4] "more text"
    test compare [property get $strings length] 10
</pre></div><p>
The JavaArray API is documented in <a class="xref" href="rgs-javaconvenience.html#native.java.arrays" title="6.7.1. Native Java Arrays">Native Java Arrays (Section 6.7.1)</a>.
</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ugs-javawidgets"></a>5.4.6. How to Test <span class="trademark">Java</span>™ Applications</h3></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="ugs-javaapi.html#ug-java-awt-how-to-test-applications">5.4.6.1. How to Test <span class="trademark">Java</span>™ AWT/Swing Applications</a></span></dt><dt><span class="section"><a href="ugs-javaapi.html#ug-java-swt-how-to-test-applications">5.4.6.2. How to Test <span class="trademark">Java</span>™ SWT Applications</a></span></dt><dt><span class="section"><a href="ugs-javaapi.html#ugsjavaw-list">5.4.6.3. How to Test List and ComboBoxes Using Proxies</a></span></dt><dt><span class="section"><a href="ugs-javaapi.html#ugsjavaw-geflist">5.4.6.4. How to Test GEF applications</a></span></dt></dl></div><p>
In this section we will see how the <span class="emphasis"><em>Squish</em></span> API makes it
straightforward to check the values and states of individual widgets so
that we can test our application's business rules.
</p><p>
As we saw in the tutorial, we can use <span class="emphasis"><em>Squish</em></span>'s recording facility to
create tests. However, it is often useful to modify such tests, or
create tests entirely from scratch in code, particularly when we want to
test business rules that involve multiple widgets.
</p><p>
In general there is no need to test a widget's standard behavior. For
example, if an unchecked two-valued checkbox isn't checked after being
clicked, that's a bug in the toolkit not in our code. If such a case
arose we may need to write a workaround (and write tests for it), but
normally we don't write tests just to check that a widget behaves as
documented. On the other hand, what we do want to test is whether our
application provides the business rules we intended to build into it. Some
tests concern individual widgets in isolation—for example, testing
that a combobox contains the appropriate items. Other tests concern
inter-widget dependencies and interactions. For example, if we have a
group of "payment method" radio buttons, we will want to test that if
the "cash" radio button is chosen the check and credit card-relevant
widgets are all hidden.
</p><p>
The purpose of this section is to explain and show how to access various
<span class="trademark">Java</span>™ widgets and perform common operations using these
widgets—such as getting and setting their properties—with
the JavaScript, Perl, Python, Ruby, and Tcl scripting languages.
</p><p>
After completing this section you should be able to access <span class="trademark">Java</span>™
widgets, gather data from those <span class="trademark">Java</span>™ widgets, and perform tests
against expected values. The principles covered in this chapter apply to
all <span class="trademark">Java</span>™ widgets, so even if you need to test a widget that isn't
specifically mentioned here, you should have no problem doing so.
</p><p>
Whether we are testing individual widgets or inter-widget dependencies
and interactions, we must first be able to get references to the widgets
we want to test. Once we have a reference we can then verify that the
widget it refers to has the value and is in the state that we expect.
</p><p>
To test and verify a widget and its properties or contents in code,
first we need access to the widget in the test script. To obtain a
reference to the widget, the <a class="xref" href="rgs-squish.html#waitForObject-function"><code class="function">waitForObject</code></a>
function is used. This function finds the widget with the given name
and returns a reference to it. For this purpose we need to know the name
of the widget we want to test, and we can get the name using the <span class="application">Spy</span>
tool (see <a class="xref" href="ug-editdebug.html#uged-spy" title="5.21.3. How to Use the Spy">How to Use the Spy (Section 5.21.3)</a>) and adding the object to the <a class="xref" href="rg-objectmap.html" title="7.11. Object Map">Object Map (Section 7.11)</a> (so that <span class="emphasis"><em>Squish</em></span> will remember it) and then
copying the object's name (preferably its symbolic name) to the
clipboard ready to be pasted into our test. If we need to gather the
names of lots of widgets it is probably faster and easier to record a
dummy test during which we make sure that we access every widget we want
to verify in our manually written test script. This will cause <span class="emphasis"><em>Squish</em></span>
to add all the relevant names to the <a class="xref" href="rg-objectmap.html" title="7.11. Object Map">Object Map (Section 7.11)</a>,
which we can then copy and paste into our code.
Another approach is to obtain a reference to a container widget as just
described, and then use <span class="trademark">Java</span>™'s introspection facilities to obtain
references to the widgets contained in the container. We will show both
approaches in this section.
</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ug-java-awt-how-to-test-applications"></a>5.4.6.1. How to Test <span class="trademark">Java</span>™ AWT/Swing Applications</h4></div></div></div><p>
In the subsections that follow we will focus on testing <span class="trademark">Java</span>™ AWT/Swing
widgets, both single-valued widgets like buttons and spinners, and
multi-valued widgets such as lists, tables, and trees. We will also
cover testing using external data files. (If you are using Java SWT,
skip ahead to <a class="xref" href="ugs-javaapi.html#ug-java-swt-how-to-test-applications" title="5.4.6.2. How to Test Java™ SWT Applications">How to Test <span class="trademark">Java</span>™ SWT Applications (Section 5.4.6.2)</a>.)
</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ugjava-awt-paymentform-example"></a>5.4.6.1.1. How to Test Stateful and Single-Valued Widgets
(<span class="trademark">Java</span>™—AWT/Swing)</h5></div></div></div><p>
In this section we will see how to test the
<code class="filename">examples/java/paymentform/PaymentForm.java</code> example
program. This program uses many basic <span class="trademark">Java</span>™ AWT/Swing widgets including
<code class="code">JButton</code>, <code class="code">JCheckBox</code>, <code class="code">JComboBox</code>,
<code class="code">JSpinner</code>, and <code class="code">JTextField</code>. As part of our
coverage of the example we will show how to check the values and state
of individual widgets. We will also demonstrate how to test a form's
business rules.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/ug-paymentform-java.png" align="middle"></img><div class="caption"><p>The <code class="code">PaymentForm</code> example in "pay by credit card" mode.
</p></div></div></div><p>
The <code class="code">PaymentForm</code> is invoked when an invoice is to be paid,
either at a point of sale, or—for credit cards—by phone. The
form's <span class="guibutton">Pay</span> button must only be enabled if the
correct fields are filled in and have valid values. The business rules
that we must test for are as follows:
</p><div class="itemizedlist"><ul type="disc"><li><p>
In "cash" mode, i.e., when the Cash tab is checked:
</p><div class="itemizedlist"><ul type="circle"><li><p>
The minimum payment is one dollar and the maximum is $2000 or
the amount due, whichever is smaller.
	</p></li></ul></div><p>
</p></li><li><p>
In "check" mode, i.e., when the Check tab is checked:
</p><div class="itemizedlist"><ul type="circle"><li><p>
The minimum payment is $10 and the maximum is $250 or the amount due,
whichever is smaller.
	</p></li><li><p>
The check date must be no earlier than 30 days ago and no later than
tomorrow.
	</p></li><li><p>
The bank name, bank number, account name, and account number line edits
must all be nonempty.
	</p></li><li><p>
The check signed checkbox must be checked.
	</p></li></ul></div><p>
</p></li><li><p>
In "card" mode, i.e., when the Credit Card tab is checked:
</p><div class="itemizedlist"><ul type="circle"><li><p>
The minimum payment is $10 or 5% of the amount due whichever is larger,
and the maximum is $5000 or the amount due, whichever is smaller.
	</p></li><li><p>
For non-Visa cards the issue date must be no earlier than three years
ago.
	</p></li><li><p>
The expiry date must be at least one month later than today.
	</p></li><li><p>
The account name and account number line edits must be nonempty.
	</p></li></ul></div><p>
</p></li></ul></div><p>
We will write three tests, one for each of the form's modes.
</p><p>
The source code for the payment form is in the directory
<code class="filename">SQUISHDIR/examples/java/paymentform</code>, and the test
suites are in subdirectories underneath—for example, the Python
version of the tests is in the directory
<code class="filename">SQUISHDIR/examples/java/paymentform/suite_py</code>, and
the JavaScript version of the tests is in
<code class="filename">SQUISHDIR/examples/java/paymentform/suite_js</code>, and
so on.
</p><p>
We will begin by reviewing the test script for testing the form's
"cash" mode. First we will show the code, then we will explain it.
</p><div class="example"><a id="idp45452688"></a><p class="title"><b>Example 5.17. The tst_cash_mode Test Script</b></p><div class="example-contents"><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">
import os
def main():
    startApplication('"' + os.environ["SQUISH_PREFIX"] + '/examples/java/paymentform/PaymentFormSwing.jar"')
    # Start with the correct tab
    tabWidgetName = ":Payment Form.Cash_com.froglogic.squish.awt.TabProxy" 
    waitForObject(tabWidgetName)
    clickTab(tabWidgetName)

    # Business rule #1: the minimum payment is $1 and the maximum is
    # $2000 or the amount due whichever is smaller
    amountDueLabelName = ("{caption?='[$][0-9.,]*' "
        "type='javax.swing.JLabel' "
        "visible='true' window=':Payment Form_PaymentForm'}")
    amountDueLabel = waitForObject(amountDueLabelName)
    chars = []
    for char in str(amountDueLabel.getText()):
        if char.isdigit():
            chars.append(char)
    amount_due = cast("".join(chars), int)
    maximum = min(2000, amount_due)
    paymentSpinnerName = ("{type='javax.swing.JSpinner' visible='true' "
            "window=':Payment Form_PaymentForm'}")
    paymentSpinner = waitForObject(paymentSpinnerName)
    model = paymentSpinner.getModel()
    test.verify(model.minimum.intValue() == 1)
    test.verify(model.maximum.intValue() == maximum)
    
    # Business rule #2: the Pay button is enabled (since the above tests
    # ensure that the payment amount is in range)
    payButtonName = ":Payment Form.Pay_javax.swing.JButton"
    payButton = waitForObject(payButtonName)
    test.verify(payButton.enabled)

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">
function main()
{
    startApplication('"' + OS.getenv("SQUISH_PREFIX") + '/examples/java/paymentform/PaymentFormSwing.jar"');
    // Start with the correct tab
    var tabWidgetName = ":Payment Form.Cash_com.froglogic." +
        "squish.awt.TabProxy";
    waitForObject(tabWidgetName);
    clickTab(tabWidgetName);

    // Business rule #1: the minimum payment is $1 and the maximum is
    // $2000 or the amount due whichever is smaller
    var amountDueLabelName = "{caption?='[$][0-9.,]*' " +
	    "type='javax.swing.JLabel' visible='true' " +
	    "window=':Payment Form_PaymentForm'}";
    var amountDueLabel = waitForObject(amountDueLabelName);
    var amount_due = 0 + amountDueLabel.text.replace(/\D/g, "");
    var maximum = Math.min(2000, amount_due);

    var paymentSpinnerName = "{type='javax.swing.JSpinner' " +
	    "visible='true' window=':Payment Form_PaymentForm'}";
    var paymentSpinner = waitForObject(paymentSpinnerName);
    var model = paymentSpinner.getModel();
    test.verify(model.minimum.intValue() == 1);
    test.verify(model.maximum.intValue() == maximum);
    
    // Business rule #2: the Pay button is enabled (since the above tests
    // ensure that the payment amount is in range)
    var payButtonName = ":Payment Form.Pay_javax.swing.JButton";
    var payButton = waitForObject(payButtonName);
    test.verify(payButton.enabled);
}

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">
sub main
{
    startApplication("\"$ENV{'SQUISH_PREFIX'}/examples/java/paymentform/PaymentFormSwing.jar\"");
    # Start with the correct tab
    my $tabWidgetName = ":Payment Form.Cash_com.froglogic." .
        "squish.awt.TabProxy";
    waitForObject($tabWidgetName);
    clickTab($tabWidgetName);

    # Business rule #1: the minimum payment is $1 and the maximum is
    # $2000 or the amount due whichever is smaller
    my $amountDueLabelName = "{caption?='[\$][0-9.,]*' " .
	    "type='javax.swing.JLabel' visible='true' " .
	    "window=':Payment Form_PaymentForm'}";
    my $amountDueLabel = waitForObject($amountDueLabelName);
    my $amount_due = $amountDueLabel-&gt;text;
    $amount_due =~ s/\D//g; # remove non-digits
    my $maximum = 2000 &lt; $amount_due ? 2000 : $amount_due;

    my $paymentSpinnerName = "{type='javax.swing.JSpinner' " .
	    "visible='true' window=':Payment Form_PaymentForm'}";
    my $paymentSpinner = waitForObject($paymentSpinnerName);
    my $model = $paymentSpinner-&gt;getModel();
    test::verify($model-&gt;minimum-&gt;intValue() == 1);
    test::verify($model-&gt;maximum-&gt;intValue() == $maximum);
   
    # Business rule #2: the Pay button is enabled (since the above tests
    # ensure that the payment amount is in range)
    my $payButtonName = ":Payment Form.Pay_javax.swing.JButton";
    my $payButton = waitForObject($payButtonName);
    test::verify($payButton-&gt;enabled);
}

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">
# encoding: UTF-8
require 'squish'
include Squish

def main
    startApplication("\"#{ENV['SQUISH_PREFIX']}/examples/java/paymentform/PaymentFormSwing.jar\"")
    # Start with the correct tab
    tabWidgetName = ":Payment Form.Cash_com.froglogic.squish.awt.TabProxy"
    waitForObject(tabWidgetName)
    clickTab(tabWidgetName)

    # Business rule #1: the minimum payment is $1 and the maximum is
    # $2000 or the amount due whichever is smaller
    amountDueLabelName = "{caption?='[$][0-9.,]*' " +
    "type='javax.swing.JLabel' " +
    "visible='true' window=':Payment Form_PaymentForm'}"
    amountDueLabel = waitForObject(amountDueLabelName)
    amount_due = String(amountDueLabel.text).gsub(/\D/, "").to_f
    maximum = 2000 &lt; amount_due ? 2000 : amount_due
    paymentSpinnerName = "{type='javax.swing.JSpinner' visible='true' " +
    "window=':Payment Form_PaymentForm'}"
    paymentSpinner = waitForObject(paymentSpinnerName)
    model = paymentSpinner.getModel()
    Test.verify(model.minimum.intValue() == 1)
    Test.verify(model.maximum.intValue() == maximum)

    # Business rule #2: the Pay button is enabled (since the above tests
    # ensure that the payment amount is in range)
    payButtonName = ":Payment Form.Pay_javax.swing.JButton"
    payButton = waitForObject(payButtonName)
    Test.verify(payButton.enabled)
end

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">
proc main {} {
    startApplication "\"$::env(SQUISH_PREFIX)/examples/java/paymentform/PaymentFormSwing.jar\""
    # Start with the correct tab
    set tabWidgetName ":Payment Form.Cash_com.froglogic.squish.awt.TabProxy" 
    waitForObject $tabWidgetName
    invoke clickTab $tabWidgetName

    # Business rule #1: the minimum payment is $1 and the maximum is
    # $2000 or the amount due whichever is smaller
    set amountDueLabelName {{caption?='[$][0-9.,]*' \
        type='javax.swing.JLabel' visible='true' \
        window=':Payment Form_PaymentForm'}}
    set amountDueLabel [waitForObject $amountDueLabelName]
    set amountText [toString [property get $amountDueLabel text]]
    regsub -all {\D} $amountText "" amountText
    set amount_due [expr $amountText]
    set maximum [expr $amount_due &lt; 2000 ? $amount_due : 2000]

    set paymentSpinnerName {{type='javax.swing.JSpinner' \
        visible='true' window=':Payment Form_PaymentForm'}}
    set paymentSpinner [waitForObject $paymentSpinnerName]
    set model [invoke $paymentSpinner getModel]
    set minimumAllowed [invoke [property get $model minimum] intValue]
    set maximumAllowed [invoke [property get $model maximum] intValue]
    test compare $minimumAllowed 1
    test compare $maximumAllowed $maximum
    
    # Business rule #2: the Pay button is enabled (since the above tests
    # ensure that the payment amount is in range)
    set payButtonName ":Payment Form.Pay_javax.swing.JButton"
    waitForObject $payButtonName
    set payButton [findObject $payButtonName]
    test verify [property get $payButton enabled]
}

</pre></div></div></div><br class="example-break"></br><p>
We must start by making sure that the form is in the mode we want to
test. In general, the way we gain access to visible widgets is always
the same: we create a variable holding the widget's name, then we call
the <a class="xref" href="rgs-squish.html#waitForObject-function"><code class="function">waitForObject</code></a> function to get a reference
to the widget. Once we have the reference we can use it to access the
widget's properties and to call the widget's methods. In this case we
don't need to call the <a class="xref" href="rgs-squish.html#waitForObject-function"><code class="function">waitForObject</code></a> function
on the tab's name since we don't need a reference to the tab; instead we
just use the <a class="xref" href="rgs-javaconvenience.html#java-clickTab-function"><code class="function">clickTab</code></a> function to click
the tab we are interested in. How did we know the tab's name? We ran a
dummy test and clicked each of the tabs—as a result <span class="emphasis"><em>Squish</em></span> put
the tab names in the object map and we copied them from there.
</p><p>
The first business rule to be tested concerns the minimum and maximum
allowed payment amounts. As usual we begin by calling <a class="xref" href="rgs-squish.html#waitForObject-function"><code class="function">waitForObject</code></a> to get references to the objects we
need to access—in this case starting with the amount due label.
Because the amount due label's text varies depending on the amount we
cannot have a fixed name for it. So instead we identify it using a
multi-property (real) name using wildcards. The wildcard of
<code class="code">[$][0-9.,]*</code> matches any text that starts with a dollar sign
and is followed by zero or more digits, periods and commas. <span class="emphasis"><em>Squish</em></span> can
also do regular expression matching—see <a class="xref" href="rg-namelookup.html" title="7.10. Improving Object Identification">Improving Object Identification (Section 7.10)</a> for more about matching.
</p><p>
Since the label's text might contain a currency symbol and grouping
markers (for example, $1,700 or €1.700), to convert its text into an
integer we must strip away any non-digit characters first. We do this in
different ways depending on the underlying scripting language. (For
example, in Python, we iterate over each character and join all those
that are digits into a single string and use the <a class="xref" href="rgs-squish.html#cast-function"><code class="function">cast</code></a> function which takes an object and the type
the object should be converted to, and returns an object of the
requested type—or 0 on failure. We use a similar approach in
JavaScript, but for Perl and Tcl we simply strip out non-digit characters
using a regular expression.) The resulting integer is the amount due, so
we can now trivially calculate the maximum amount that can be paid in
cash.
</p><p>
With the minimum and maximum amounts known we next get a reference to
the payment spinner. (In this case we didn't get the name from the
object map, but guessed it. Alternatively, we could have used
introspection, a technique we will use shortly.) Once we have a
reference to the spinner, we retrieve its number model. Then we use the
<a class="xref" href="rgs-squish.html#test.verify-function"><code class="function">test.verify</code></a> function to ensure that the model
has the correct minimum and maximum amounts set. (For Tcl we have used
the <a class="xref" href="rgs-squish.html#test.compare-function"><code class="function">test.compare</code></a> function instead of <a class="xref" href="rgs-squish.html#test.verify-function"><code class="function">test.verify</code></a> since it is more convenient to do so.)
</p><p>
Checking the last business rule is easy in this case since if the amount
is in range (and it must be because we have just checked it), then
payment is allowed so the <span class="guibutton">Pay</span> button should be
enabled. Once again, we use the same approach to test this: first we
call the <a class="xref" href="rgs-squish.html#waitForObject-function"><code class="function">waitForObject</code></a> function to get a
reference, and then we conduct the test—in this case checking that
the <span class="guibutton">Pay</span> button is enabled.
</p><p>
Although the "cash" mode test works well, there are a few places where
we use essentially the same code. So before creating the test for the
"check" and "card" modes, we will create some common functions that we
can use to refactor our tests with. (The process used to create shared
code is described a little later in <a class="xref" href="ug-shareddata.html" title="5.23. How to Create and Use Shared Data and Shared Scripts">How to Create and Use Shared Data and Shared Scripts (Section 5.23)</a>—essentially all we need to do is create
a new script under the Test Suite's shared item's scripts item.) The
Python common code is in <code class="filename">common.py</code>, the JavaScript
common code is in <code class="filename">common.js</code>, and so on.
</p><div class="example"><a id="idp45477848"></a><p class="title"><b>Example 5.18. The Shared Code</b></p><div class="example-contents"><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">
def clickTabbedPane(text):
    waitForObject(":Payment Form.%s_com.froglogic.squish.awt.TabProxy" % (
        text))
    clickTab(":Payment Form.%s_com.froglogic.squish.awt.TabProxy" % text)

    
def getAmountDue():
    amountDueLabel = waitForObject("{caption?='[$][0-9.,]*' "
            "type='javax.swing.JLabel' visible='true' "
            "window=':Payment Form_PaymentForm'}")
    chars = []
    for char in str(amountDueLabel.getText()):
        if char.isdigit():
            chars.append(char)
    return cast("".join(chars), int)


def checkPaymentRange(minimum, maximum):
    paymentSpinner = waitForObject("{type='javax.swing.JSpinner' "
        "visible='true' window=':Payment Form_PaymentForm'}")
    model = paymentSpinner.getModel()
    test.verify(model.minimum.intValue() == minimum)
    test.verify(model.maximum.intValue() == maximum)

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">
function clickTabbedPane(text)
{
    var tabbedPaneName = ":Payment Form." + text + 
        "_com.froglogic.squish.awt.TabProxy";
    waitForObject(tabbedPaneName);
    clickTab(tabbedPaneName);
}

    
function getAmountDue()
{
    var amountDueLabel = waitForObject("{caption?='[$][0-9.,]*' " +
            "type='javax.swing.JLabel' visible='true' " +
            "window=':Payment Form_PaymentForm'}")
    return 0 + amountDueLabel.text.replace(/\D/g, "");
}


function checkPaymentRange(minimum, maximum)
{
    var paymentSpinner = waitForObject("{type='javax.swing.JSpinner' " +
	    "visible='true' window=':Payment Form_PaymentForm'}");
    var model = paymentSpinner.getModel();
    test.verify(model.minimum.intValue() == minimum);
    test.verify(model.maximum.intValue() == maximum);
}

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">
sub clickTabbedPane
{
    my $text = shift(@_);
    my $name = ":Payment Form.${text}_com.froglogic." .
     "squish.awt.TabProxy";
    waitForObject($name);
    clickTab($name);
}

    
sub getAmountDue
{
    my $amountDueLabel = waitForObject("{caption?='[\$][0-9.,]*' " .
            "type='javax.swing.JLabel' visible='true' " .
            "window=':Payment Form_PaymentForm'}");
    my $amount_due = $amountDueLabel-&gt;text;
    $amount_due =~ s/\D//g; # remove non-digits
    return $amount_due;
}


sub checkPaymentRange
{
    my ($minimum, $maximum) = @_;
    my $paymentSpinner = waitForObject("{type='javax.swing.JSpinner' " .
        "visible='true' window=':Payment Form_PaymentForm'}");
    my $model = $paymentSpinner-&gt;getModel();
    test::verify($model-&gt;minimum-&gt;intValue() == $minimum);
    test::verify($model-&gt;maximum-&gt;intValue() == $maximum);
}

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">
# encoding: UTF-8
require 'squish'
include Squish

def clickTabbedPane(text)
    waitForObject(":Payment Form.#{text}_com.froglogic.squish.awt.TabProxy")
    clickTab(":Payment Form.#{text}_com.froglogic.squish.awt.TabProxy")
end

    
def getAmountDue
    amountDueLabel = waitForObject("{caption?='[$][0-9.,]*' " +
            "type='javax.swing.JLabel' visible='true' " +
            "window=':Payment Form_PaymentForm'}")
    String(amountDueLabel.text).gsub(/\D/, "").to_f
end

def checkPaymentRange(minimum, maximum)
    paymentSpinner = waitForObject("{type='javax.swing.JSpinner' " +
        "visible='true' window=':Payment Form_PaymentForm'}")
    model = paymentSpinner.getModel()
    Test.verify(model.minimum.intValue() == minimum)
    Test.verify(model.maximum.intValue() == maximum)
end

def min(a, b)
    a &lt; b ? a : b
end

def max(a, b)
    a &lt; b ? b : a
end

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">
proc clickTabbedPane {text} {
    waitForObject ":Payment Form.${text}_com.froglogic.squish.awt.TabProxy"
    invoke clickTab ":Payment Form.${text}_com.froglogic.squish.awt.TabProxy"
}


proc getAmountDue {} {
    set amountDueLabel [waitForObject \
        {{caption?='[$][0-9.,]*' type='javax.swing.JLabel' \
            visible='true' window=':Payment Form_PaymentForm'}}]
    set amountText [toString [property get $amountDueLabel text]]
    regsub -all {\D} $amountText "" amountText
    return [expr $amountText]
}


proc checkPaymentRange {minimum maximum} {
    set paymentSpinner [waitForObject \
        {{type='javax.swing.JSpinner' visible='true' \
            window=':Payment Form_PaymentForm'}}]
    set model [invoke $paymentSpinner getModel]
    set minimumAllowed [invoke [property get $model minimum] intValue]
    set maximumAllowed [invoke [property get $model maximum] intValue]
    test compare $minimumAllowed $minimum
    test compare $maximumAllowed $maximum
}

</pre></div></div></div><br class="example-break"></br><p>
Now we can write our tests for "check" and "card" modes and put more of
our effort into testing the business rules and less into some of the
basic chores. We've broken the code for "check" mode into a
<code class="code">main</code> function—this is special to <span class="emphasis"><em>Squish</em></span> and the
only function <span class="emphasis"><em>Squish</em></span> will call—and some test-specific supporting
functions, which combined with the shared functions shown above, make
the code more manageable. Although the <code class="code">main</code> function comes
at the end of the <code class="filename">test.py</code> (or
<code class="filename">test.js</code> and so on) file, we will show it first, and
then show the test-specific supporting functions afterwards.
</p><div class="example"><a id="idp45489824"></a><p class="title"><b>Example 5.19. The tst_check_mode Test Script's main function</b></p><div class="example-contents"><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

def main():
    startApplication('"' + os.environ["SQUISH_PREFIX"] + '/examples/java/paymentform/PaymentFormSwing.jar"')
    # Import functionality needed by more than one test script
    source(findFile("scripts", "common.py"))

    # Start with the correct tab
    clickTabbedPane("Check")

    # Business rule #1: the minimum payment is $10 and the maximum is
    # $250 or the amount due whichever is smaller
    amount_due = getAmountDue()
    checkPaymentRange(10, min(250, amount_due))
    
    # Business rule #2: the check date must be no earlier than 30 days 
    # ago and no later than tomorrow
    checkDateRange(-30, 1)
    
    # Business rule #3: the Pay button is disabled (since the form's data
    # isn't yet valid), so we use findObject() without waiting
    payButtonName = ":Payment Form.Pay_javax.swing.JButton"
    payButton = findObject(payButtonName)
    test.verify(not payButton.enabled)
    
    # Business rule #4: the check must be signed (and if it isn't we
    # will check the check box ready to test the next rule)
    ensureSignedCheckBoxIsChecked()
    
    # Business rule #5: the Pay button should be enabled since all the 
    # previous tests pass, the check is signed and now we have filled in
    # the account details
    populateCheckFields()
    payButton = waitForObject(payButtonName)
    test.verify(payButton.enabled)
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

function main()
{
    startApplication('"' + OS.getenv("SQUISH_PREFIX") + '/examples/java/paymentform/PaymentFormSwing.jar"');
    // Import functionality needed by more than one test script
    source(findFile("scripts", "common.js"));

    // Start with the correct tab
    clickTabbedPane("Check");

    // Business rule #1: the minimum payment is $10 and the maximum is
    // $250 or the amount due whichever is smaller
    var amount_due = getAmountDue();
    checkPaymentRange(10, Math.min(250, amount_due));
    
    // Business rule #2: the check date must be no earlier than 30 days 
    // ago and no later than tomorrow
    checkDateRange(-30, 1);
    
    // Business rule #3: the Pay button is disabled (since the form's data
    // isn't yet valid), so we use findObject() without waiting
    var payButtonName = ":Payment Form.Pay_javax.swing.JButton";
    var payButton = findObject(payButtonName);
    test.verify(!payButton.enabled);
    
    // Business rule #4: the check must be signed (and if it isn't we
    // will check the check box ready to test the next rule)
    ensureSignedCheckBoxIsChecked();
    
    // Business rule #5: the Pay button should be enabled since all the 
    // previous tests pass, the check is signed and now we have filled in
    // the account details
    populateCheckFields();
    var payButton = waitForObject(payButtonName);
    test.verify(payButton.enabled);
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

sub main
{
    startApplication("\"$ENV{'SQUISH_PREFIX'}/examples/java/paymentform/PaymentFormSwing.jar\"");
    # Import functionality needed by more than one test script
    source(findFile("scripts", "common.pl"));

    # Start with the correct tab
    clickTabbedPane("Check");

    # Business rule #1: the minimum payment is $10 and the maximum is
    # $250 or the amount due whichever is smaller
    my $amount_due = getAmountDue();
    checkPaymentRange(10, $amount_due &lt; 250 ? $amount_due : 250);
    
    # Business rule #2: the check date must be no earlier than 30 days 
    # ago and no later than tomorrow
    checkDateRange(-30, 1);
    
    # Business rule #3: the Pay button is disabled (since the form's data
    # isn't yet valid), so we use findObject() without waiting
    my $payButtonName = ":Payment Form.Pay_javax.swing.JButton";
    my $payButton = findObject($payButtonName);
    test::verify(!$payButton-&gt;enabled);
    
    # Business rule #4: the check must be signed (and if it isn't we
    # will check the check box ready to test the next rule)
    ensureSignedCheckBoxIsChecked;
    
    # Business rule #5: the Pay button should be enabled since all the 
    # previous tests pass, the check is signed and now we have filled in
    # the account details
    populateCheckFields;
    $payButton = findObject($payButtonName);
    test::verify($payButton-&gt;enabled);
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

def main
    startApplication("\"#{ENV['SQUISH_PREFIX']}/examples/java/paymentform/PaymentFormSwing.jar\"")
    # Import functionality needed by more than one test script
    require findFile("scripts", "common.rb")

    # Start with the correct tab
    clickTabbedPane("Check")

    # Business rule #1: the minimum payment is $10 and the maximum is
    # $250 or the amount due whichever is smaller
    amount_due = getAmountDue
    checkPaymentRange(10, min(250, amount_due))

    # Business rule #2: the check date must be no earlier than 30 days
    # ago and no later than tomorrow
    checkDateRange(-30, 1)

    # Business rule #3: the Pay button is disabled (since the form's data
    # isn't yet valid), so we use findObject() without waiting
    payButtonName = ":Payment Form.Pay_javax.swing.JButton"
    payButton = findObject(payButtonName)
    Test.verify(!payButton.enabled)

    # Business rule #4: the check must be signed (and if it isn't we
    # will check the check box ready to test the next rule)
    ensureSignedCheckBoxIsChecked

    # Business rule #5: the Pay button should be enabled since all the
    # previous tests pass, the check is signed and now we have filled in
    # the account details
    populateCheckFields
    payButton = waitForObject(payButtonName)
    Test.verify(payButton.enabled)
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

proc main {} {
    startApplication "\"$::env(SQUISH_PREFIX)/examples/java/paymentform/PaymentFormSwing.jar\""
    # Import functionality needed by more than one test script
    source [findFile "scripts" "common.tcl"]

    # Start with the correct tab
    clickTabbedPane "Check"

    # Business rule #1: the minimum payment is $10 and the maximum is
    # $250 or the amount due whichever is smaller
    set amount_due [getAmountDue]
    set maximum [expr 250 &gt; $amount_due ? $amount_due : 250]
    checkPaymentRange 10 $maximum
    
    # Business rule #2: the check date must be no earlier than 30 days 
    # ago and no later than tomorrow
    checkDateRange -30 1
    
    # Business rule #3: the Pay button is disabled (since the form's data
    # isn't yet valid), so we use findObject() without waiting
    set payButtonName ":Payment Form.Pay_javax.swing.JButton"
    set payButton [findObject $payButtonName]
    test verify [expr ![property get $payButton enabled]]
    
    # Business rule #4: the check must be signed (and if it isn't we
    # will check the check box ready to test the next rule)
    ensureSignedCheckBoxIsChecked
    
    # Business rule #5: the Pay button should be enabled since all the 
    # previous tests pass, the check is signed and now we have filled in
    # the account details
    populateCheckFields
    set payButton [waitForObject $payButtonName]
    test verify [property get $payButton enabled]
}
</pre></div></div></div><br class="example-break"></br><p>
The <a class="xref" href="rgs-squish.html#source-function"><code class="function">source</code></a> function (or <code class="code">require</code>
for Ruby), is used to read in a
script and execute it. Normally such a script is used purely to define
things—for example, functions—and these then become
available to the test script.
</p><p>
The first business rule is very similar to before, but the code is much
shorter thanks to the shared <code class="code">checkPaymentRange</code> function.
The test for the second rule is even simpler since we have put all the
code in a separate <code class="code">checkDateRange</code> function that we will
look at in a moment.
</p><p>
The third rule checks that the <span class="guibutton">Pay</span>
button is disabled since at this stage the form's data isn't valid. (For
example, the check hasn't been signed and there are no account details
filled in.) The fourth rule is used to confirm that the check is
signed—something that we explicitly make happen if it is necessary
in the test-specific <code class="code">ensureSignedCheckBoxIsChecked</code>
function.
</p><p>
For the fifth rule we populate the account line edits with fake
data. At the end all the widgets have valid values so the
<span class="guibutton">Pay</span> button should be enabled, and the last line
tests that it is.
</p><p>
Here are the supporting functions, each followed by a very brief
explanation.
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

def checkDateRange(daysBeforeToday, daysAfterToday):
    calendar = java_util_Calendar.getInstance()
    calendar.add(java_util_Calendar.DAY_OF_MONTH, daysBeforeToday)
    earliest = calendar.getTime()
    calendar.setTime(java_util_Date())
    calendar.add(java_util_Calendar.DAY_OF_MONTH, daysAfterToday)
    latest = calendar.getTime()
    checkDateSpinner = waitForObject("{container=':Payment Form."
        "Check_com.froglogic.squish.awt.TabProxy' "
        "type='javax.swing.JSpinner' visible='true'}")
    model = checkDateSpinner.getModel()
    AnyClass = calendar.getClass()
    SimpleDateFormatClass = AnyClass.forName("java.text.SimpleDateFormat")
    formatter = SimpleDateFormatClass.newInstance()
    formatter.applyPattern("yyyy-MM-dd")
    test.verify(formatter.format(model.getStart()) ==
                formatter.format(earliest))
    test.verify(formatter.format(model.getEnd()) ==
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

function checkDateRange(daysBeforeToday, daysAfterToday)
{
    var checkDateSpinner = waitForObject("{container=':Payment Form." +
	    "Check_com.froglogic.squish.awt.TabProxy' " +
            "type='javax.swing.JSpinner' visible='true'}");
    var model = checkDateSpinner.getModel();
    var calendar = java_util_Calendar.getInstance();
    calendar.add(java_util_Calendar.DAY_OF_MONTH, daysBeforeToday);
    var earliest = calendar.getTime();
    calendar.setTime(new java_util_Date());
    calendar.add(java_util_Calendar.DAY_OF_MONTH, daysAfterToday);
    var latest = calendar.getTime();
    var AnyClass = calendar.getClass();
    var SimpleDateFormatClass = AnyClass.forName(
        "java.text.SimpleDateFormat");
    var formatter = SimpleDateFormatClass.newInstance();
    formatter.applyPattern("yyyy-MM-dd");
    test.verify(formatter.format(model.getStart()) ==
		formatter.format(earliest));
    test.verify(formatter.format(model.getEnd()) ==
		formatter.format(latest));
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

sub checkDateRange
{
    my ($daysBeforeToday, $daysAfterToday) = @_;
    my $calendar = java_util_Calendar::getInstance();
    $calendar-&gt;add(java_util_Calendar-&gt;DAY_OF_MONTH, $daysBeforeToday);
    my $earliest = $calendar-&gt;getTime();
    $calendar-&gt;setTime(java_util_Date-&gt;new());
    $calendar-&gt;add(java_util_Calendar-&gt;DAY_OF_MONTH, $daysAfterToday);
    my $latest = $calendar-&gt;getTime();
    my $checkDateSpinner = waitForObject(
            "{container=':Payment Form.Check_com.froglogic." .
            "squish.awt.TabProxy' " .
            "type='javax.swing.JSpinner' visible='true'}");
    my $model = $checkDateSpinner-&gt;getModel();
    my $simpleDateFormatClass = java_lang_Class::forName("java.text.SimpleDateFormat");
    my $formatter = $simpleDateFormatClass-&gt;newInstance();
    $formatter-&gt;applyPattern("yyyy-MM-dd");
    test::verify($formatter-&gt;format($model-&gt;getStart()) eq
                 $formatter-&gt;format($earliest));
    test::verify($formatter-&gt;format($model-&gt;getEnd()) eq
                 $formatter-&gt;format($latest));
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

def checkDateRange(daysBeforeToday, daysAfterToday)
    calendar = LC::Java_util_Calendar.getInstance()
    calendar.add(LC::Java_util_Calendar.DAY_OF_MONTH, daysBeforeToday)
    earliest = calendar.getTime()
    calendar.setTime(LC::Java_util_Date.new)
    calendar.add(LC::Java_util_Calendar.DAY_OF_MONTH, daysAfterToday)
    latest = calendar.getTime()
    checkDateSpinner = waitForObject("{container=':Payment Form." +
    "Check_com.froglogic.squish.awt.TabProxy' " +
    "type='javax.swing.JSpinner' visible='true'}")
    model = checkDateSpinner.getModel()
    simpleDateFormatClass = LC::Java_lang_Class.forName("java.text.SimpleDateFormat")
    formatter = simpleDateFormatClass.newInstance()
    formatter.applyPattern("yyyy-MM-dd")
    Test.verify(formatter.format(model.getStart()) ==
    formatter.format(earliest))
    Test.verify(formatter.format(model.getEnd()) ==
    formatter.format(latest))
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

proc checkDateRange {daysBeforeToday daysAfterToday} {
    set checkDateSpinner [waitForObject \
        {{container=':Payment Form.Check_com.froglogic.squish.awt.TabProxy' \
            type='javax.swing.JSpinner' visible='true'}}]
    set AnyClass [invoke $checkDateSpinner getClass]
    set SimpleDateFormatClass [invoke $AnyClass forName \
        "java.text.SimpleDateFormat"]
    set formatter [invoke $SimpleDateFormatClass newInstance]
    invoke $formatter applyPattern "yyyy-MM-dd"
    set model [invoke $checkDateSpinner getModel]
    set minimumAllowed [invoke $formatter format [invoke $model getStart]]
    set maximumAllowed [invoke $formatter format [invoke $model getEnd]]
    set calendar [invoke java_util_Calendar getInstance]
    invoke $calendar add [property get java_util_Calendar DAY_OF_MONTH] \
        $daysBeforeToday
    set minimumDate [invoke $formatter format [invoke $calendar getTime]]
    invoke $calendar setTime [construct java_util_Date]
    invoke $calendar add [property get java_util_Calendar DAY_OF_MONTH] \
        $daysAfterToday
    set maximumDate [invoke $formatter format [invoke $calendar getTime]]
    test compare $minimumAllowed $minimumDate
    test compare $maximumAllowed $maximumDate
}
</pre></div><p>
In the <code class="code">checkDateRange</code> function we test the properties of
a <code class="code">JSpinner</code>'s <code class="code">SpinnerDateModel</code>. Notice that we
compare the dates as strings using a uniform format.
</p><p>
While <span class="emphasis"><em>Squish</em></span> provides access to most of the <span class="trademark">Java</span>™ API automatically,
in some cases we need to access classes that are not available by
default. In this function we need a couple of classes that are not
available, <code class="code">java.util.Calendar</code> and
<code class="code">java.text.SimpleDateFormat</code>. This isn't a problem in
practice since we can always register additional classes (whether
standard or our own custom classes) with the <span class="application">squishserver</span>—see
<a class="xref" href="rg-autsettings.html#rgas-javawrapping" title="7.3.8.2. Wrapping custom Java™ classes">Wrapping custom <span class="trademark">Java</span>™ classes (Section 7.3.8.2)</a> for details, including a way to
access such classes without even having to register them or use a
<code class="filename">.ini</code> file. In this case
we added several extra classes in <code class="filename">java.ini</code> which
has just two lines:
</p><pre class="programlisting">
[general]
AutClasses="java.util.Calendar","java.util.Date",\
"java.text.DateFormat","java.text.SimpleDateFormat"
</pre><p>
In fact, we only used this approach for the Perl version; for the others
we used Java's introspection facilities to create instances of the
<code class="code">java.text.DateFormat</code> and
<code class="code">java.text.SimpleDateFormat</code> classes.
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

def ensureSignedCheckBoxIsChecked():
    checkSignedCheckBox = waitForObject(
            ":Check.Check Signed_javax.swing.JCheckBox")
    if not checkSignedCheckBox.isSelected():
        clickButton(checkSignedCheckBox)
    test.verify(checkSignedCheckBox.isSelected())
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

function ensureSignedCheckBoxIsChecked()
{
    var checkSignedCheckBox = waitForObject(
            ":Check.Check Signed_javax.swing.JCheckBox");
    if (!checkSignedCheckBox.isSelected()) {
        clickButton(checkSignedCheckBox);
	}
    test.verify(checkSignedCheckBox.isSelected());
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

sub ensureSignedCheckBoxIsChecked
{
    my $checkSignedCheckBox = waitForObject(
            ":Check.Check Signed_javax.swing.JCheckBox");
    if (!$checkSignedCheckBox-&gt;isSelected()) {
        clickButton($checkSignedCheckBox);
    }
    test::verify($checkSignedCheckBox-&gt;isSelected());
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

def ensureSignedCheckBoxIsChecked
    checkSignedCheckBox = waitForObject(
    ":Check.Check Signed_javax.swing.JCheckBox")
    if !checkSignedCheckBox.isSelected()
        clickButton(checkSignedCheckBox)
    end
    Test.verify(checkSignedCheckBox.isSelected())
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

proc ensureSignedCheckBoxIsChecked {} {
    set checkSignedCheckBox [waitForObject \
        ":Check.Check Signed_javax.swing.JCheckBox"]
    if {![invoke $checkSignedCheckBox isSelected]} {
        invoke clickButton $checkSignedCheckBox
    }
    test verify [invoke $checkSignedCheckBox isSelected]
}
</pre></div><p>
The <code class="code">ensureSignedCheckBoxIsChecked</code> function checks the
state of a <code class="code">JCheckBox</code> and if it is not checked, checks it by
clicking it. The function then verifies that the checkbox is indeed
checked.
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

def populateCheckFields():
    bankNameLineEdit = waitForObject(
        ":Check.Bank Name:_javax.swing.JTextField")
    type(bankNameLineEdit, "A Bank")
    bankNumberLineEdit = waitForObject(
        ":Check.Bank Number:_javax.swing.JTextField")
    type(bankNumberLineEdit, "88-91-33X")
    accountNameLineEdit = waitForObject(
        ":Check.Account Name:_javax.swing.JTextField")
    type(accountNameLineEdit, "An Account")
    accountNumberLineEdit = waitForObject(
        ":Check.Account Number:_javax.swing.JTextField")
    type(accountNumberLineEdit, "932745395")
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

function populateCheckFields()
{
    var bankNameLineEdit = waitForObject(
        ":Check.Bank Name:_javax.swing.JTextField");
    type(bankNameLineEdit, "A Bank");
    var bankNumberLineEdit = waitForObject(
        ":Check.Bank Number:_javax.swing.JTextField");
    type(bankNumberLineEdit, "88-91-33X");
    var accountNameLineEdit = waitForObject(
        ":Check.Account Name:_javax.swing.JTextField");
    type(accountNameLineEdit, "An Account");
    var accountNumberLineEdit = waitForObject(
        ":Check.Account Number:_javax.swing.JTextField");
    type(accountNumberLineEdit, "932745395");
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

sub populateCheckFields
{
    my $bankNameLineEdit = waitForObject(
        ":Check.Bank Name:_javax.swing.JTextField");
    type($bankNameLineEdit, "A Bank");
    my $bankNumberLineEdit = waitForObject(
        ":Check.Bank Number:_javax.swing.JTextField");
    type($bankNumberLineEdit, "88-91-33X");
    my $accountNameLineEdit = waitForObject(
        ":Check.Account Name:_javax.swing.JTextField");
    type($accountNameLineEdit, "An Account");
    my $accountNumberLineEdit = waitForObject(
        ":Check.Account Number:_javax.swing.JTextField");
    type($accountNumberLineEdit, "932745395");
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

def populateCheckFields
    bankNameLineEdit = waitForObject(
    ":Check.Bank Name:_javax.swing.JTextField")
    type(bankNameLineEdit, "A Bank")
    bankNumberLineEdit = waitForObject(
    ":Check.Bank Number:_javax.swing.JTextField")
    type(bankNumberLineEdit, "88-91-33X")
    accountNameLineEdit = waitForObject(
    ":Check.Account Name:_javax.swing.JTextField")
    type(accountNameLineEdit, "An Account")
    accountNumberLineEdit = waitForObject(
    ":Check.Account Number:_javax.swing.JTextField")
    type(accountNumberLineEdit, "932745395")
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

proc populateCheckFields {} {
    set bankNameLineEdit [waitForObject \
        ":Check.Bank Name:_javax.swing.JTextField"]
    invoke type $bankNameLineEdit "A Bank"
    set bankNumberLineEdit [waitForObject \
        ":Check.Bank Number:_javax.swing.JTextField"]
    invoke type $bankNumberLineEdit "88-91-33X"
    set accountNameLineEdit [waitForObject \
        ":Check.Account Name:_javax.swing.JTextField"]
    invoke type $accountNameLineEdit "An Account"
    set accountNumberLineEdit [waitForObject \
        ":Check.Account Number:_javax.swing.JTextField"]
    invoke type $accountNumberLineEdit "932745395"
}
</pre></div><p>
The <code class="code">populateCheckFields</code> function fills in some
<code class="code">JTextField</code>s—this, along with setting the date and
checking the checkbox earlier—should ensure that the
<span class="guibutton">Pay</span> button is enabled, something that is checked
in the <code class="code">main</code> function after the
<code class="code">populateCheckFields</code> function is called. </p><p>
Notice that we used the <a class="xref" href="rgs-javaconvenience.html#java-type-function"><code class="function">type</code></a> function to
simulate the user entering text. It is almost always better to simulate
user interaction than to set widget properties directly—after all,
it is the application's behavior as experienced by the user that we
normally need to test.
</p><p>
We are now ready to look at the last test of the form's business
logic—the test of "card" mode. The code is a bit longer because
there are a few more things to test given the test specification, but
everything works on the same principles as the tests we have already
seen.
</p><div class="example"><a id="idp45545944"></a><p class="title"><b>Example 5.20. The tst_card_mode Test Script's main function</b></p><div class="example-contents"><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

def main():
    startApplication('"' + os.environ["SQUISH_PREFIX"] + '/examples/java/paymentform/PaymentFormSwing.jar"')
    source(findFile("scripts", "common.py"))

    # Start with the correct tab
    clickTabbedPane("Credit Card")
    
    # Business rule #1: the minimum payment is $10 or 5% of the amount due
    # whichever is larger and the maximum is $5000 or the amount due 
    # whichever is smaller
    amount_due = getAmountDue()
    checkPaymentRange(max(10, amount_due / 20.0), min(5000, amount_due))
    
    # Business rule #2: for non-Visa cards the issue date must be no
    # earlier than 3 years ago
    # Business rule #3: the expiry date must be at least a month later
    # than today---we make sure that this is the case for the later tests
    checkCardDateEdits()

    # Business rule #4: the Pay button is disabled (since the form's data
    # isn't yet valid), so we use findObject() without waiting
    payButtonName = ":Payment Form.Pay_javax.swing.JButton"
    payButton = findObject(payButtonName)
    test.verify(not payButton.enabled)
    
    # Business rule #5: the Pay button should be enabled since all the 
    # previous tests pass, and now we have filled in the account details
    populateCardFields()
    payButton = findObject(payButtonName)
    test.verify(payButton.enabled)
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

function main()
{
    startApplication('"' + OS.getenv("SQUISH_PREFIX") + '/examples/java/paymentform/PaymentFormSwing.jar"');
    source(findFile("scripts", "common.js"));

    // Start with the correct tab
    clickTabbedPane("Credit Card");
    
    // Business rule #1: the minimum payment is $10 or 5% of the amount
    // due whichever is larger and the maximum is $5000 or the amount
    // due whichever is smaller
    var amount_due = getAmountDue();
    checkPaymentRange(Math.max(10, amount_due / 20.0),
                      Math.min(5000, amount_due));

    // Business rule #2: for non-Visa cards the issue date must be no
    // earlier than 3 years ago
    // Business rule #3: the expiry date must be at least a month later
    // than today---we make sure that this is the case for the later tests
    checkCardDateEdits();

    // Business rule #4: the Pay button is disabled (since the form's data
    // isn't yet valid), so we use findObject() without waiting
    var payButtonName = ":Payment Form.Pay_javax.swing.JButton";
    var payButton = findObject(payButtonName);
    test.verify(!payButton.enabled);
    
    // Business rule #5: the Pay button should be enabled since all the 
    // previous tests pass, and now we have filled in the account details
    populateCardFields();
    var payButton = waitForObject(payButtonName);
    test.verify(payButton.enabled);
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

sub main
{
    startApplication("\"$ENV{'SQUISH_PREFIX'}/examples/java/paymentform/PaymentFormSwing.jar\"");
    source(findFile("scripts", "common.pl"));

    # Start with the correct tab
    clickTabbedPane("Credit Card");
    
    # Business rule #1: the minimum payment is $10 or 5% of the amount
    # due whichever is larger and the maximum is $5000 or the amount 
    # due whichever is smaller
    my $amount_due = getAmountDue();
    my $minimum = $amount_due / 20.0 &gt; 10 ? $amount_due / 20.0 : 10;
    my $maximum = $amount_due &lt; 5000 ? $amount_due : 5000;
    checkPaymentRange($minimum, $maximum);

    # Business rule #2: for non-Visa cards the issue date must be no
    # earlier than 3 years ago
    # Business rule #3: the expiry date must be at least a month later
    # than today---we make sure that this is the case for the later tests
    checkCardDateEdits;

    # Business rule #4: the Pay button is disabled (since the form's data
    # isn't yet valid), so we use findObject() without waiting
    my $payButtonName = ":Payment Form.Pay_javax.swing.JButton";
    my $payButton = findObject($payButtonName);
    test::verify(!$payButton-&gt;enabled);
    
    # Business rule #5: the Pay button should be enabled since all the 
    # previous tests pass, and now we have filled in the account details
    populateCardFields;
    $payButton = findObject($payButtonName);
    test::verify($payButton-&gt;enabled);
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

def main
    startApplication("\"#{ENV['SQUISH_PREFIX']}/examples/java/paymentform/PaymentFormSwing.jar\"")
    require findFile("scripts", "common.rb")

    # Start with the correct tab
    clickTabbedPane("Credit Card")

    # Business rule #1: the minimum payment is $10 or 5% of the amount due
    # whichever is larger and the maximum is $5000 or the amount due
    # whichever is smaller
    amount_due = getAmountDue
    checkPaymentRange(max(10, amount_due / 20.0), min(5000, amount_due))

    # Business rule #2: for non-Visa cards the issue date must be no
    # earlier than 3 years ago
    # Business rule #3: the expiry date must be at least a month later
    # than today---we make sure that this is the case for the later tests
    checkCardDateEdits

    # Business rule #4: the Pay button is disabled (since the form's data
    # isn't yet valid), so we use findObject() without waiting
    payButtonName = ":Payment Form.Pay_javax.swing.JButton"
    payButton = findObject(payButtonName)
    Test.verify(!payButton.enabled)

    # Business rule #5: the Pay button should be enabled since all the
    # previous tests pass, and now we have filled in the account details
    populateCardFields
    payButton = findObject(payButtonName)
    Test.verify(payButton.enabled)
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

proc main {} {
    startApplication "\"$::env(SQUISH_PREFIX)/examples/java/paymentform/PaymentFormSwing.jar\""
    # Import functionality needed by more than one test script
    source [findFile "scripts" "common.tcl"]

    # Start with the correct tab
    clickTabbedPane "Credit Card"
    
    # Business rule #1: the minimum payment is $10 or 5% of the amount due
    # whichever is larger and the maximum is $5000 or the amount due 
    # whichever is smaller
    set amount_due [getAmountDue]
    set five_percent [expr $amount_due / 20]
    set minimum [expr 10 &gt; $five_percent ? 10 : $five_percent]
    set maximum [expr 5000 &gt; $amount_due ? $amount_due : 5000]
    checkPaymentRange $minimum $maximum

    # Business rule #2: for non-Visa cards the issue date must be no
    # earlier than 3 years ago
    # Business rule #3: the expiry date must be at least a month later
    # than today---we make sure that this is the case for the later tests
    checkCardDateEdits
    
    # Business rule #4: the Pay button is disabled (since the form's data
    # isn't yet valid), so we use findObject() without waiting
    set payButtonName ":Payment Form.Pay_javax.swing.JButton"
    set payButton [findObject $payButtonName]
    test verify [expr ![property get $payButton enabled]]
    
    # Business rule #5: the Pay button should be enabled since all the 
    # previous tests pass, and now we have filled in the account details
    populateCardFields
    set payButton [waitForObject $payButtonName]
    test verify [property get $payButton enabled]
}
</pre></div></div></div><br class="example-break"></br><p>
Just as we did for the "check" mode's <code class="code">main</code> function, we
have encapsulated almost every test in a separate function. This makes
the <code class="code">main</code> function simpler and clearer and makes it easier
to develop and test tests individually.
</p><p>
Here are the supporting functions, each with some brief discussion of
their use.
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

def checkCardDateEdits():
    # (1) set the card type to any non-Visa card
    cardTypeComboBox = waitForObject(
        ":Credit Card.Card Type:_javax.swing.JComboBox")
    for index in range(cardTypeComboBox.getItemCount()):
        if cardTypeComboBox.getItemAt(index).toString() != "Visa":
            cardTypeComboBox.setSelectedIndex(index)
            break
    # (2) find the two date spinners
    creditCardTabPane = waitForObject(":Payment Form.Credit "
        "Card_com.froglogic.squish.awt.TabProxy").component
    spinners = []
    for i in range(creditCardTabPane.getComponentCount()):
        component = creditCardTabPane.getComponent(i)
        if (component.getClass().toString() ==
            "class javax.swing.JSpinner"):
            spinners.append(component)
    test.verify(len(spinners) == 2)
    # (3) check the issue date spinner's minimum date
    calendar = java_util_Calendar.getInstance()
    calendar.add(java_util_Calendar.YEAR, -3)
    date = calendar.getTime()
    issueDateSpinner = spinners[0]
    model = issueDateSpinner.getModel()
    java_lang_Class.forName("java.text.SimpleDateFormat")
    formatter = java_text_SimpleDateFormat()
    formatter.applyPattern("yyyy-MM-dd")
    test.verify(formatter.format(model.getStart()) ==
                formatter.format(date))
    # (4) set the expiry date more than a month later
    # than now for later tests
    calendar.setTime(java_util_Date())
    calendar.add(java_util_Calendar.DAY_OF_MONTH, 35)
    expiryDateSpinner = spinners[1]
    expiryDateSpinner.setValue(calendar.getTime())
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

function checkCardDateEdits()
{
    // (1) set the card type to any non-Visa card
    var cardTypeComboBox = waitForObject(
        ":Credit Card.Card Type:_javax.swing.JComboBox");
    for (var index = 0; index &lt; cardTypeComboBox.getItemCount(); ++index) {
        if (cardTypeComboBox.getItemAt(index).toString() != "Visa") {
            cardTypeComboBox.setSelectedIndex(index);
            break;
	}
    }
    // (2) find the two date spinners
    var creditCardTabPane = waitForObject(":Payment Form.Credit Card_com." +
	    "froglogic.squish.awt.TabProxy").component;
    var spinners = [];
    for (var i = 0; i &lt; creditCardTabPane.getComponentCount(); ++i) {
        var component = creditCardTabPane.getComponent(i);
        if (component.getClass().toString() ==
	    "class javax.swing.JSpinner") {
            spinners.push(component);
	}
    }
    test.verify(spinners.length == 2);
    // (3) check the issue date spinner's minimum date
    var calendar = java_util_Calendar.getInstance();
    calendar.add(java_util_Calendar.YEAR, -3);
    var threeYearsAgo = calendar.getTime();
    var issueDateSpinner = spinners[0];
    var model = issueDateSpinner.getModel();
    java_lang_Class.forName("java.text.SimpleDateFormat");
    var formatter = new java_text_SimpleDateFormat();
    formatter.applyPattern("yyyy-MM-dd");
    test.verify(formatter.format(model.getStart()) == 
                formatter.format(threeYearsAgo));
    // (4) set the expiry date more than a month later 
    // than now for later tests
    calendar.setTime(new java_util_Date());
    calendar.add(java_util_Calendar.DAY_OF_MONTH, 35);
    var expiryDateSpinner = spinners[1];
    expiryDateSpinner.setValue(calendar.getTime());
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

sub checkCardDateEdits
{
    # (1) set the card type to any non-Visa card
    my $cardTypeComboBox = waitForObject(
        ":Credit Card.Card Type:_javax.swing.JComboBox");
    for (my $index = 0; $index &lt; $cardTypeComboBox-&gt;getItemCount();
        ++$index) {
        if ($cardTypeComboBox-&gt;getItemAt($index)-&gt;toString() != "Visa") {
            $cardTypeComboBox-&gt;setSelectedIndex($index);
            last;
	}
    }
    # (2) find the two date spinners
    my $creditCardTabPane = waitForObject(":Payment Form.Credit " .
        "Card_com.froglogic.squish.awt.TabProxy")-&gt;component;
    my @spinners = ();
    for (my $i = 0; $i &lt; $creditCardTabPane-&gt;getComponentCount(); ++$i) {
        my $component = $creditCardTabPane-&gt;getComponent($i);
        if ($component-&gt;getClass()-&gt;toString() eq
            "class javax.swing.JSpinner") {
            push @spinners, $component;
	}
    }
    test::verify(@spinners == 2);
    # (3) check the issue date spinner's minimum date
    my $calendar = java_util_Calendar::getInstance();
    $calendar-&gt;add(java_util_Calendar-&gt;YEAR, -3);
    my $date = $calendar-&gt;getTime();
    my $issueDateSpinner = $spinners[0];
    my $model = $issueDateSpinner-&gt;getModel();
    java_lang_Class::forName("java.text.SimpleDateFormat");
    my $formatter = new java_text_SimpleDateFormat();
    $formatter-&gt;applyPattern("yyyy-MM-dd");
    test::verify($formatter-&gt;format($model-&gt;getStart()) eq
                 $formatter-&gt;format($date));
    # (4) set the expiry date more than a month later than 
    # now for later tests
    $calendar-&gt;setTime(java_util_Date-&gt;new());
    $calendar-&gt;add(java_util_Calendar-&gt;DAY_OF_MONTH, 35);
    my $expiryDateSpinner = $spinners[1];
    $expiryDateSpinner-&gt;setValue($calendar-&gt;getTime());
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

def checkCardDateEdits
    # (1) set the card type to any non-Visa card
    cardTypeComboBox = waitForObject(
    ":Credit Card.Card Type:_javax.swing.JComboBox")
    for index in 0...cardTypeComboBox.getItemCount()
        if cardTypeComboBox.getItemAt(index).toString() != "Visa"
            cardTypeComboBox.setSelectedIndex(index)
            break
        end
    end
    # (2) find the two date spinners
    creditCardTabPane = waitForObject(":Payment Form.Credit " +
    "Card_com.froglogic.squish.awt.TabProxy").component
    spinners = []
    for i in 0...creditCardTabPane.getComponentCount()
        component = creditCardTabPane.getComponent(i)
        if (component.getClass().toString() ==
        "class javax.swing.JSpinner")
            spinners &lt;&lt; component
        end
    end
    Test.verify(spinners.length == 2)
    # (3) check the issue date spinner's minimum date
    calendar = LC::Java_util_Calendar.getInstance()
    calendar.add(LC::Java_util_Calendar.YEAR, -3)
    date = calendar.getTime()
    issueDateSpinner = spinners[0]
    model = issueDateSpinner.getModel()
    LC::Java_lang_Class.forName("java.text.SimpleDateFormat")
    formatter = LC::Java_text_SimpleDateFormat.new
    formatter.applyPattern("yyyy-MM-dd")
    Test.verify(formatter.format(model.getStart()) ==
    formatter.format(date))
    # (4) set the expiry date more than a month later
    # than now for later tests
    calendar.setTime(LC::Java_util_Date.new())
    calendar.add(LC::Java_util_Calendar.DAY_OF_MONTH, 35)
    expiryDateSpinner = spinners[1]
    expiryDateSpinner.setValue(calendar.getTime())
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

proc checkCardDateEdits {} {
    # (1) set the card type to any non-Visa card
    set cardTypeComboBox [waitForObject \
        ":Credit Card.Card Type:_javax.swing.JComboBox"]
    set count [invoke $cardTypeComboBox getItemCount]
    for {set index 0} {$index &lt; $count} {incr index} {
        if {[invoke $cardTypeComboBox getItemAt $index] != "Visa"} {
            invoke $cardTypeComboBox setSelectedIndex $index
            break
	}
    }
    # (2) find the two date spinners
    set creditCardTabPaneProxy [waitForObject \
        ":Payment Form.Credit Card_com.froglogic.squish.awt.TabProxy"]
    set creditCardTabPane [property get $creditCardTabPaneProxy component]
    set spinners {}
    set count [invoke $creditCardTabPane getComponentCount]
    for {set index 0} {$index &lt; $count} {incr index} {
        set component [invoke $creditCardTabPane getComponent $index]
	set classname [invoke [invoke $component getClass] toString]
	if {$classname == "class javax.swing.JSpinner"} {
            lappend spinners $component
	}
    }
    test compare [llength $spinners] 2
    # (3) check the issue date spinner's minimum date
    set calendar [invoke java_util_Calendar getInstance]
    invoke $calendar add [property get java_util_Calendar YEAR] -3
    set issueDateSpinner [lindex $spinners 0]
    set model [invoke $issueDateSpinner getModel]
    invoke java_lang_Class forName "java.text.SimpleDateFormat"
    set formatter [construct java_text_SimpleDateFormat]
    invoke $formatter applyPattern "yyyy-MM-dd"
    set minimumAllowed [invoke $formatter format [invoke $model getStart]]
    set minimumDate [invoke $formatter format [invoke $calendar getTime]]
    test compare $minimumAllowed $minimumDate
    # (4) set the expiry date more than a month later than now for 
    # later tests
    invoke $calendar setTime [construct java_util_Date]
    invoke $calendar add [property get java_util_Calendar DAY_OF_MONTH] 35
    set expiryDateSpinner [lindex $spinners 1]
    invoke $expiryDateSpinner setValue [invoke $calendar getTime]
}
</pre></div><p>
The second and third business rules are handled by the test-specific
<code class="code">checkCardDateEdits</code> function.
For the second business rule we need the card type combobox to be on any
card type except Visa, so we iterate over the combobox's items and set
the current item to be the first non-Visa item we find. Now we must
check that the card's issue date is not allowed to be too long ago.
</p><p>
This form has two <code class="code">JSpinner</code>s, one used for the card's issue
date and the other for the card's expiry date. We can't use names to
distinguish between the spinners so we must obtain references to them by
using introspection. To do this we begin by finding the innermost
component that contains the spinners—in this case the
<code class="code">JPane</code> that is shown by the <code class="code">JTabbedPane</code>'s
current tab. (<span class="emphasis"><em>Squish</em></span> uses "proxy"s for some widgets, in this case a
TabProxy; but we can always access the relevant component using the
<code class="code">component</code> property as we do here.) Once we have the
<code class="code">JPane</code>, we iterate over its components, making a list of
those that are <code class="code">JSpinner</code>s. We then check that there are
exactly two spinners as expected and then we are ready to check
that the minimum issue date has been correctly set to three years ago.
</p><p>
The third business rule says that the expiry date must be at least a
month ahead. We explicitly set the expiry to be 35 days ahead
so that the <span class="guibutton">Pay</span> button will be enabled later on.
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

def populateCardFields():
    cardAccountNameLineEdit = waitForObject(
        ":Credit Card.Account Name:_javax.swing.JTextField")
    type(cardAccountNameLineEdit, "An Account")
    cardAccountNumberLineEdit = waitForObject(
        ":Credit Card.Account Number:_javax.swing.JTextField")
    type(cardAccountNumberLineEdit, "1343 876 326 1323 32")
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

function populateCardFields()
{
    var cardAccountNameLineEdit = waitForObject(
        ":Credit Card.Account Name:_javax.swing.JTextField");
    type(cardAccountNameLineEdit, "An Account");
    var cardAccountNumberLineEdit = waitForObject(
        ":Credit Card.Account Number:_javax.swing.JTextField");
    type(cardAccountNumberLineEdit, "1343 876 326 1323 32");
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

sub populateCardFields
{
    my $cardAccountNameLineEdit = waitForObject(
        ":Credit Card.Account Name:_javax.swing.JTextField");
    type($cardAccountNameLineEdit, "An Account");
    my $cardAccountNumberLineEdit = waitForObject(
        ":Credit Card.Account Number:_javax.swing.JTextField");
    type($cardAccountNumberLineEdit, "1343 876 326 1323 32");
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

def populateCardFields
    cardAccountNameLineEdit = waitForObject(
    ":Credit Card.Account Name:_javax.swing.JTextField")
    type(cardAccountNameLineEdit, "An Account")
    cardAccountNumberLineEdit = waitForObject(
    ":Credit Card.Account Number:_javax.swing.JTextField")
    type(cardAccountNumberLineEdit, "1343 876 326 1323 32")
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

proc populateCardFields {} {
    set cardAccountNameLineEdit [waitForObject \
        ":Credit Card.Account Name:_javax.swing.JTextField"]
    invoke type $cardAccountNameLineEdit "An Account"
    set cardAccountNumberLineEdit [waitForObject \
        ":Credit Card.Account Number:_javax.swing.JTextField"]
    invoke type $cardAccountNumberLineEdit "1343 876 326 1323 32"
}
</pre></div><p>
Initially the <span class="guibutton">Pay</span> button should be
disabled, and we check for this in the <code class="code">main</code> function. For the fifth business
rule, we need some fake data for the card
account name and number, and this is provided by the
<code class="code">populateCardFields</code> function. After this has been called,
and since the dates are now in range, the
<span class="guibutton">Pay</span> button should now be enabled, and again we
check this in the <code class="code">main</code> function.
</p><p>
We have now completed our review of testing business rules using
stateful and single-valued widgets. <span class="trademark">Java</span>™ has many other similar
widgets but all of them are identified and tested using the same
techniques we have used here.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ug-testing-lists-tables-and-trees"></a>5.4.6.1.2. How to Test JList, JTable, and JTree widgets
(Java—AWT/Swing)</h5></div></div></div><p>
In this section we will see how to iterate over every item in <span class="trademark">Java</span>™'s
JList, JTable, and JTree widgets, and how to retrieve information from
each item, such as their text and selected status. The actual data is
held in models, so in each example we begin by retrieving a reference to
the widget's underlying model, and then operate on the model itself.
</p><p>
Although the examples only output each item's text and selected status
to Squish's log, they are very easy to adapt to do more sophisticated
testing, such as comparing actual values against expected values.
</p><p>
All the code shown in this section is taken from the
<code class="filename">examples/java/itemviews</code> example's test suites.
</p><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a id="how-to-test-jlist"></a>5.4.6.1.2.1. How to Test JList</h6></div></div></div><p>
It is very easy to iterate over all the items in a JList and retrieve
their texts and selected status, as the following test example shows:
</p><div class="example"><a id="idp45602952"></a><p class="title"><b>Example 5.21. The tst_jlist Test Script</b></p><div class="example-contents"><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">
import os
def main():
    startApplication('"' + os.environ["SQUISH_PREFIX"] + '/examples/java/itemviews/ItemViewsSwing.jar"')
    listWidgetName = ":Item Views_javax.swing.JList"
    listWidget = waitForObject(listWidgetName)
    model = listWidget.getModel()
    for row in range(model.getSize()):
        item = model.getElementAt(row)
        selected = ""
        if listWidget.isSelectedIndex(row):
            selected = " +selected"
        test.log("(%d) '%s'%s" % (row, item.toString(), selected))

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">
function main()
{
    startApplication('"' + OS.getenv("SQUISH_PREFIX") + '/examples/java/itemviews/ItemViewsSwing.jar"');
    var listWidgetName = ":Item Views_javax.swing.JList";
    var listWidget = waitForObject(listWidgetName);
    var model = listWidget.getModel();
    for (var row = 0; row &lt; model.getSize(); ++row) {
        var item = model.getElementAt(row);
        var selected = "";
        if (listWidget.isSelectedIndex(row)) {
            selected = " +selected";
        }
        test.log("(" + String(row) + ") '" + item.toString() + "'" + selected);
    }
}

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

sub main
{
    startApplication("\"$ENV{'SQUISH_PREFIX'}/examples/java/itemviews/ItemViewsSwing.jar\"");
    my $listWidgetName = ":Item Views_javax.swing.JList";
    my $listWidget = waitForObject($listWidgetName);
    my $model = $listWidget-&gt;getModel();
    for (my $row = 0; $row &lt; $model-&gt;getSize(); ++$row) {
        my $item = $model-&gt;getElementAt($row);
        my $selected = "";
        if ($listWidget-&gt;isSelectedIndex($row)) {
            $selected = " +selected";
        }
        test::log("($row) '" . $item-&gt;toString() . "'$selected");
    }
}

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">
# encoding: UTF-8
require 'squish'
include Squish

def main
    startApplication("\"#{ENV['SQUISH_PREFIX']}/examples/java/itemviews/ItemViewsSwing.jar\"")
    listWidgetName = ":Item Views_javax.swing.JList"
    listWidget = waitForObject(listWidgetName)
    model = listWidget.getModel()
    for row in 0...model.getSize()
        item = model.getElementAt(row)
        selected = ""
        if listWidget.isSelectedIndex(row)
            selected = " +selected"
        end
        Test.log("(#{row}) '#{item.toString()}'#{selected}")
    end
end

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">
proc main {} {
    startApplication "\"$::env(SQUISH_PREFIX)/examples/java/itemviews/ItemViewsSwing.jar\""
    set listWidgetName ":Item Views_javax.swing.JList"
    set listWidget [waitForObject $listWidgetName]
    set model [invoke $listWidget getModel]
    for {set row 0} {$row &lt; [invoke $model getSize]} {incr row} {
        set item [invoke $model getElementAt $row]
        set selected ""
        if {[invoke $listWidget isSelectedIndex $row]} {
            set selected " +selected"
        }
        set text [invoke $item toString]
        test log "($row) '$text'$selected"
    }
}

</pre></div></div></div><br class="example-break"></br><p>
All the output goes to <span class="emphasis"><em>Squish</em></span>'s log, but clearly it is easy to
change the script to test against a list of specific values and so on.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a id="how-to-test-jtable"></a>5.4.6.1.2.2. How to Test JTable</h6></div></div></div><p>
It is also very easy to iterate over all the items in a JTable and
retrieve their texts and selected status, as the following test example
shows:
</p><div class="example"><a id="idp45612360"></a><p class="title"><b>Example 5.22. The tst_jtable Test Script</b></p><div class="example-contents"><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">
import os
def main():
    startApplication('"' + os.environ["SQUISH_PREFIX"] + '/examples/java/itemviews/ItemViewsSwing.jar"')
    tableWidgetName = ":Item Views_javax.swing.JTable"
    tableWidget = waitForObject(tableWidgetName)
    model = tableWidget.getModel()
    for row in range(model.getRowCount()):
        for column in range(model.getColumnCount()):
            item = model.getValueAt(row, column)
            selected = ""
            if tableWidget.isCellSelected(row, column):
                selected = " +selected"
            test.log("(%d, %d) '%s'%s" % (row, column, item.toString(), selected))

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">
function main()
{
    startApplication('"' + OS.getenv("SQUISH_PREFIX") + '/examples/java/itemviews/ItemViewsSwing.jar"');
    var tableWidgetName = ":Item Views_javax.swing.JTable";
    var tableWidget = waitForObject(tableWidgetName);
    var model = tableWidget.getModel();
    for (var row = 0; row &lt; model.getRowCount(); ++row) {
        for (var column = 0; column &lt; model.getColumnCount(); ++column) {
            var item = model.getValueAt(row, column);
            var selected = "";
            if (tableWidget.isCellSelected(row, column)) {
                selected = " +selected";
            }
            test.log("(" + String(row) + ", " + String(column) + ") '" +
                     item.toString() + "'" + selected);
        }
    }
}

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

sub main
{
    startApplication("\"$ENV{'SQUISH_PREFIX'}/examples/java/itemviews/ItemViewsSwing.jar\"");
    my $tableWidgetName = ":Item Views_javax.swing.JTable";
    my $tableWidget = waitForObject($tableWidgetName);
    my $model = $tableWidget-&gt;getModel();
    for (my $row = 0; $row &lt; $model-&gt;getRowCount(); ++$row) {
        for (my $column = 0; $column &lt; $model-&gt;getColumnCount(); ++$column) {
            my $item = $model-&gt;getValueAt($row, $column);
            my $selected = "";
            if ($tableWidget-&gt;isCellSelected($row, $column)) {
                $selected = " +selected";
            }
            test::log("($row, $column) '$item'$selected");
        }
    }
}

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">
# encoding: UTF-8
require 'squish'
include Squish

def main
    startApplication("\"#{ENV['SQUISH_PREFIX']}/examples/java/itemviews/ItemViewsSwing.jar\"")
    tableWidgetName = ":Item Views_javax.swing.JTable"
    tableWidget = waitForObject(tableWidgetName)
    model = tableWidget.getModel()
    for row in 0...model.getRowCount()
        for column in 0...model.getColumnCount()
            item = model.getValueAt(row, column)
            selected = ""
            if tableWidget.isCellSelected(row, column)
                selected = " +selected"
            end
            Test.log("(#{row}, #{column}) '#{item}'#{selected}")
        end
    end
end

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">
proc main {} {
    startApplication "\"$::env(SQUISH_PREFIX)/examples/java/itemviews/ItemViewsSwing.jar\""
    set tableWidgetName ":Item Views_javax.swing.JTable"
    set tableWidget [waitForObject $tableWidgetName]
    set model [invoke $tableWidget getModel]
    for {set row 0} {$row &lt; [invoke $model getRowCount]} {incr row} {
        for {set column 0} {$column &lt; [invoke $model getColumnCount]} {incr column} {
            set item [invoke $model getValueAt $row $column]
            set selected ""
            if {[invoke $tableWidget isCellSelected $row $column]} {
                set selected " +selected"
            }
            set text [invoke $item toString]
            test log "($row, $column) '$text'$selected"
        }
    }
}

</pre></div></div></div><br class="example-break"></br><p>
Again, all the output goes to <span class="emphasis"><em>Squish</em></span>'s log, and clearly it is
easy to change the script to test against a specific values and so on.
</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip: Table Verification
Points"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></img></td><th align="left"><a id="table.verification.points2"></a>Table Verification
Points</th></tr><tr><td align="left" valign="top"><p>
It is possible to use table
verification points to check an entire table. See
<a class="xref" href="ug-vps.html#ugv-table" title="5.22.2. How to Create and Use Table Verifications">How to Create and Use Table Verifications (Section 5.22.2)</a>.
</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a id="how-to-test-jtree"></a>5.4.6.1.2.3. How to Test JTree</h6></div></div></div><p>
It is slightly more tricky to iterate over all the items in a JTree and
retrieve their texts and selected status—since a tree is a
recursive structure. Nonetheless, it is perfectly possible, as the
following test example shows:
</p><div class="example"><a id="idp45625088"></a><p class="title"><b>Example 5.23. The tst_jtree Test Script</b></p><div class="example-contents"><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">
import os
def checkAnItem(indent, model, item, selectionModel, treePath):
    if indent &gt; -1:
        selected = ""
        if selectionModel.isPathSelected(treePath):
            selected = " +selected"
        test.log("|%s'%s'%s" % (" " * indent, item.toString(), selected))
    else:
        indent = -4
    for row in range(model.getChildCount(item)):
        child = model.getChild(item, row)
        childTreePath = treePath.pathByAddingChild(child)
        checkAnItem(indent + 4, model, child, selectionModel, childTreePath)
       
def main():
    startApplication('"' + os.environ["SQUISH_PREFIX"] + '/examples/java/itemviews/ItemViewsSwing.jar"')
    treeWidgetName = ":Item Views_javax.swing.JTree"
    treeWidget = waitForObject(treeWidgetName)
    model = treeWidget.getModel()
    selectionModel = treeWidget.getSelectionModel()
    treePath = javax_swing_tree_TreePath(model.getRoot())
    checkAnItem(-1, model, model.getRoot(), selectionModel, treePath)

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

function checkAnItem(indent, model, item, selectionModel, treePath)
{
    if (indent &gt; -1) {
        var selected = "";
        if (selectionModel.isPathSelected(treePath)) {
            selected = " +selected";
        }
        var offset = "";
        for (var i = 0; i &lt; indent; ++i) {
            offset = offset.concat(" ");
        }
        test.log("|" + offset + "'" + item.toString() + "'" + selected);
    }
    else {
        indent = -4;
    }
    for (var row = 0; row &lt; model.getChildCount(item); ++row) {
        var child = model.getChild(item, row);
        var childTreePath = treePath.pathByAddingChild(child);
        checkAnItem(indent + 4, model, child, selectionModel, childTreePath)
    }
}
       
function main()
{
    startApplication('"' + OS.getenv("SQUISH_PREFIX") + '/examples/java/itemviews/ItemViewsSwing.jar"');
    var treeWidgetName = ":Item Views_javax.swing.JTree";
    var treeWidget = waitForObject(treeWidgetName);
    var model = treeWidget.getModel();
    var selectionModel = treeWidget.getSelectionModel();
    var treePath = new javax_swing_tree_TreePath(model.getRoot());
    checkAnItem(-1, model, model.getRoot(), selectionModel, treePath);
}

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

sub checkAnItem
{
    my ($indent, $model, $item, $selectionModel, $treePath) = @_;
    if ($indent &gt; -1) {
        my $selected = "";
        if ($selectionModel-&gt;isPathSelected($treePath)) {
            $selected = " +selected";
        }
        my $padding = " " x $indent;
        test::log("|" . $padding . "'" . $item-&gt;toString() . "'$selected");
    }
    else {
        $indent = -4;
    }
    for (my $row = 0; $row &lt; $model-&gt;getChildCount($item); ++$row) {
        my $child = $model-&gt;getChild($item, $row);
        my $childTreePath = $treePath-&gt;pathByAddingChild($child);
        checkAnItem($indent + 4, $model, $child, $selectionModel, $childTreePath);
    }
}

sub main
{
    startApplication("\"$ENV{'SQUISH_PREFIX'}/examples/java/itemviews/ItemViewsSwing.jar\"");
    my $treeWidgetName = ":Item Views_javax.swing.JTree";
    my $treeWidget = waitForObject($treeWidgetName);
    my $model = $treeWidget-&gt;getModel();
    my $selectionModel = $treeWidget-&gt;getSelectionModel();
    my $treePath = new javax_swing_tree_TreePath($model-&gt;getRoot());
    checkAnItem(-1, $model, $model-&gt;getRoot(), $selectionModel, $treePath);
}

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">
# encoding: UTF-8
require 'squish'
include Squish

def checkAnItem(indent, model, item, selectionModel, treePath)
    if indent &gt; -1
        selected = ""
        if selectionModel.isPathSelected(treePath)
            selected = " +selected"
        end
        Test.log("|%s'%s'%s" % [" " * indent, item, selected])
    else
        indent = -4
    end
    for row in 0...model.getChildCount(item)
        child = model.getChild(item, row)
        childTreePath = treePath.pathByAddingChild(child)
        checkAnItem(indent + 4, model, child, selectionModel, childTreePath)
    end
end

def main
    startApplication("\"#{ENV['SQUISH_PREFIX']}/examples/java/itemviews/ItemViewsSwing.jar\"")
    treeWidgetName = ":Item Views_javax.swing.JTree"
    treeWidget = waitForObject(treeWidgetName)
    model = treeWidget.getModel()
    selectionModel = treeWidget.getSelectionModel()
    treePath = LC::Javax_swing_tree_TreePath.new(model.getRoot())
    checkAnItem(-1, model, model.getRoot(), selectionModel, treePath)
end

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">
proc checkAnItem {indent model item selectionModel treePath} {
    if {$indent &gt; -1} {
        set selected ""
        if {[invoke $selectionModel isPathSelected $treePath]} {
            set selected " +selected"
        }
        set offset [string repeat " " $indent]
        set text [invoke $item toString]
        test log "|$offset '$text'$selected"
    } else {
        set indent -4
    }
    for {set row 0} {$row &lt; [invoke $model getChildCount $item]} {incr row} {
        set child [invoke $model getChild $item $row]
        set childTreePath [invoke $treePath pathByAddingChild $child]
        set offset [expr $indent + 4]
        checkAnItem $offset $model $child $selectionModel $childTreePath
    }
}
       
proc main {} {
    startApplication "\"$::env(SQUISH_PREFIX)/examples/java/itemviews/ItemViewsSwing.jar\""
    set treeWidgetName ":Item Views_javax.swing.JTree"
    set treeWidget [waitForObject $treeWidgetName]
    set model [invoke $treeWidget getModel]
    set selectionModel [invoke $treeWidget getSelectionModel]
    set root [invoke $model getRoot]
    set treePath [construct javax_swing_tree_TreePath $root]
    checkAnItem -1 $model $root $selectionModel $treePath
}

</pre></div></div></div><br class="example-break"></br><p>
The key difference from JList and JTable is that since JTrees are
recursive it is easiest if we ourselves use recursion to iterate over
all the items. We have also kept track of the "path" of each item since
we need this to determine which items are selected—there is no
need to do this if we only want to retrieve attributes of the items
themselves. And just as with the previous examples, all the output goes
to <span class="emphasis"><em>Squish</em></span>'s log, although it is easy to adapt the script to
perform other tests.
</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ug-testing-jtable-using-external-data"></a>5.4.6.1.3. How to Test JTable and Use External Data Files (Java—AWT/Swing)</h5></div></div></div><p>
In this section we will see how to test the
<code class="filename">CsvTable.java</code> program shown below. This program
uses a JTable to present the contents of a <code class="filename">.csv</code>
(comma-separated values) file, and provides some basic functionality for
manipulating the data—inserting and deleting rows and swapping
columns.
<sup>[<a href="ugs-qtapi.html#ftn.test.data.format.footnote" class="footnoteref">20</a>]</sup>
As we review the tests we will learn how to import test data,
manipulate the data, and compare what the JTable
shows with what we expect its contents to be. And since the
CSV Table program is a main-window-style
application, we will also learn how to test that menu options behave as
expected.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/ug-csvtable-java.png" align="middle"></img><div class="caption">The CSV Table program.</div></div></div><p>
The source code for this example is in the directory
<code class="filename">SQUISHDIR/examples/java/csvtable</code>, and the test
suites are in subdirectories underneath—for example, the Python
version of the tests is in the directory
<code class="filename">SQUISHDIR/examples/java/csvtable/suite_py</code>, and
the JavaScript version of the tests is in
<code class="filename">SQUISHDIR/examples/java/csvtable/suite_js</code>, and so
on.
</p><p>
The first test we will look at is deceptively simple and consists of
just four executable statements. This simplicity is achieved by putting
almost all the functionality into a shared script, to avoid code
duplication. Here is the complete <code class="code">main</code> function:
</p><div class="example"><a id="idp45649976"></a><p class="title"><b>Example 5.24. The tst_loading Test Script</b></p><div class="example-contents"><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">
import os

def main():
    startApplication('"' + os.environ["SQUISH_PREFIX"] + '/examples/java/csvtable/CsvTableSwing.jar"')
    source(findFile("scripts", "common.py"))
    filename = "before.csv"
    doFileOpen(filename)
    jtable = waitForObject("{type='javax.swing.JTable' visible='true'}")
    compareTableWithDataFile(jtable, filename)

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

function main()
{
    startApplication('"' + OS.getenv("SQUISH_PREFIX") + '/examples/java/csvtable/CsvTableSwing.jar"');
    source(findFile("scripts", "common.js"));
    var filename = "before.csv";
    doFileOpen(filename);
    var jtable = waitForObject("{type='javax.swing.JTable' visible='true'}");
    compareTableWithDataFile(jtable, filename);
}

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

sub main
{
    startApplication("\"$ENV{'SQUISH_PREFIX'}/examples/java/csvtable/CsvTableSwing.jar\"");
    source(findFile("scripts", "common.pl"));
    my $filename = "before.csv";
    doFileOpen($filename);
    my $jtable = waitForObject("{type='javax.swing.JTable' visible='true'}");
    compareTableWithDataFile($jtable, $filename);
}

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">
# encoding: UTF-8
require 'squish'

include Squish

def main
    startApplication("\"#{ENV['SQUISH_PREFIX']}/examples/java/csvtable/CsvTableSwing.jar\"")
    require findFile("scripts", "common.rb")
    filename = "before.csv"
    doFileOpen(filename)
    jtable = waitForObject("{type='javax.swing.JTable' visible='true'}")
    compareTableWithDataFile(jtable, filename)
end

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

proc main {} {
    startApplication "\"$::env(SQUISH_PREFIX)/examples/java/csvtable/CsvTableSwing.jar\""
    source [findFile "scripts" "common.tcl"]
    set filename "before.csv"
    doFileOpen $filename
    set jtable [waitForObject {{type='javax.swing.JTable' visible='true'}}]
    compareTableWithDataFile $jtable $filename
}

</pre></div></div></div><br class="example-break"></br><p>
We begin by loading in the script that contains common functionality,
just as we did in an earlier section. Then we call a custom
<code class="code">doFileOpen</code> function that tells the program to open
the given file—and this is done through the user interface as we
will see. Next we get a reference to the JTable using the
<a class="xref" href="rgs-squish.html#waitForObject-function"><code class="function">waitForObject</code></a> function, and finally we
check that the JTable's contents match the contents of the data file
held amongst the test suite's test data. Note that both the CSV Table
program and <span class="emphasis"><em>Squish</em></span> load and parse the data file using their own
completely independent code. (See <a class="xref" href="ug-shareddata.html" title="5.23. How to Create and Use Shared Data and Shared Scripts">How to Create and Use Shared Data and Shared Scripts (Section 5.23)</a> for
how to import test data into <span class="emphasis"><em>Squish</em></span>.)
</p><p>
Now we will look at the custom functions we have used in the above test.
</p><div class="example"><a id="idp45657600"></a><p class="title"><b>Example 5.25. Extracts from the Shared Scripts</b></p><div class="example-contents"><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

def doFileOpen(filename):
    chooseMenuOptionByKey("F", "o")
    paneName = "{type='javax.swing.JRootPane' visible='true'}"
    waitForObject(paneName)
    # Platform-specific name
    fileDialogEntryName = ("{leftWidget=':Open.File Name:"
        "_javax.swing.plaf.metal.MetalFileChooserUI$AlignedLabel' "
        "type='javax.swing.plaf.metal.MetalFileChooserUI$3' "
        "visible='true' window=':Open_javax.swing.JDialog'}")
    waitForObject(fileDialogEntryName)
    type(fileDialogEntryName, filename)
    waitForObject(fileDialogEntryName)
    type(fileDialogEntryName, "&lt;Return&gt;")
    

def chooseMenuOptionByKey(menuKey, optionKey):
    paneName = "{type='javax.swing.JRootPane' visible='true'}"
    waitForObject(paneName)
    type(paneName, "&lt;Alt+%s&gt;" % menuKey)
    waitForObject(paneName)
    type(paneName, optionKey)

    
def compareTableWithDataFile(jtable, filename):
    tableModel = jtable.getModel()
    for row, record in enumerate(testData.dataset(filename)):
        for column, name in enumerate(testData.fieldNames(record)):
            text = tableModel.getValueAt(row, column).toString()
            test.compare(testData.field(record, name), text)
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

function doFileOpen(filename)
{
    chooseMenuOptionByKey("F", "o");
    var paneName = "{type='javax.swing.JRootPane' visible='true'}";
    waitForObject(paneName);
    // Platform-specific name
    var fileDialogEntryName = ("{leftWidget=':Open.File Name:" +
        "_javax.swing.plaf.metal.MetalFileChooserUI$AlignedLabel' " +
        "type='javax.swing.plaf.metal.MetalFileChooserUI$3' visible='true' " +
        "window=':Open_javax.swing.JDialog'}");
    waitForObject(fileDialogEntryName);
    type(fileDialogEntryName, filename);
    waitForObject(fileDialogEntryName);
    type(fileDialogEntryName, "&lt;Return&gt;");
}
    

function chooseMenuOptionByKey(menuKey, optionKey)
{
    var paneName = "{type='javax.swing.JRootPane' visible='true'}";
    waitForObject(paneName);
    type(paneName, "&lt;Alt+" + menuKey + "&gt;")
    waitForObject(paneName);
    type(paneName, optionKey);
}

    
function compareTableWithDataFile(jtable, filename)
{
    var tableModel = jtable.getModel();
    var records = testData.dataset(filename);
    for (var row = 0; row &lt; records.length; ++row) {
        columnNames = testData.fieldNames(records[row]);
        for (var column = 0; column &lt; columnNames.length; ++column) {
            text = tableModel.getValueAt(row, column).toString();
            test.compare(testData.field(records[row], column), text);
        }
    }
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

sub doFileOpen
{
    my $filename = shift(@_);
    chooseMenuOptionByKey("F", "o");
    my $paneName = "{type='javax.swing.JRootPane' visible='true'}";
    waitForObject($paneName);
    # Platform-specific name
    my $fileDialogEntryName = ("{leftWidget=':Open.File Name:" .
        "_javax.swing.plaf.metal.MetalFileChooserUI\$AlignedLabel' " .
        "type='javax.swing.plaf.metal.MetalFileChooserUI\$3' " .
        "visible='true' window=':Open_javax.swing.JDialog'}");
    waitForObject($fileDialogEntryName);
    type($fileDialogEntryName, $filename);
    waitForObject($fileDialogEntryName);
    type($fileDialogEntryName, "&lt;Return&gt;");
}
    

sub chooseMenuOptionByKey
{
    my($menuKey, $optionKey) = @_;
    my $paneName = "{type='javax.swing.JRootPane' visible='true'}";
    waitForObject($paneName);
    type($paneName, "&lt;Alt+$menuKey&gt;");
    waitForObject($paneName);
    type($paneName, $optionKey);
}

    
sub compareTableWithDataFile
{
    my ($jtable, $filename) = @_;
    my $tableModel = $jtable-&gt;getModel();
    my @records = testData::dataset($filename);
    for (my $row = 0; $row &lt; scalar(@records); $row++) {
        my @columnNames = testData::fieldNames($records[$row]);
        for (my $column = 0; $column &lt; scalar(@columnNames); $column++) {
            my $text = $tableModel-&gt;getValueAt($row, $column)-&gt;toString();
            test::compare($text, testData::field($records[$row], $column));
        }
    }
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

def doFileOpen(filename)
    chooseMenuOptionByKey("F", "o")
    paneName = "{type='javax.swing.JRootPane' visible='true'}"
    waitForObject(paneName)
    # Platform-specific name
    fileDialogEntryName = ("{leftWidget=':Open.File Name:" +
    "_javax.swing.plaf.metal.MetalFileChooserUI$AlignedLabel' " +
    "type='javax.swing.plaf.metal.MetalFileChooserUI$3' " +
    "visible='true' window=':Open_javax.swing.JDialog'}")
    waitForObject(fileDialogEntryName)
    type(fileDialogEntryName, filename)
    waitForObject(fileDialogEntryName)
    type(fileDialogEntryName, "&lt;Return&gt;")
end

def chooseMenuOptionByKey(menuKey, optionKey)
    paneName = "{type='javax.swing.JRootPane' visible='true'}"
    waitForObject(paneName)
    type(paneName, "&lt;Alt+#{menuKey}&gt;")
    waitForObject(paneName)
    type(paneName, optionKey)
end

def compareTableWithDataFile(jtable, filename)
    tableModel = jtable.getModel()
    TestData.dataset(filename).each_with_index do
        |record, row|
        for column in 0...TestData.fieldNames(record).length
            text = tableModel.getValueAt(row, column).toString()
            Test.compare(TestData.field(record, column), text)
        end
    end
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

proc doFileOpen {filename} {
    chooseMenuOptionByKey "F" "o"
    set paneName {{type='javax.swing.JRootPane' visible='true'}}
    waitForObject $paneName
    # Platform-specific name
    set fileDialogEntryName \
        {{leftWidget=':Open.File Name:_javax.swing.plaf.metal.MetalFileChooserUI$AlignedLabel' type='javax.swing.plaf.metal.MetalFileChooserUI$3' visible='true' window=':Open_javax.swing.JDialog'}}
    waitForObject $fileDialogEntryName
    invoke type $fileDialogEntryName $filename
    waitForObject $fileDialogEntryName
    invoke type $fileDialogEntryName "&lt;Return&gt;"
}
    

proc chooseMenuOptionByKey {menuKey optionKey} {
    set paneName {{type='javax.swing.JRootPane' visible='true'}}
    waitForObject $paneName
    invoke type $paneName "&lt;Alt+$menuKey&gt;"
    waitForObject $paneName
    invoke type $paneName $optionKey
}

    
proc compareTableWithDataFile {jtable filename} {
    set data [testData dataset $filename]
    set tableModel [invoke $jtable getModel]
    for {set row 0} {$row &lt; [llength $data]} {incr row} {
        set columnNames [testData fieldNames [lindex $data $row]]
        for {set column 0} {$column &lt; [llength $columnNames]} \
            {incr column} {
            set item [invoke $tableModel getValueAt $row $column]
            test compare [testData field [lindex $data $row] $column] \
                [invoke $item toString]
        }
    }
}
</pre></div></div></div><br class="example-break"></br><p>
The <code class="code">doFileOpen</code> function begins by opening a file
through the user interface. This is done by using the custom
<code class="code">chooseMenuOptionByKey</code> function. The file dialog used may
not be the same on all platforms so the name of the text entry (in this
case of type AlignedLabel) may vary, so we have added a note that the
name is platform-specific. Apart from that using the dialog itself is
straightforward—we simply type in the filename into the text entry
and the type <span class="keycap"><strong>Return</strong></span> to confirm the
choice.
</p><p>
The
<code class="code">chooseMenuOptionByKey</code> function simulates the user
clicking
<span class="keycap"><strong>Alt</strong></span>+<span class="keycap"><strong><span class="emphasis"><em>k</em></span></strong></span>
(where <span class="emphasis"><em>k</em></span> is a character, for example "F" for the
file menu), and then the character that corresponds to the required
action, (for example, "o" for "Open").
</p><p>
When the file is opened, the program is expected to load the file's
data. We check that the data has been loaded correctly by comparing the
data shown in the JTable with the data in the file. This comparison is
done by the custom <code class="code">compareTableWithDataFile</code> function. This
function uses <span class="emphasis"><em>Squish</em></span>'s <a class="xref" href="rgs-squish.html#testData.dataset-function"><code class="function">testData.dataset</code></a>
function to load in the data so that it can be accessed through the
<span class="emphasis"><em>Squish</em></span> API. We expect every cell in the table to match the
corresponding item in the data, and we check that this is the case using
the <a class="xref" href="rgs-squish.html#test.compare-function"><code class="function">test.compare</code></a> function.
</p><p>
Now that we know how to compare a table's data with the data in a file
we can perform some more ambitious tests. We will load in the
<code class="filename">before.csv</code> file, delete a few rows, insert a new
row in the middle, and append a new row at the end. Then we will swap a
few pairs of columns. At the end the data should match the
<code class="filename">after.csv</code> file.
</p><p>
Rather than writing code to do all these things we can simply record a
test script that opens the file and performs all the deletions,
insertions, and column swaps. Then we can edit the recorded test script
to add a few lines of code near the end to compare the actual results
with the expected results. Shown below is an extract from the test script
starting one line above the hand written code and continuing to the end
of the script:
</p><div class="example"><a id="idp45685200"></a><p class="title"><b>Example 5.26. Extracts from the tst_editing Script</b></p><div class="example-contents"><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

    type(waitForObject(":Input.Enter the comma-separated names of the two columns_JTextField"), "&lt;Return&gt;")
# Added by Hand
    source(findFile("scripts", "common.py"))
    jtable = waitForObject("{type='javax.swing.JTable' visible='true'}")
    tableModel = jtable.getModel()
    test.verify(tableModel.getColumnCount() == 5)
    test.verify(tableModel.getRowCount() == 10)
    compareTableWithDataFile(jtable, "after.csv")
# End of Added by Hand
    type(waitForObject(":CSV Table - before.csv_JRootPane"), "&lt;Alt+F&gt;")
    type(waitForObject(":CSV Table - before.csv_JRootPane"), "q")
    type(waitForObject(":CSV Table.Yes_JButton"), "&lt;Alt+N&gt;")
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

    type(waitForObject(":Input.Enter the comma-separated names of the two columns_JTextField"), "&lt;Return&gt;");
// Added by Hand
    source(findFile("scripts", "common.js"))
    var jtable = waitForObject("{type='javax.swing.JTable' visible='true'}")
    var tableModel = jtable.getModel()
    test.verify(tableModel.getColumnCount() == 5)
    test.verify(tableModel.getRowCount() == 10)
    compareTableWithDataFile(jtable, "after.csv")
// End of Added by Hand
    type(waitForObject(":CSV Table - before.csv_JRootPane"), "&lt;Alt+F&gt;");
    type(waitForObject(":CSV Table - before.csv_JRootPane"), "q");
    type(waitForObject(":CSV Table.Yes_JButton"), "&lt;Alt+N&gt;");
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

    type(waitForObject(":Input.Enter the comma-separated names of the two columns_JTextField"), "&lt;Return&gt;");
# Added by Hand
    source(findFile("scripts", "common.pl"));
    my $jtable = waitForObject("{type='javax.swing.JTable' visible='true'}");
    my $tableModel = $jtable-&gt;getModel();
    test::verify($tableModel-&gt;getColumnCount() == 5);
    test::verify($tableModel-&gt;getRowCount() == 10);
    compareTableWithDataFile($jtable, "after.csv");
# End of Added by Hand
    type(waitForObject(":CSV Table - before.csv_JRootPane"), "&lt;Alt+F&gt;");
    type(waitForObject(":CSV Table - before.csv_JRootPane"), "q");
    type(waitForObject(":CSV Table.Yes_JButton"), "&lt;Alt+N&gt;");
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

    type(waitForObject(":Input.Enter the comma-separated names of the two columns_JTextField"), "&lt;Return&gt;")
    # Added by Hand
    require findFile("scripts", "common.rb")
    jtable = waitForObject("{type='javax.swing.JTable' visible='true'}")
    tableModel = jtable.getModel()
    Test.verify(tableModel.getColumnCount() == 5)
    Test.verify(tableModel.getRowCount() == 10)
    compareTableWithDataFile(jtable, "after.csv")
    # End of Added by Hand
    type(waitForObject(":CSV Table - before.csv_JRootPane"), "&lt;Alt+F&gt;")
    type(waitForObject(":CSV Table - before.csv_JRootPane"), "q")
    type(waitForObject(":CSV Table.Yes_JButton"), "&lt;Alt+N&gt;")
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

    invoke type [waitForObject ":Input.Enter the comma-separated names of the two columns_JTextField"] "&lt;Return&gt;"
# Added by Hand
    source [findFile "scripts" "common.tcl"]
    set jtable [waitForObject {{type='javax.swing.JTable' \
        visible='true'}}]
    set tableModel [invoke $jtable getModel]
    test compare [invoke $tableModel getColumnCount] 5
    test compare [invoke $tableModel getRowCount] 10
    compareTableWithDataFile $jtable "after.csv"
# End of Added by Hand
    invoke type [waitForObject ":CSV Table - before.csv_JRootPane"] "&lt;Alt+F&gt;"
    invoke type [waitForObject ":CSV Table - before.csv_JRootPane"] "q"
    invoke type [waitForObject ":CSV Table.Yes_JButton"] "&lt;Alt+N&gt;"
}
</pre></div></div></div><br class="example-break"></br><p>
As the extract indictates, the added lines are not inserted at the
<span class="emphasis"><em>end</em></span> of the recorded test script, but rather just
before the program is terminated—after all, we need the program to
be running to query its JTable. (The reason that the row counts differ
is that slightly different interactions were recorded for each
scripting language.)
</p><p>
This example shows the power of combining recording with hand editing.
If at a later date a new feature was added to the program we could
incorporate tests for it in a number of ways. The simplest would be to
just add another test script, do the recording, and then add in the
lines needed to compare the table with the expected data. Another
approach would be to record the use of the new feature in a temporary
test and then copy and paste the recording into the existing test at a
suitable place and then change the file to be compared at the end to one
that accounts for all the changes to the original data and also the
changes that are a result of using the new feature. Or we could record a
test snippet directly into an existing test.
</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ug-java-swt-how-to-test-applications"></a>5.4.6.2. How to Test <span class="trademark">Java</span>™ SWT Applications</h4></div></div></div><p>
In the subsections that follow we will focus on testing <span class="trademark">Java</span>™ SWT
widgets, both single-valued widgets like buttons and date/time edits,
and multi-valued widgets such as lists, tables, and trees. We will also
cover testing using external data files.
</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ugjava-swt-paymentform-example"></a>5.4.6.2.1. How to Test Stateful and Single-Valued Widgets (<span class="trademark">Java</span>™/SWT)</h5></div></div></div><p>
In this section we will see how to test the
<code class="filename">examples/java/paymentform_swt/PaymentFormSWT.java</code>
example program. This program uses many basic <span class="trademark">Java</span>™/SWT widgets
including <code class="code">Button</code>, <code class="code">Combo</code>,
<code class="code">DateTime</code>, <code class="code">TabFolder</code>, and <code class="code">Text</code>. As
part of our coverage of the example we will show how to check the values
and state of individual widgets. We will also demonstrate how to test a
form's business rules.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/ug-paymentform-java-swt.png" align="middle"></img><div class="caption"><p>The <code class="code">PaymentFormSWT</code> example in "pay by credit card" mode.
</p></div></div></div><p>
The <code class="code">PaymentFormSWT</code> is invoked when an invoice is to be paid,
either at a point of sale, or—for credit cards—by phone. The
form's <span class="guibutton">Pay</span> button must only be enabled if the
correct fields are filled in and have valid values. The business rules
that we must test for are as follows:
</p><div class="itemizedlist"><ul type="disc"><li><p>
In "cash" mode, i.e., when the Cash tab is checked:
</p><div class="itemizedlist"><ul type="circle"><li><p>
The minimum payment is one dollar and the maximum is $2000 or
the amount due, whichever is smaller.
	</p></li></ul></div><p>
</p></li><li><p>
In "check" mode, i.e., when the Check tab is checked:
</p><div class="itemizedlist"><ul type="circle"><li><p>
The minimum payment is $10 and the maximum is $250 or the amount due,
whichever is smaller.
	</p></li><li><p>
The check date must be no earlier than 30 days ago and no later than
tomorrow, and must initially be set to today's date.
	</p></li><li><p>
The bank name, bank number, account name, and account number line edits
must all be nonempty.
	</p></li><li><p>
The check signed checkbox must be checked.
	</p></li></ul></div><p>
</p></li><li><p>
In "card" mode, i.e., when the Credit Card tab is checked:
</p><div class="itemizedlist"><ul type="circle"><li><p>
The minimum payment is $10 or 5% of the amount due whichever is larger,
and the maximum is $5000 or the amount due, whichever is smaller.
	</p></li><li><p>
The issue date must be no earlier than three years ago, and must be
initially set to the earliest possible date.
	</p></li><li><p>
The expiry date must be at least one month later than today, and must be
initially set to the earliest possible date.
	</p></li><li><p>
The account name and account number line edits must be nonempty.
	</p></li></ul></div><p>
</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Eclipse 3.4-specific"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></img></td><th align="left">Eclipse 3.4-specific</th></tr><tr><td align="left" valign="top"><p>
<span class="trademark">Java</span>™/SWT's DateTime control for Eclipse 3.4 does not support the
setting of date ranges, so although the application does constrain the
date ranges using listeners, we cannot easily test this in hand written
code. One simple solution is to record a script where an attempt is made
to change to an out of range date, and either run that as a separate
test or copy and paste the relevant lines into a hand written script.
</p></td></tr></table></div><p>
We will write three tests, one for each of the form's modes.
</p><p>
The source code for the payment form is in the directory
<code class="filename">SQUISHDIR/examples/java/paymentform_swt</code>, and the test
suites are in subdirectories underneath—for example, the Python
version of the tests is in the directory
<code class="filename">SQUISHDIR/examples/java/paymentform_swt/suite_py</code>, and
the JavaScript version of the tests is in
<code class="filename">SQUISHDIR/examples/java/paymentform_swt/suite_js</code>,
and so on.
</p><p>
We will begin by reviewing the test script for testing the form's
"cash" mode. First we will show the code, then we will explain it.
</p><div class="example"><a id="idp45718056"></a><p class="title"><b>Example 5.27. The tst_cash_mode Test Script</b></p><div class="example-contents"><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">
import os
def main():
    startApplication('"' + os.environ["SQUISH_PREFIX"] + '/examples/java/paymentform_swt/PaymentFormSWT.jar"')
    # Start with the correct tab
    tabFolderName = ":Payment Form_org.eclipse.swt.widgets.TabFolder"
    tabFolder = waitForObject(tabFolderName)
    clickTab(tabFolder, "C&amp;ash")

    # Business rule #1: the minimum payment is $1 and the maximum is
    # $2000 or the amount due whichever is smaller
    amountDueLabelName = ("{caption?='[$][0-9.,]*' "
        "type='org.eclipse.swt.widgets.Label' visible='true' "
        "window=':Payment Form_org.eclipse.swt.widgets.Shell'}")
    amountDueLabel = waitForObject(amountDueLabelName)
    chars = []
    for char in str(amountDueLabel.getText()):
        if char.isdigit():
            chars.append(char)
    amount_due = cast("".join(chars), int)
    maximum = min(2000, amount_due)
    paymentSpinnerName = ("{isvisible='true' "
        "type='org.eclipse.swt.widgets.Spinner' "
        "window=':Payment Form_org.eclipse.swt.widgets.Shell'}")
    paymentSpinner = waitForObject(paymentSpinnerName)
    test.verify(paymentSpinner.getMinimum() == 1)
    test.verify(paymentSpinner.getMaximum() == maximum)
    
    # Business rule #2: the Pay button is enabled (since the above tests
    # ensure that the payment amount is in range)
    payButtonName = ":Payment Form.Pay_org.eclipse.swt.widgets.Button"
    payButton = waitForObject(payButtonName)
    test.verify(payButton.isEnabled())

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">
function main()
{
    startApplication('"' + OS.getenv("SQUISH_PREFIX") + '/examples/java/paymentform_swt/PaymentFormSWT.jar"');
    // Start with the correct tab
    var tabFolderName = ":Payment Form_org.eclipse.swt.widgets.TabFolder";
    var tabFolder = waitForObject(tabFolderName);
    clickTab(tabFolder, "C&amp;ash");

    // Business rule #1: the minimum payment is $1 and the maximum is
    // $2000 or the amount due whichever is smaller
    var amountDueLabelName = "{caption?='[$][0-9.,]*' " +
        "type='org.eclipse.swt.widgets.Label' " +
        "window=':Payment Form_org.eclipse.swt.widgets.Shell'}";
    var amountDueLabel = waitForObject(amountDueLabelName);
    var amount_due = 0 + amountDueLabel.text.replace(/\D/g, "");
    var maximum = Math.min(2000, amount_due);

    var paymentSpinnerName = "{isvisible='true' " +
        "type='org.eclipse.swt.widgets.Spinner' " +
        "window=':Payment Form_org.eclipse.swt.widgets.Shell'}";
    var paymentSpinner = waitForObject(paymentSpinnerName);
    test.verify(paymentSpinner.getMinimum() == 1);
    test.verify(paymentSpinner.getMaximum() == maximum);
    
    // Business rule #2: the Pay button is enabled (since the 
    // above tests ensure that the payment amount is in range)
    var payButtonName = ":Payment Form.Pay_org.eclipse.swt." +
        "widgets.Button";
    var payButton = waitForObject(payButtonName);
    test.verify(payButton.isEnabled());
}

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

sub main
{
    startApplication("\"$ENV{'SQUISH_PREFIX'}/examples/java/paymentform_swt/PaymentFormSWT.jar\"");
    # Start with the correct tab
    my $tabFolderName = ":Payment Form_org.eclipse.swt.widgets.TabFolder";
    my $tabFolder = waitForObject($tabFolderName);
    clickTab($tabFolder, "C&amp;ash");

    # Business rule #1: the minimum payment is $1 and the maximum is
    # $2000 or the amount due whichever is smaller
    my $amountDueLabelName = "{caption?='[\$][0-9.,]*' " .
        "type='org.eclipse.swt.widgets.Label' visible='true' " .
        "window=':Payment Form_org.eclipse.swt.widgets.Shell'}";
    my $amountDueLabel = waitForObject($amountDueLabelName);
    my $amount_due = $amountDueLabel-&gt;text;
    $amount_due =~ s/\D//g; # remove non-digits
    my $maximum = 2000 &lt; $amount_due ? 2000 : $amount_due;
    my $paymentSpinnerName = "{isvisible='true' " .
        "type='org.eclipse.swt.widgets.Spinner' " .
        "window=':Payment Form_org.eclipse.swt.widgets.Shell'}";
    my $paymentSpinner = waitForObject($paymentSpinnerName);
    test::verify($paymentSpinner-&gt;getMinimum() == 1);
    test::verify($paymentSpinner-&gt;getMaximum() == $maximum);

    # Business rule #2: the Pay button is enabled (since the above tests
    # ensure that the payment amount is in range)
    my $payButtonName = ":Payment Form.Pay_org.eclipse.swt.widgets.Button";
    my $payButton = waitForObject($payButtonName);
    test::verify($payButton-&gt;isEnabled());
}

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">
# encoding: UTF-8
require 'squish'
include Squish

def main
    startApplication("\"#{ENV['SQUISH_PREFIX']}/examples/java/paymentform_swt/PaymentFormSWT.jar\"")
    # Start with the correct tab
    tabFolderName = ":Payment Form_org.eclipse.swt.widgets.TabFolder"
    tabFolder = waitForObject(tabFolderName)
    clickTab(tabFolder, "C&amp;ash")

    # Business rule #1: the minimum payment is $1 and the maximum is
    # $2000 or the amount due whichever is smaller
    amountDueLabelName = "{caption?='[$][0-9.,]*' " +
    "type='org.eclipse.swt.widgets.Label' visible='true' " +
    "window=':Payment Form_org.eclipse.swt.widgets.Shell'}"
    amountDueLabel = waitForObject(amountDueLabelName)
    amount_due = String(amountDueLabel.text).gsub(/\D/, "").to_f
    maximum = 2000 &lt; amount_due ? 2000 : amount_due
    paymentSpinnerName = "{isvisible='true' " +
    "type='org.eclipse.swt.widgets.Spinner' " +
    "window=':Payment Form_org.eclipse.swt.widgets.Shell'}"
    paymentSpinner = waitForObject(paymentSpinnerName)
    Test.verify(paymentSpinner.getMinimum() == 1)
    Test.verify(paymentSpinner.getMaximum() == maximum)

    # Business rule #2: the Pay button is enabled (since the above tests
    # ensure that the payment amount is in range)
    payButtonName = ":Payment Form.Pay_org.eclipse.swt.widgets.Button"
    payButton = waitForObject(payButtonName)
    Test.verify(payButton.isEnabled())
end

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">
proc main {} {
    startApplication "\"$::env(SQUISH_PREFIX)/examples/java/paymentform_swt/PaymentFormSWT.jar\""
    # Start with the correct tab
    set tabFolderName ":Payment Form_org.eclipse.swt.widgets.TabFolder"
    set tabFolder [waitForObject $tabFolderName]
    invoke clickTab $tabFolder "C&amp;ash"

    # Business rule #1: the minimum payment is $1 and the maximum is
    # $2000 or the amount due whichever is smaller
    set amountDueLabelName {{caption?='[$][0-9.,]*' \
        type='org.eclipse.swt.widgets.Label' \
        window=':Payment Form_org.eclipse.swt.widgets.Shell'}}
    set amountDueLabel [waitForObject $amountDueLabelName]
    set amountText [toString [property get $amountDueLabel text]]
    regsub -all {\D} $amountText "" amountText
    set amount_due [expr $amountText]
    set maximum [expr $amount_due &lt; 2000 ? $amount_due : 2000]
    set paymentSpinnerName {{isvisible='true' \
        type='org.eclipse.swt.widgets.Spinner' \
        window=':Payment Form_org.eclipse.swt.widgets.Shell'}}
    set paymentSpinner [waitForObject $paymentSpinnerName]
    test compare [invoke $paymentSpinner getMinimum] 1
    test compare [invoke $paymentSpinner getMaximum] $maximum
    
    # Business rule #2: the Pay button is enabled (since the above tests
    # ensure that the payment amount is in range)
    set payButtonName ":Payment Form.Pay_org.eclipse.swt.widgets.Button"
    set payButton [waitForObject $payButtonName]
    test verify [invoke $payButton isEnabled]
}

</pre></div></div></div><br class="example-break"></br><p>
We must start by making sure that the form is in the mode we want to
test. In general, the way we gain access to visible widgets is always
the same: we create a variable holding the widget's name, then we call
<a class="xref" href="rgs-squish.html#waitForObject-function"><code class="function">waitForObject</code></a> to get a reference to the
widget. Once we have the reference we can use it to access the widget's
properties and to call the widget's methods. In this case we use
the <a class="xref" href="rgs-squish.html#waitForObject-function"><code class="function">waitForObject</code></a> function to get a reference
to the <code class="code">TabFolder</code> widget and then use the <a class="xref" href="rgs-javaconvenience.html#java-clickTab-function"><code class="function">clickTab</code></a> function to click the tab we are
interested in. How did we know the tab folder's name? We used the <span class="application">Spy</span>
(see <a class="xref" href="ug-editdebug.html#uged-spy" title="5.21.3. How to Use the Spy">How to Use the Spy (Section 5.21.3)</a>).
</p><p>
The first business rule to be tested concerns the minimum and maximum
allowed payment amounts. As usual we begin calling
<a class="xref" href="rgs-squish.html#waitForObject-function"><code class="function">waitForObject</code></a> to get
references to the widgets we are interested in—in this case
starting with the amount due label. Because the amount due label's text
varies depending on the amount we cannot have a fixed name for it.
So instead we identify it using a real (multi-property) name using
wildcards. The wildcard of <code class="code">[$][0-9.,]*</code> matches any text
that starts with a dollar sign and is followed by zero or more digits,
periods and commas. <span class="emphasis"><em>Squish</em></span> can also do regular expression
matching—see <a class="xref" href="rg-namelookup.html" title="7.10. Improving Object Identification">Improving Object Identification (Section 7.10)</a> for more about
matching.
</p><p>
Since the label's text might contain a currency symbol and grouping
markers (for example, $1,700 or €1.700), to convert its text into an
integer we must strip away any non-digit characters first. We do this in
different ways depending on the underlying scripting language. (For
example, in Python, we iterate over each character and join all those
that are digits into a single string and use the <a class="xref" href="rgs-squish.html#cast-function"><code class="function">cast</code></a> function which takes an object and the type
the object should be converted to, and returns an object of the
requested type—or 0 on failure. We use a similar approach in
JavaScript, but for Perl and Tcl we simply strip out non-digit characters
using a regular expression.) The resulting integer is the amount due, so
we can now trivially calculate the maximum amount that can be paid in
cash.
</p><p>
With the minimum and maximum amounts known we next get a reference to
the payment <code class="code">Spinner</code>, again using the <span class="application">Spy</span> to find out the
spinner's name. Once we have a reference to the spinner, we use the
<a class="xref" href="rgs-squish.html#test.verify-function"><code class="function">test.verify</code></a> method to ensure that is has
the correct minimum and maximum amounts set. (For Tcl we have used the
<a class="xref" href="rgs-squish.html#test.compare-function"><code class="function">test.compare</code></a> method instead of <a class="xref" href="rgs-squish.html#test.verify-function"><code class="function">test.verify</code></a> since it is more convenient to do
so.)
</p><p>
Checking the last business rule is easy in this case since if the amount
is in range (and it must be because we have just checked it), then
payment is allowed so the <span class="guibutton">Pay</span> button should be
enabled. Once again, we use the same approach to test this: first we
call <a class="xref" href="rgs-squish.html#waitForObject-function"><code class="function">waitForObject</code></a>
to get a reference to it, and then
we conduct the test—in this case checking that the
<span class="guibutton">Pay</span> button is enabled.
</p><p>
Although the "cash" mode test works well, there are a few places where
we use essentially the same code. So before creating the test for the
"check" and "card" modes, we will create some common functions that we
can use to refactor our tests with. (The process used to create shared
code is described a little later in <a class="xref" href="ug-shareddata.html" title="5.23. How to Create and Use Shared Data and Shared Scripts">How to Create and Use Shared Data and Shared Scripts (Section 5.23)</a>—essentially all we need to do is create
a new script under the Test Suite's shared item's scripts item.) The
Python common code is in <code class="filename">common.py</code>, the JavaScript
common code is in <code class="filename">common.js</code>, and so on.
</p><div class="example"><a id="idp45747088"></a><p class="title"><b>Example 5.28. The Shared Code</b></p><div class="example-contents"><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">
def clickTabItem(name):
    tabFolderName = ("{isvisible='true' "
        "type='org.eclipse.swt.widgets.TabFolder' "
        "window=':Payment Form_org.eclipse.swt.widgets.Shell'}")
    tabFolder = waitForObject(tabFolderName)
    clickTab(tabFolder, name)


def dateTimeEqualsDate(dateTime, date):
    return (dateTime.getYear() == date.get(java_util_Calendar.YEAR) and
        dateTime.getMonth() == date.get(java_util_Calendar.MONTH) and
        dateTime.getDay() == date.get(java_util_Calendar.DAY_OF_MONTH))

    
def getAmountDue():
    amountDueLabelName = ("{caption?='[$][0-9.,]*' "
            "type='org.eclipse.swt.widgets.Label' visible='true' "
            "window=':Payment Form_org.eclipse.swt.widgets.Shell'}")
    amountDueLabel = waitForObject(amountDueLabelName)
    chars = []
    for char in str(amountDueLabel.getText()):
        if char.isdigit():
            chars.append(char)
    return cast("".join(chars), int)


def checkPaymentRange(minimum, maximum):
    paymentSpinner = waitForObject("{isvisible='true' "
        "type='org.eclipse.swt.widgets.Spinner' "
        "window=':Payment Form_org.eclipse.swt.widgets.Shell'}")
    test.verify(paymentSpinner.getMinimum() == minimum)
    test.verify(paymentSpinner.getMaximum() == maximum)

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">
function clickTabItem(name)
{
    var tabFolderName = "{isvisible='true' type='org.eclipse." +
        "swt.widgets.TabFolder' " +
        "window=':Payment Form_org.eclipse.swt.widgets.Shell'}";
    var tabFolder = waitForObject(tabFolderName);
    clickTab(tabFolder, name);
}


function dateTimeEqualsDate(dateTime, aDate)
{
    return (dateTime.getYear() == aDate.get(java_util_Calendar.YEAR) &amp;&amp;
        dateTime.getMonth() == aDate.get(java_util_Calendar.MONTH) &amp;&amp;
        dateTime.getDay() == aDate.get(java_util_Calendar.DAY_OF_MONTH));
}

    
function getAmountDue()
{
    var amountDueLabel = waitForObject("{caption?='[$][0-9.,]*' " +
            "type='org.eclipse.swt.widgets.Label' visible='true' " +
            "window=':Payment Form_org.eclipse.swt.widgets.Shell'}");
    return 0 + amountDueLabel.text.replace(/\D/g, "");
}


function checkPaymentRange(minimum, maximum)
{
    var paymentSpinner = waitForObject("{isvisible='true' " +
        "type='org.eclipse.swt.widgets.Spinner' " +
        "window=':Payment Form_org.eclipse.swt.widgets.Shell'}");
    test.verify(paymentSpinner.getMinimum() == minimum);
    test.verify(paymentSpinner.getMaximum() == maximum);
}

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">
sub clickTabItem
{
    my $name = shift(@_);
    my $tabFolderName = "{isvisible='true' " .
        "type='org.eclipse.swt.widgets.TabFolder' " .
        "window=':Payment Form_org.eclipse.swt.widgets.Shell'}";
    my $tabFolder = waitForObject($tabFolderName);
    clickTab($tabFolder, $name);
}


sub dateTimeEqualsDate
{
    my ($dateTime, $date) = @_;
    return ($dateTime-&gt;getYear() == $date-&gt;get(java_util_Calendar-&gt;YEAR) &amp;&amp;
        $dateTime-&gt;getMonth() == $date-&gt;get(java_util_Calendar-&gt;MONTH) &amp;&amp;
        $dateTime-&gt;getDay() == $date-&gt;get(java_util_Calendar-&gt;DAY_OF_MONTH));
}

    
sub getAmountDue
{
    my $amountDueLabel = waitForObject("{caption?='[\$][0-9.,]*' " .
            "type='org.eclipse.swt.widgets.Label' visible='true' " .
            "window=':Payment Form_org.eclipse.swt.widgets.Shell'}");
    my $amount_due = $amountDueLabel-&gt;text;
    $amount_due =~ s/\D//g; # remove non-digits
    return $amount_due;
}


sub checkPaymentRange
{
    my ($minimum, $maximum) = @_;
    my $paymentSpinner = waitForObject("{isvisible='true' " .
        "type='org.eclipse.swt.widgets.Spinner' " .
        "window=':Payment Form_org.eclipse.swt.widgets.Shell'}");
    test::verify($paymentSpinner-&gt;getMinimum() == $minimum);
    test::verify($paymentSpinner-&gt;getMaximum() == $maximum);
}

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">
# encoding: UTF-8
require 'squish'

include Squish

def clickTabItem(name)
    tabFolderName = "{isvisible='true' " +
    "type='org.eclipse.swt.widgets.TabFolder' " +
    "window=':Payment Form_org.eclipse.swt.widgets.Shell'}"
    tabFolder = waitForObject(tabFolderName)
    clickTab(tabFolder, name)
end

def dateTimeEqualsDate(dateTime, date)
    dateTime.getYear() == date.get(LC::Java_util_Calendar.YEAR) &amp;&amp;
    dateTime.getMonth() == date.get(LC::Java_util_Calendar.MONTH) &amp;&amp;
    dateTime.getDay() == date.get(LC::Java_util_Calendar.DAY_OF_MONTH)
end

def getAmountDue
    amountDueLabelName = "{caption?='[$][0-9.,]*' " +
    "type='org.eclipse.swt.widgets.Label' visible='true' " +
    "window=':Payment Form_org.eclipse.swt.widgets.Shell'}"
    amountDueLabel = waitForObject(amountDueLabelName)
    String(amountDueLabel.text).gsub(/\D/, "").to_f
end

def checkPaymentRange(minimum, maximum)
    paymentSpinner = waitForObject("{isvisible='true' " +
    "type='org.eclipse.swt.widgets.Spinner' " +
    "window=':Payment Form_org.eclipse.swt.widgets.Shell'}")
    Test.verify(paymentSpinner.getMinimum() == minimum)
    Test.verify(paymentSpinner.getMaximum() == maximum)
end

def min(a, b)
    a &lt; b ? a : b
end

def max(a, b)
    a &lt; b ? b : a
end

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">
proc clickTabItem {name} {
    set tabFolderName {{isvisible='true' \
        type='org.eclipse.swt.widgets.TabFolder' \
        window=':Payment Form_org.eclipse.swt.widgets.Shell'}}
    set tabFolder [waitForObject $tabFolderName]
    invoke clickTab $tabFolder $name
}


proc getAmountDue {} {
    set amountDueLabelName {{caption?='[$][0-9.,]*' \
        type='org.eclipse.swt.widgets.Label' \
        window=':Payment Form_org.eclipse.swt.widgets.Shell'}}
    set amountDueLabel [waitForObject $amountDueLabelName]
    set amountText [toString [property get $amountDueLabel text]]
    regsub -all {\D} $amountText "" amountText
    return [expr $amountText]
}


proc dateTimeEqualsDate {dateTime date} {
    set yearsMatch [expr [invoke $dateTime getYear] == \
        [invoke $date get [property get java_util_Calendar YEAR]]]
    set monthsMatch [expr [invoke $dateTime getMonth] == \
        [invoke $date get [property get java_util_Calendar MONTH]]]
    set daysMatch [expr [invoke $dateTime getDay] == \
        [invoke $date get [property get java_util_Calendar DAY_OF_MONTH]]]
    if {$yearsMatch &amp;&amp; $monthsMatch &amp;&amp; $daysMatch} {
        return true
    }
    return false
}


proc checkPaymentRange {minimum maximum} {
    set paymentSpinner [waitForObject {{isvisible='true' \
        type='org.eclipse.swt.widgets.Spinner' \
        window=':Payment Form_org.eclipse.swt.widgets.Shell'}}]
    test compare [invoke $paymentSpinner getMinimum] $minimum
    test compare [invoke $paymentSpinner getMaximum] $maximum
    
}

</pre></div></div></div><br class="example-break"></br><p>
Now we can write our tests for "check" and "card" modes and put more of
our effort into testing the business rules and less into some of the
basic chores. The code for "check" mode is quite long, but we have
broken it down into a <code class="code">main</code> function—the only
function that <span class="emphasis"><em>Squish</em></span> will call—and a couple of test-specific
supporting functions that help keep the <code class="code">main</code> function
short and clear, in addition to making use of the common functions we
saw above.
</p><div class="example"><a id="idp45763464"></a><p class="title"><b>Example 5.29. The tst_check_mode Test Script's main function</b></p><div class="example-contents"><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

def main():
    startApplication('"' + os.environ["SQUISH_PREFIX"] + '/examples/java/paymentform_swt/PaymentFormSWT.jar"')
    # Import functionality needed by more than one test script
    source(findFile("scripts", "common.py"))

    # Start with the correct tab
    clickTabItem("Chec&amp;k")

    # Business rule #1: the minimum payment is $10 and the maximum is
    # $250 or the amount due whichever is smaller
    amount_due = getAmountDue()
    checkPaymentRange(10, min(250, amount_due))
    
    # Business rule #2: the check date must be no earlier than 30 days 
    # ago and no later than tomorrow, and must initially be set to
    # today. Here we just check its initial value.
    checkDateTime = waitForObject(":Check.Check Date:_DateTime")
    today = java_util_Calendar.getInstance()
    test.verify(dateTimeEqualsDate(checkDateTime, today))
    
    # Business rule #3: the Pay button is disabled (since the form's data
    # isn't yet valid), so we use findObject() without waiting
    payButtonName = ":Payment Form.Pay_org.eclipse.swt.widgets.Button"
    payButton = findObject(payButtonName)
    test.verify(not payButton.isEnabled())
    
    # Business rule #4: the check must be signed (and if it isn't we
    # will check the check box ready to test the next rule)
    ensureSignedCheckBoxIsChecked()
    
    # Business rule #5: the Pay button should be enabled since all the 
    # previous tests pass, the check is signed and now we have filled in
    # the account details
    populateCheckFields()
    payButton = waitForObject(payButtonName)
    test.verify(payButton.isEnabled())
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

function main()
{
    startApplication('"' + OS.getenv("SQUISH_PREFIX") + '/examples/java/paymentform_swt/PaymentFormSWT.jar"');
    // Import functionality needed by more than one test script
    source(findFile("scripts", "common.js"));

    // Start with the correct tab
    clickTabItem("Chec&amp;k");

    // Business rule #1: the minimum payment is $10 and the maximum is
    // $250 or the amount due whichever is smaller
    var amount_due = getAmountDue();
    checkPaymentRange(10, Math.min(250, amount_due));
    
    // Business rule #2: the check date must be no earlier than 30 days 
    // ago and no later than tomorrow, and must initially be set to
    // today. Here we just check its initial value.
    var checkDateTime = waitForObject(":Check.Check Date:_DateTime");
    var today = java_util_Calendar.getInstance();
    test.verify(dateTimeEqualsDate(checkDateTime, today));
    
    // Business rule #3: the Pay button is disabled (since the form's data
    // isn't yet valid), so we use findObject() without waiting
    var payButtonName = ":Payment Form.Pay_org.eclipse.swt.widgets.Button";
    var payButton = findObject(payButtonName);
    test.verify(!payButton.isEnabled());
    
    // Business rule #4: the check must be signed (and if it isn't we
    // will check the check box ready to test the next rule)
    ensureSignedCheckBoxIsChecked();
    
    // Business rule #5: the Pay button should be enabled since all the 
    // previous tests pass, the check is signed and now we have filled in
    // the account details
    populateCheckFields();
    var payButton = waitForObject(payButtonName);
    test.verify(payButton.isEnabled());
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

sub main
{
    startApplication("\"$ENV{'SQUISH_PREFIX'}/examples/java/paymentform_swt/PaymentFormSWT.jar\"");
    # Import functionality needed by more than one test script
    source(findFile("scripts", "common.pl"));

    # Start with the correct tab
    clickTabItem("Chec&amp;k");

    # Business rule #1: the minimum payment is $10 and the maximum is
    # $250 or the amount due whichever is smaller
    my $amount_due = getAmountDue();
    checkPaymentRange(10, $amount_due &lt; 250 ? $amount_due : 250);

    # Business rule #2: the check date must be no earlier than 30 days
    # ago and no later than tomorrow, and must initially be set to
    # today. Here we just check its initial value.
    my $checkDateTime = waitForObject(":Check.Check Date:_DateTime");
    my $today = java_util_Calendar::getInstance();
    test::verify(dateTimeEqualsDate($checkDateTime, $today));

    # Business rule #3: the Pay button is disabled (since the form's data
    # isn't yet valid), so we use findObject() without waiting
    my $payButtonName = ":Payment Form.Pay_org.eclipse.swt.widgets.Button";
    my $payButton = findObject($payButtonName);
    test::verify(!$payButton-&gt;isEnabled());

    # Business rule #4: the check must be signed (and if it isn't we
    # will check the check box ready to test the next rule)
    ensureSignedCheckBoxIsChecked();

    # Business rule #5: the Pay button should be enabled since all the
    # previous tests pass, the check is signed and now we have filled in
    # the account details
    populateCheckFields();
    $payButton = waitForObject($payButtonName);
    test::verify($payButton-&gt;isEnabled());
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

def main
    startApplication("\"#{ENV['SQUISH_PREFIX']}/examples/java/paymentform_swt/PaymentFormSWT.jar\"")
    # Import functionality needed by more than one test script
    require findFile("scripts", "common.rb")

    # Start with the correct tab
    clickTabItem("Chec&amp;k")

    # Business rule #1: the minimum payment is $10 and the maximum is
    # $250 or the amount due whichever is smaller
    amount_due = getAmountDue
    checkPaymentRange(10, min(250, amount_due))

    # Business rule #2: the check date must be no earlier than 30 days
    # ago and no later than tomorrow, and must initially be set to
    # today. Here we just check its initial value.
    checkDateTime = waitForObject(":Check.Check Date:_DateTime")
    today = LC::Java_util_Calendar.getInstance()
    Test.verify(dateTimeEqualsDate(checkDateTime, today))

    # Business rule #3: the Pay button is disabled (since the form's data
    # isn't yet valid), so we use findObject() without waiting
    payButtonName = ":Payment Form.Pay_org.eclipse.swt.widgets.Button"
    payButton = findObject(payButtonName)
    Test.verify(!payButton.isEnabled())

    # Business rule #4: the check must be signed (and if it isn't we
    # will check the check box ready to test the next rule)
    ensureSignedCheckBoxIsChecked

    # Business rule #5: the Pay button should be enabled since all the
    # previous tests pass, the check is signed and now we have filled in
    # the account details
    populateCheckFields()
    payButton = waitForObject(payButtonName)
    Test.verify(payButton.isEnabled())
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

proc main {} {
    startApplication "\"$::env(SQUISH_PREFIX)/examples/java/paymentform_swt/PaymentFormSWT.jar\""
    # Import functionality needed by more than one test script
    source [findFile "scripts" "common.tcl"]

    # Start with the correct tab
    clickTabItem "Chec&amp;k"

    # Business rule #1: the minimum payment is $10 and the maximum is
    # $250 or the amount due whichever is smaller
    set amount_due [getAmountDue]
    checkPaymentRange 10 [expr 250 &gt; $amount_due ? $amount_due : 250]
    
    # Business rule #2: the check date must be no earlier than 30 days 
    # ago and no later than tomorrow, and must initially be set to
    # today. Here we just check its initial value.
    set checkDateTime [waitForObject ":Check.Check Date:_DateTime"]
    set today [invoke java_util_Calendar getInstance]
    test verify [dateTimeEqualsDate $checkDateTime $today]
    
    # Business rule #3: the Pay button is disabled (since the form's data
    # isn't yet valid), so we use findObject() without waiting
    set payButtonName ":Payment Form.Pay_org.eclipse.swt.widgets.Button"
    set payButton [findObject $payButtonName]
    test verify [expr ![invoke $payButton isEnabled]]
    
    # Business rule #4: the check must be signed (and if it isn't we
    # will check the check box ready to test the next rule)
    ensureSignedCheckBoxIsChecked
    
    # Business rule #5: the Pay button should be enabled since all the 
    # previous tests pass, the check is signed and now we have filled in
    # the account details
    populateCheckFields
    set payButton [waitForObject $payButtonName]
    test verify [invoke $payButton isEnabled]
}
</pre></div></div></div><br class="example-break"></br><p>
The <a class="xref" href="rgs-squish.html#source-function"><code class="function">source</code></a> function (or <code class="code">require</code>
for Ruby), is used to read in a
script and execute it. Normally such a script is used purely to define
things—for example, functions—and these then become
available to the test script.
</p><p>
The first business rule is very similar to before, except that this time
we use the common <code class="code">checkPaymentRange</code> function. The second
rule shows how we can test the properties of a <code class="code">DateTime</code>
using the common <code class="code">dateTimeEqualsDate</code> function.
</p><p>
While <span class="emphasis"><em>Squish</em></span> provides access to most of the <span class="trademark">Java</span>™ API automatically,
in some cases we need to access classes that are not available by
default. In this test we need a class that is not
available by default, <code class="code">java.util.Calendar</code>. This isn't a
problem in practice since we can always register additional classes
(whether standard or our own custom classes) with the
<span class="application">squishserver</span>—see <a class="xref" href="rg-autsettings.html#rgas-javawrapping" title="7.3.8.2. Wrapping custom Java™ classes">Wrapping custom <span class="trademark">Java</span>™ classes (Section 7.3.8.2)</a> for
details. In this case we added several extra classes in
<code class="filename">java.ini</code> which has just
two lines:
</p><pre class="programlisting">
[general]
AutClasses="java.util.Calendar","java.util.Date",\
"java.text.DateFormat","java.text.SimpleDateFormat"
</pre><p>
An alternative to registering additional classes is to create instances
of them using Java's introspection facilities.
</p><p>
The third rule checks that the <span class="guibutton">Pay</span>
button is disabled since at this stage the form's data isn't valid. (For
example, the check hasn't been signed and there are no account details
filled in.) The fourth rule is used to ensure and confirm that the check
is signed—functionality that we have wholly encapsulated in the
<code class="code">ensureSignedCheckBoxIsChecked</code> function. For the fifth
rule we populate the account line edits with fake data using the
<code class="code">populateCheckFields</code> function. At the end all
the widgets have valid values so the <span class="guibutton">Pay</span> button
should be enabled, and the last line tests that it is.
</p><div class="example"><a id="idp45792832"></a><p class="title"><b>Example 5.30. The tst_check_mode Test Script's other functions</b></p><div class="example-contents"><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

def ensureSignedCheckBoxIsChecked():
    checkSignedButton = waitForObject(":Check.Check Signed_Button")
    if not checkSignedButton.getSelection():
        clickButton(checkSignedButton)
    snooze(1)
    test.verify(checkSignedButton.getSelection())

def populateCheckFields():
    bankNameText = waitForObject(":Check.Bank Name:_Text")
    type(bankNameText, "A Bank")
    bankNumberText = waitForObject(":Check.Bank Number:_Text")
    type(bankNumberText, "88-91-33X")
    accountNameText = waitForObject(":Check.Account Name:_Text")
    type(accountNameText, "An Account")
    accountNumberText = waitForObject(":Check.Account Number:_Text")
    type(accountNumberText, "932745395")
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

function ensureSignedCheckBoxIsChecked()
{
    var checkSignedButton = waitForObject(":Check.Check Signed_Button");
    if (!checkSignedButton.getSelection()) {
        clickButton(checkSignedButton);
    }
    snooze(1);
    test.verify(checkSignedButton.getSelection());
}

function populateCheckFields()
{
    var bankNameText = waitForObject(":Check.Bank Name:_Text");
    type(bankNameText, "A Bank");
    var bankNumberText = waitForObject(":Check.Bank Number:_Text");
    type(bankNumberText, "88-91-33X");
    var accountNameText = waitForObject(":Check.Account Name:_Text");
    type(accountNameText, "An Account");
    var accountNumberText = waitForObject(":Check.Account Number:_Text");
    type(accountNumberText, "932745395");
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

sub ensureSignedCheckBoxIsChecked
{
    my $checkSignedButton = waitForObject(":Check.Check Signed_Button");
    if (!$checkSignedButton-&gt;getSelection()) {
        clickButton($checkSignedButton);
    }
    test::verify($checkSignedButton-&gt;getSelection());
}

sub populateCheckFields
{
    my $bankNameText = waitForObject(":Check.Bank Name:_Text");
    type($bankNameText, "A Bank");
    my $bankNumberText = waitForObject(":Check.Bank Number:_Text");
    type($bankNumberText, "88-91-33X");
    my $accountNameText = waitForObject(":Check.Account Name:_Text");
    type($accountNameText, "An Account");
    my $accountNumberText = waitForObject(":Check.Account Number:_Text");
    type($accountNumberText, "932745395");
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

def ensureSignedCheckBoxIsChecked
    checkSignedButton = waitForObject(":Check.Check Signed_Button")
    if !checkSignedButton.getSelection()
        clickButton(checkSignedButton)
    end
    snooze(1)
    Test.verify(checkSignedButton.getSelection())
end

def populateCheckFields
    bankNameText = waitForObject(":Check.Bank Name:_Text")
    type(bankNameText, "A Bank")
    bankNumberText = waitForObject(":Check.Bank Number:_Text")
    type(bankNumberText, "88-91-33X")
    accountNameText = waitForObject(":Check.Account Name:_Text")
    type(accountNameText, "An Account")
    accountNumberText = waitForObject(":Check.Account Number:_Text")
    type(accountNumberText, "932745395")
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

proc ensureSignedCheckBoxIsChecked {} {
    set checkSignedButton [waitForObject ":Check.Check Signed_Button"]
    if {![invoke $checkSignedButton getSelection]} {
        invoke clickButton $checkSignedButton
    }
    snooze 1
    test verify [invoke $checkSignedButton getSelection]
}

proc populateCheckFields {} {
    set bankNameText [waitForObject ":Check.Bank Name:_Text"]
    invoke type $bankNameText "A Bank"
    set bankNumberText [waitForObject ":Check.Bank Number:_Text"]
    invoke type $bankNumberText "88-91-33X"
    set accountNameText [waitForObject ":Check.Account Name:_Text"]
    invoke type $accountNameText "An Account"
    set accountNumberText [waitForObject ":Check.Account Number:_Text"]
    invoke type $accountNumberText "932745395"
}
</pre></div></div></div><br class="example-break"></br><p>
Notice that we used the <a class="xref" href="rgs-javaconvenience.html#java-type-function"><code class="function">type</code></a> function to
simulate the user entering text. It is almost always better to simulate
user interaction than to set widget properties directly—after all,
it is the application's behavior as experienced by the user that we
normally need to test.
</p><p>
We are now ready to look at the last test of the form's business
logic—the test of "card" mode. Just as with "check" mode we have
refactored the <code class="code">main</code> function to keep it short and
understandable, relying on common functions and test-specific functions
in the <code class="filename">test.py</code> (or <code class="filename">test.js</code>
etc.) file to encapsulate particular tests.
</p><div class="example"><a id="idp45805688"></a><p class="title"><b>Example 5.31. The tst_card_mode Test Script's main function</b></p><div class="example-contents"><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

def main():
    startApplication('"' + os.environ["SQUISH_PREFIX"] + '/examples/java/paymentform_swt/PaymentFormSWT.jar"')
    source(findFile("scripts", "common.py"))

    # Start with the correct tab
    clickTabItem("&amp;Card")
    
    # Business rule #1: the minimum payment is $10 or 5% of the amount due
    # whichever is larger and the maximum is $5000 or the amount due 
    # whichever is smaller
    amount_due = getAmountDue()
    checkPaymentRange(max(10, amount_due / 20.0), min(5000, amount_due))

    # Make sure the card type is not Master, i.e., not the default, just
    # to show how to manipulate a Combo.
    cardTypeCombo = waitForObject(":Card.Card Type:_Combo")
    for index in range(cardTypeCombo.getItemCount()):
        if cardTypeCombo.getItem(index) != "Master":
            cardTypeCombo.select(index)
            break
    
    # Business rules #2 and 3: the issue date must be no
    # earlier than 3 years ago, and must start out at that date, and the
    # expiry date must be at least a month later than today.
    # All we check here is that both DateTimes are set to their earliest
    # valid date.
    checkCardDateDetails()

    # Business rule #4: the Pay button is disabled (since the form's data
    # isn't yet valid), so we use findObject() without waiting
    payButtonName = ":Payment Form.Pay_org.eclipse.swt.widgets.Button"
    payButton = findObject(payButtonName)
    test.verify(not payButton.isEnabled())
    
    # Business rule #5: the Pay button should be enabled since all the 
    # previous tests pass, and now we have filled in the account details
    populateCardFields()
    payButton = waitForObject(payButtonName)
    test.verify(payButton.isEnabled())
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

function main()
{
    startApplication('"' + OS.getenv("SQUISH_PREFIX") + '/examples/java/paymentform_swt/PaymentFormSWT.jar"');
    source(findFile("scripts", "common.js"));

    // Start with the correct tab
    clickTabItem("&amp;Card");
    
    // Business rule #1: the minimum payment is $10 or 5% of the
    // amount due whichever is larger and the maximum is $5000 or the
    // amount due whichever is smaller
    var amount_due = getAmountDue();
    checkPaymentRange(Math.max(10, amount_due / 20.0),
                      Math.min(5000, amount_due));

    // Make sure the card type is not Master, i.e., not the default,
    // just to show how to manipulate a Combo.
    var cardTypeCombo = waitForObject(":Card.Card Type:_Combo");
    for (var index = 0; index &lt; cardTypeCombo.getItemCount(); ++index) {
        if (cardTypeCombo.getItem(index) != "Master") {
            cardTypeCombo.select(index);
            break;
	}
    }
    
    // Business rules #2 and #3: the issue date must be no
    // earlier than 3 years ago, and must start out at that date, and the
    // expiry date must be at least a month later than today.
    // All we check here is that both DateTimes are set to their earliest
    // valid date.
    checkCardDateDetails();

    // Business rule #4: the Pay button is disabled (since the form's data
    // isn't yet valid), so we use findObject() without waiting
    var payButtonName = ":Payment Form.Pay_org.eclipse.swt.widgets.Button";
    var payButton = findObject(payButtonName);
    test.verify(!payButton.isEnabled());
    
    // Business rule #5: the Pay button should be enabled since all the 
    // previous tests pass, and now we have filled in the account details
    populateCardFields();
    var payButton = waitForObject(payButtonName);
    test.verify(payButton.isEnabled());
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

sub main
{
    startApplication("\"$ENV{'SQUISH_PREFIX'}/examples/java/paymentform_swt/PaymentFormSWT.jar\"");
    source(findFile("scripts", "common.pl"));

    # Start with the correct tab
    clickTabItem("&amp;Card");

    # Business rule #1: the minimum payment is $10 or 5% of the amount due
    # whichever is larger and the maximum is $5000 or the amount due
    # whichever is smaller
    my $amount_due = getAmountDue();
    checkPaymentRange($amount_due / 20.0 &gt; 10 ? $amount_due / 20.0 : 10,
                      $amount_due &lt; 5000 ? $amount_due : 5000);

    # Make sure the card type is not Master, i.e., not the default, just
    # to show how to manipulate a Combo.
    my $cardTypeCombo = waitForObject(":Card.Card Type:_Combo");
    for (my $index = 0; $index &lt; $cardTypeCombo-&gt;getItemCount(); ++$index) {
        if ($cardTypeCombo-&gt;getItem($index) ne "Master") {
            $cardTypeCombo-&gt;select($index);
            last;
        }
    }

    # Business rules #2 and 3: the issue date must be no
    # earlier than 3 years ago, and must start out at that date, and the
    # expiry date must be at least a month later than today.
    # All we check here is that both DateTimes are set to their earliest
    # valid date.
    checkCardDateDetails();

    # Business rule #4: the Pay button is disabled (since the form's data
    # isn't yet valid), so we use findObject() without waiting
    my $payButtonName = ":Payment Form.Pay_org.eclipse.swt.widgets.Button";
    my $payButton = findObject($payButtonName);
    test::verify(!$payButton-&gt;isEnabled());

    # Business rule #5: the Pay button should be enabled since all the
    # previous tests pass, and now we have filled in the account details
    populateCardFields();
    $payButton = waitForObject($payButtonName);
    test::verify($payButton-&gt;isEnabled());
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

def main
    startApplication("\"#{ENV['SQUISH_PREFIX']}/examples/java/paymentform_swt/PaymentFormSWT.jar\"")
    require findFile("scripts", "common.rb")

    # Start with the correct tab
    clickTabItem("&amp;Card")

    # Business rule #1: the minimum payment is $10 or 5% of the amount due
    # whichever is larger and the maximum is $5000 or the amount due
    # whichever is smaller
    amount_due = getAmountDue()
    checkPaymentRange(max(10, amount_due / 20.0), min(5000, amount_due))

    # Make sure the card type is not Master, i.e., not the default, just
    # to show how to manipulate a Combo.
    cardTypeCombo = waitForObject(":Card.Card Type:_Combo")
    for index in 0...cardTypeCombo.getItemCount()
        if cardTypeCombo.getItem(index) != "Master"
            cardTypeCombo.select(index)
            break
        end
    end

    # Business rules #2 and 3: the issue date must be no
    # earlier than 3 years ago, and must start out at that date, and the
    # expiry date must be at least a month later than today.
    # All we check here is that both DateTimes are set to their earliest
    # valid date.
    checkCardDateDetails

    # Business rule #4: the Pay button is disabled (since the form's data
    # isn't yet valid), so we use findObject() without waiting
    payButtonName = ":Payment Form.Pay_org.eclipse.swt.widgets.Button"
    payButton = findObject(payButtonName)
    Test.verify(!payButton.isEnabled())

    # Business rule #5: the Pay button should be enabled since all the
    # previous tests pass, and now we have filled in the account details
    populateCardFields
    payButton = waitForObject(payButtonName)
    Test.verify(payButton.isEnabled())
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

proc main {} {
    startApplication "\"$::env(SQUISH_PREFIX)/examples/java/paymentform_swt/PaymentFormSWT.jar\""
    source [findFile "scripts" "common.tcl"]

    # Start with the correct tab
    clickTabItem "&amp;Card"
    
    # Business rule #1: the minimum payment is $10 or 5% of the amount 
    # due whichever is larger and the maximum is $5000 or the amount
    # due whichever is smaller
    set amount_due [getAmountDue]
    set five_percent [expr $amount_due / 20.0]
    set minimum [expr 10 &gt; $five_percent ? 10 : $five_percent]
    set maximum [expr 5000 &gt; $amount_due ? $amount_due : 5000]
    checkPaymentRange $minimum $maximum

    # Make sure the card type is not Master, i.e., not the default, just
    # to show how to manipulate a Combo.
    set cardTypeCombo [waitForObject ":Card.Card Type:_Combo"]
    set count [invoke $cardTypeCombo getItemCount]
    for {set index 0} {$index &lt; $count} {incr index} {
        if {[invoke $cardTypeCombo getItem $index] != "Master"} {
            invoke $cardTypeCombo select $index
            break
        }
    }
    
    # Business rules #2 and 3: the issue date must be no
    # earlier than 3 years ago, and must start out at that date, and the
    # expiry date must be at least a month later than today.
    # All we check here is that both DateTimes are set to their earliest
    # valid date.
    checkCardDateDetails

    # Business rule #4: the Pay button is disabled (since the form's data
    # isn't yet valid), so we use findObject() without waiting
    set payButtonName ":Payment Form.Pay_org.eclipse.swt.widgets.Button"
    set payButton [findObject $payButtonName]
    test verify [expr ![invoke $payButton isEnabled]]
    
    # Business rule #5: the Pay button should be enabled since all the 
    # previous tests pass, and now we have filled in the account details
    populateCardFields
    set payButton [waitForObject $payButtonName]
    test verify [invoke $payButton isEnabled]
}
</pre></div></div></div><br class="example-break"></br><p>
We start by setting the correct tab and then for the first business rule
we check the payment range—this is the same as we did for the
other modes.
</p><p>
Although it isn't necessary for testing the business rules, we change
the item in the <code class="code">Combo</code> widget just to show how it is done.
</p><p>
The second and third business rules are a bit involved so we encapsulate
them in the test-specific <code class="code">checkCardDateDetails</code> function.
</p><p>
Initially the <span class="guibutton">Pay</span> button should be
disabled, so business rule four checks for this. For the fifth business
rule, we provide some fake data for the card
account name and number using the <code class="code">populateCardFields</code>
function, and since the dates are in range the
<span class="guibutton">Pay</span> button should now be enabled as our last
check verifies.
</p><div class="example"><a id="idp45831864"></a><p class="title"><b>Example 5.32. The tst_card_mode Test Script's other functions</b></p><div class="example-contents"><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

def checkCardDateDetails():
    tabFolderName = ":Payment Form_org.eclipse.swt.widgets.TabFolder"
    tabFolder = waitForObject(tabFolderName)
    for index in range(tabFolder.getItemCount()):
        tabItem = tabFolder.getItem(index)
        if tabItem.getText() == "&amp;Card":
            break
    dateTimes = []
    control = tabItem.getControl()
    children = control.getChildren()
    for index in range(children.length):
        child = children.at(index)
        if (child.getClass().toString() ==
            "class org.eclipse.swt.widgets.DateTime"):
            dateTimes.append(child)
    test.verify(len(dateTimes) == 2)

    earliestIssueDate = java_util_Calendar.getInstance()
    earliestIssueDate.add(java_util_Calendar.YEAR, -3)
    test.verify(dateTimeEqualsDate(dateTimes[0], earliestIssueDate))
    earliestExpiryDate = java_util_Calendar.getInstance()
    earliestExpiryDate.add(java_util_Calendar.MONTH, 1)
    test.verify(dateTimeEqualsDate(dateTimes[1], earliestExpiryDate))

def populateCardFields():
    cardAccountNameText = waitForObject(":Card.Account Name:_Text")
    mouseClick(cardAccountNameText, 10, 10, 0, Button.Button1)
    type(cardAccountNameText, "An Account")
    cardAccountNumberText = waitForObject(":Card.Account Number:_Text")
    type(cardAccountNumberText, "1343 876 326 1323 32")
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

function checkCardDateDetails()
{
    var tabFolderName = ":Payment Form_org.eclipse.swt.widgets.TabFolder";
    var tabFolder = waitForObject(tabFolderName);
    for (var index = 0; index &lt; tabFolder.getItemCount(); ++index) {
        var tabItem = tabFolder.getItem(index);
        if (tabItem.getText() == "&amp;Card") {
            break;
	}
    }
    var dateTimes = [];
    var control = tabItem.getControl();
    var children = control.getChildren();
    for (var index = 0; index &lt;  children.length; ++index) {
        var child = children.at(index);
        if (child.getClass().toString() ==
            "class org.eclipse.swt.widgets.DateTime") {
            dateTimes.push(child);
	}
    }
    test.verify(dateTimes.length == 2);

    var earliestIssueDate = java_util_Calendar.getInstance();
    earliestIssueDate.add(java_util_Calendar.YEAR, -3);
    test.verify(dateTimeEqualsDate(dateTimes[0], earliestIssueDate));
    var earliestExpiryDate = java_util_Calendar.getInstance();
    earliestExpiryDate.add(java_util_Calendar.MONTH, 1);
    test.verify(dateTimeEqualsDate(dateTimes[1], earliestExpiryDate));
}

function populateCardFields()
{
    var cardAccountNameText = waitForObject(":Card.Account Name:_Text");
    mouseClick(cardAccountNameText, 10, 10, 0, Button.Button1);
    type(cardAccountNameText, "An Account");
    var cardAccountNumberText = waitForObject(":Card.Account Number:_Text");
    type(cardAccountNumberText, "1343 876 326 1323 32");
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

sub checkCardDateDetails
{
    my $tabFolderName = ":Payment Form_org.eclipse.swt.widgets.TabFolder";
    my $tabFolder = waitForObject($tabFolderName);
    my $tabItem;
    for (my $index = 0; $index &lt; $tabFolder-&gt;getItemCount(); ++$index) {
        $tabItem = $tabFolder-&gt;getItem($index);
        if ($tabItem-&gt;getText() eq "&amp;Card") {
            last;
	}
    }
    my @dateTimes = ();
    my $control = $tabItem-&gt;getControl();
    my $children = $control-&gt;getChildren();
    for (my $index = 0; $index &lt; $children-&gt;length(); ++$index) {
        my $child = $children-&gt;at($index);
        if ($child-&gt;getClass()-&gt;toString() eq
	    "class org.eclipse.swt.widgets.DateTime") {
            push @dateTimes, $child;
	}
    }
    test::verify(@dateTimes == 2);

    my $earliestIssueDate = java_util_Calendar::getInstance();
    $earliestIssueDate-&gt;add(java_util_Calendar-&gt;YEAR, -3);
    test::verify(dateTimeEqualsDate($dateTimes[0], $earliestIssueDate));
    my $earliestExpiryDate = java_util_Calendar::getInstance();
    $earliestExpiryDate-&gt;add(java_util_Calendar-&gt;MONTH, 1);
    test::verify(dateTimeEqualsDate($dateTimes[1], $earliestExpiryDate));
}

sub populateCardFields
{
    my $cardAccountNameText = waitForObject(":Card.Account Name:_Text");
    mouseClick($cardAccountNameText, 10, 10, 0, Button::Button1);
    type($cardAccountNameText, "An Account");
    my $cardAccountNumberText = waitForObject(
        ":Card.Account Number:_Text");
    type($cardAccountNumberText, "1343 876 326 1323 32");
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

def checkCardDateDetails
    tabFolderName = ":Payment Form_org.eclipse.swt.widgets.TabFolder"
    tabFolder = waitForObject(tabFolderName)
    for index in 0...tabFolder.getItemCount()
        tabItem = tabFolder.getItem(index)
        if tabItem.getText() == "&amp;Card"
            break
        end
    end
    dateTimes = []
    control = tabItem.getControl()
    children = control.getChildren()
    for index in 0...children.length
        child = children.at(index)
        if (child.getClass().toString() ==
        "class org.eclipse.swt.widgets.DateTime")
            dateTimes &lt;&lt; child
        end
    end
    Test.verify(dateTimes.length == 2)

    earliestIssueDate = LC::Java_util_Calendar.getInstance()
    earliestIssueDate.add(LC::Java_util_Calendar.YEAR, -3)
    Test.verify(dateTimeEqualsDate(dateTimes[0], earliestIssueDate))
    earliestExpiryDate = LC::Java_util_Calendar.getInstance()
    earliestExpiryDate.add(LC::Java_util_Calendar.MONTH, 1)
    Test.verify(dateTimeEqualsDate(dateTimes[1], earliestExpiryDate))
end

def populateCardFields
    cardAccountNameText = waitForObject(":Card.Account Name:_Text")
    mouseClick(cardAccountNameText, 10, 10, 0, Button::BUTTON1)
    type(cardAccountNameText, "An Account")
    cardAccountNumberText = waitForObject(":Card.Account Number:_Text")
    type(cardAccountNumberText, "1343 876 326 1323 32")
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

proc checkCardDateDetails {} {
    set tabFolderName ":Payment Form_org.eclipse.swt.widgets.TabFolder"
    set tabFolder [waitForObject $tabFolderName]
    set count [invoke $tabFolder getItemCount]
    for {set index 0} {$index &lt; $count} {incr index} {
        set tabItem [invoke $tabFolder getItem $index]
        if {[invoke $tabItem getText] == "&amp;Card"} {
            break
        }
    }
    set dateTimes {}
    set control [invoke $tabItem getControl]
    set children [invoke $control getChildren]
    set count [property get $children length]
    for {set index 0} {$index &lt; $count} {incr index} {
        set child [invoke $children at $index]
        set className [invoke [invoke $child getClass] toString]
        if {$className == "class org.eclipse.swt.widgets.DateTime"} {
            lappend dateTimes $child
        }
    }
    test compare [llength $dateTimes] 2

    set earliestIssueDate [invoke java_util_Calendar getInstance]
    invoke $earliestIssueDate add [property get java_util_Calendar YEAR] -3
    set issueDateTime [lindex $dateTimes 0]
    test verify [dateTimeEqualsDate $issueDateTime $earliestIssueDate]
    set earliestExpiryDate [invoke java_util_Calendar getInstance]
    invoke $earliestExpiryDate add [property get java_util_Calendar \
        MONTH] 1
    set expiryDateTime [lindex $dateTimes 1]
    test verify [dateTimeEqualsDate $expiryDateTime $earliestExpiryDate]
}

proc populateCardFields {} {
    set cardAccountNameText [waitForObject ":Card.Account Name:_Text"]
    invoke mouseClick $cardAccountNameText 10 10 0 [enum Button Button1]
    invoke type $cardAccountNameText "An Account"
    set cardAccountNumberText [waitForObject \
        ":Card.Account Number:_Text"]
    invoke type $cardAccountNumberText "1343 876 326 1323 32"
}
</pre></div></div></div><br class="example-break"></br><p>
In the <code class="code">checkCardDateDetails</code> function,
for the issue date and expiry date <code class="code">DateTime</code> widgets we want
to check that they are both set to their earliest valid date. Rather
than identifying them by name we have used introspection to find them.
We begin by getting a reference to the <code class="code">TabFolder</code>.
Then we use the tab folder's API to iterate over each
<code class="code">TabItem</code> until we get the one we want. We then retrieve the
tab item's array of child widgets—such arrays have a
<code class="code">length</code> property and an <code class="code">at</code> method and we use
these to iterate over every child item and to keep a reference to the
two <code class="code">DateTime</code> items.
</p><p>
Once we have the date time widgets we check that there are exactly two
of them and that they are both set to the expected dates.
</p><p>
For the <code class="code">populateCardFields</code> function we use the <a class="xref" href="rgs-javaconvenience.html#java-type-function"><code class="function">type</code></a> function to enter the fake data.
</p><p>
We have now completed our review of testing business rules using
stateful and single-valued widgets. <span class="trademark">Java</span>™/SWT has many other similar
widgets but all of them are identified and tested using the same
techniques we have used here.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ug-testing-lists-tables-and-trees-swt"></a>5.4.6.2.2. How to Test List, Table, and Tree widgets (<span class="trademark">Java</span>™/SWT)</h5></div></div></div><p>
In this section we will see how to iterate over every item in <span class="trademark">Java</span>™
SWT's List, Table, and Tree widgets, and how to retrieve information
from each item, such as their text and checked and selected statuses.
</p><p>
Although the examples only output each item's text and checked and
selected statuses to Squish's log, they are very easy to adapt to do
more sophisticated testing, such as comparing actual values against
expected values.
</p><p>
All the code shown in this section is taken from the
<code class="filename">examples/java/itemviews_swt</code> example's test suites.
</p><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a id="how-to-test-list"></a>5.4.6.2.2.1. How to Test List</h6></div></div></div><p>
It is very easy to iterate over all the items in a List and retrieve
their texts and selected status, as the following test example shows:
</p><div class="example"><a id="idp45861048"></a><p class="title"><b>Example 5.33. The tst_list Test Script</b></p><div class="example-contents"><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">
import os
def main():
    startApplication('"' + os.environ["SQUISH_PREFIX"] + '/examples/java/itemviews_swt/ItemViewsSWT.jar"')
    listWidgetName = ":Item Views_org.eclipse.swt.widgets.List"
    listWidget = waitForObject(listWidgetName)
    for row in range(listWidget.getItemCount()):
        text = listWidget.getItem(row)
        selected = ""
        if listWidget.isSelected(row):
            selected = " +selected"
        test.log("(%d) '%s'%s" % (row, text, selected))

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">
function main()
{
    startApplication('"' + OS.getenv("SQUISH_PREFIX") + '/examples/java/itemviews_swt/ItemViewsSWT.jar"');
    var listWidgetName = ":Item Views_org.eclipse.swt.widgets.List";
    var listWidget = waitForObject(listWidgetName);
    for (var row = 0; row &lt; listWidget.getItemCount(); ++row) {
        var text = listWidget.getItem(row);
        var selected = "";
        if (listWidget.isSelected(row)) {
            selected = " +selected";
        }
        test.log("(" + String(row) + ") '" + text + "'" + selected);
    }
}

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

sub main
{
    startApplication("\"$ENV{'SQUISH_PREFIX'}/examples/java/itemviews_swt/ItemViewsSWT.jar\"");
    my $listWidgetName = ":Item Views_org.eclipse.swt.widgets.List";
    my $listWidget = waitForObject($listWidgetName);
    for (my $row = 0; $row &lt; $listWidget-&gt;getItemCount(); ++$row) {
        my $text = $listWidget-&gt;getItem($row);
        my $selected = "";
        if ($listWidget-&gt;isSelected($row)) {
            $selected = " +selected";
        }
        test::log("($row) '$text'$selected");
    }
}

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">
# encoding: UTF-8
require 'squish'

include Squish

def main
    startApplication("\"#{ENV['SQUISH_PREFIX']}/examples/java/itemviews_swt/ItemViewsSWT.jar\"")
    listWidgetName = ":Item Views_org.eclipse.swt.widgets.List"
    listWidget = waitForObject(listWidgetName)
    for row in 0...listWidget.getItemCount()
        text = listWidget.getItem(row)
        selected = ""
        if listWidget.isSelected(row)
            selected = " +selected"
        end
        Test.log("(#{row}) '#{text}'#{selected}")
    end
end

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">
proc main {} {
    startApplication "\"$::env(SQUISH_PREFIX)/examples/java/itemviews_swt/ItemViewsSWT.jar\""
    set listWidgetName ":Item Views_org.eclipse.swt.widgets.List"
    set listWidget [waitForObject $listWidgetName]
    for {set row 0} {$row &lt; [invoke $listWidget getItemCount]} \
        {incr row} {
        set text [invoke $listWidget getItem $row]
        set selected ""
        if {[invoke $listWidget isSelected $row]} {
            set selected " +selected"
        }
        test log "($row) '$text'$selected"
    }
}

</pre></div></div></div><br class="example-break"></br><p>
All the output goes to <span class="emphasis"><em>Squish</em></span>'s log, but clearly it is easy to
change the script to test against a list of specific values and so on.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a id="how-to-test-table"></a>5.4.6.2.2.2. How to Test Table</h6></div></div></div><p>
It is also very easy to iterate over all the items in a Table and
retrieve their texts and checked and selected statuses, as the following
test example shows:
</p><div class="example"><a id="idp45870296"></a><p class="title"><b>Example 5.34. The tst_table Test Script</b></p><div class="example-contents"><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">
import os
def main():
    startApplication('"' + os.environ["SQUISH_PREFIX"] + '/examples/java/itemviews_swt/ItemViewsSWT.jar"')
    tableWidgetName = ":Item Views_org.eclipse.swt.widgets.Table"
    tableWidget = waitForObject(tableWidgetName)
    for row in range(tableWidget.getItemCount()):
        item = tableWidget.getItem(row)
        checked = ""
        if item.getChecked():
            checked = " +checked"
        selected = ""
        if tableWidget.isSelected(row):
            selected = " +selected"
        texts = []
        for column in range(tableWidget.getColumnCount()):
            texts.append(item.getText(column))
        test.log("(%d, 0) '%s'%s%s" % (row, "|".join(texts), checked,
            selected))

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">
function main()
{
    startApplication('"' + OS.getenv("SQUISH_PREFIX") + '/examples/java/itemviews_swt/ItemViewsSWT.jar"');
    var tableWidgetName = ":Item Views_org.eclipse.swt.widgets.Table";
    var tableWidget = waitForObject(tableWidgetName);
    for (var row = 0; row &lt; tableWidget.getItemCount(); ++row) {
        var item = tableWidget.getItem(row);
        var checked = "";
        if (item.getChecked()) {
            checked = " +checked";
        }
        var selected = "";
        if (tableWidget.isSelected(row)) {
            selected = " +selected";
        }
        var text = "";
        for (var column = 0; column &lt; tableWidget.getColumnCount();
            ++column) {
            if (text != "") {
                text += "|";
            }
            text += item.getText(column);
        }
        test.log("(" + String(row) + ", 0) '" + text + "'" + checked +
            selected);
    }
}

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

sub main
{
    startApplication("\"$ENV{'SQUISH_PREFIX'}/examples/java/itemviews_swt/ItemViewsSWT.jar\"");
    my $tableWidgetName = ":Item Views_org.eclipse.swt.widgets.Table";
    my $tableWidget = waitForObject($tableWidgetName);
    for (my $row = 0; $row &lt; $tableWidget-&gt;getItemCount(); ++$row) {
        my $item = $tableWidget-&gt;getItem($row);
        my $checked = "";
        if ($item-&gt;getChecked()) {
            $checked = " +checked";
        }
        my $selected = "";
        if ($tableWidget-&gt;isSelected($row)) {
            $selected = " +selected";
        }
        my @texts = ();
        for (my $column = 0; $column &lt; $tableWidget-&gt;getColumnCount();
            ++$column) {
            push @texts, $item-&gt;getText($column);
        }
        $text = join("|", @texts);
        test::log("($row, 0) '$text'$checked$selected");
    }
}

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">
# encoding: UTF-8
require 'squish'
include Squish

def main
    startApplication("\"#{ENV['SQUISH_PREFIX']}/examples/java/itemviews_swt/ItemViewsSWT.jar\"")
    tableWidgetName = ":Item Views_org.eclipse.swt.widgets.Table"
    tableWidget = waitForObject(tableWidgetName)
    for row in 0...tableWidget.getItemCount()
        item = tableWidget.getItem(row)
        checked = ""
        if item.getChecked()
            checked = " +checked"
        end
        selected = ""
        if tableWidget.isSelected(row)
            selected = " +selected"
        end
        texts = []
        for column in 0...tableWidget.getColumnCount()
            texts &lt;&lt; item.getText(column)
        end
        Test.log("(#{row}, 0) '%s'#{checked}#{selected}" % texts.join("|"))
    end
end

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">
proc main {} {
    startApplication "\"$::env(SQUISH_PREFIX)/examples/java/itemviews_swt/ItemViewsSWT.jar\""
    set tableWidgetName ":Item Views_org.eclipse.swt.widgets.Table"
    set tableWidget [waitForObject $tableWidgetName]
    for {set row 0} {$row &lt; [invoke $tableWidget getItemCount]} \
        {incr row} {
        set item [invoke $tableWidget getItem $row]
        set checked ""
        if {[invoke $item getChecked]} {
            set checked " +checked"
        }
        set selected ""
        if {[invoke $tableWidget isSelected $row]} {
            set selected " +selected"
        }
        set text {}
        for {set column 0} {$column &lt; [invoke $tableWidget getColumnCount]} \
            {incr column} {
            lappend text [invoke $item getText $column]
        }
        set text [join $text "|"]
        test log "($row, 0) '$text'$checked$selected"
    }
}

</pre></div></div></div><br class="example-break"></br><p>
In this example we only put texts in each <code class="code">TableItem</code>'s first
column which is why we hard-coded column 0 in the output. Nonetheless
the code shows how to access the texts from all the columns, so the code
should be easy to adapt.
</p><p>
Again, all the output goes to <span class="emphasis"><em>Squish</em></span>'s log, and clearly it is
easy to change the script to test against a specific values and so on.
</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip: Table Verification
Points"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></img></td><th align="left"><a id="table.verification.points3"></a>Table Verification
Points</th></tr><tr><td align="left" valign="top"><p>
It is possible to use table
verification points to check an entire table. See
<a class="xref" href="ug-vps.html#ugv-table" title="5.22.2. How to Create and Use Table Verifications">How to Create and Use Table Verifications (Section 5.22.2)</a>.
</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a id="testing-tree-widget-java-swt"></a>5.4.6.2.2.3. How to Test Tree</h6></div></div></div><p>
It is slightly more tricky to iterate over all the items in a Tree and
retrieve their texts and checked and selected statuses—since a
tree is a recursive structure. Nonetheless, it is perfectly possible, as
the following test example shows:
</p><div class="example"><a id="idp45884392"></a><p class="title"><b>Example 5.35. The tst_tree Test Script</b></p><div class="example-contents"><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">
import os
def checkAnItem(indent, item, selection):
    if indent &gt; -1:
        checked = selected = ""
        if item.getChecked():
            checked = " +checked"
        for i in range(selection.length):
            if selection.at(i) == item:
                selected = " +selected"
                break
        test.log("|%s'%s'%s%s" % (" " * indent, item.getText(), checked,
            selected))
    else:
        indent = -4
    for row in range(item.getItemCount()):
        child = item.getItem(row)
        checkAnItem(indent + 4, child, selection)
        
def main():
    startApplication('"' + os.environ["SQUISH_PREFIX"] + '/examples/java/itemviews_swt/ItemViewsSWT.jar"')
    treeWidgetName = ":Item Views_org.eclipse.swt.widgets.Tree"
    treeWidget = waitForObject(treeWidgetName)
    checkAnItem(-1, treeWidget, treeWidget.getSelection())

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">
function checkAnItem(indent, item, selection)
{
    if (indent &gt; -1) {
        var checked = "";
        var selected = "";
        if (item.getChecked()) {
            checked = " +checked";
        }
        for (var i = 0; i &lt; selection.length; ++i) {
            if (selection.at(i) == item) {
                selected = " +selected";
                break;
            }
        }
        var offset = "";
        for (var i = 0; i &lt; indent; ++i) {
            offset = offset.concat(" ");
        }
        test.log("|" + offset + "'" + item.getText() + "'" + checked +
            selected);
    }
    else {
        indent = -4;
    }
    for (var row = 0; row &lt; item.getItemCount(); ++row) {
        var child = item.getItem(row);
        checkAnItem(indent + 4, child, selection);
    }
}
        
function main()
{
    startApplication('"' + OS.getenv("SQUISH_PREFIX") + '/examples/java/itemviews_swt/ItemViewsSWT.jar"');
    var treeWidgetName = ":Item Views_org.eclipse.swt.widgets.Tree";
    var treeWidget = waitForObject(treeWidgetName);
    checkAnItem(-1, treeWidget, treeWidget.getSelection());
}

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

sub checkAnItem
{
    my ($indent, $item, $selection) = @_;
    if ($indent &gt; -1) {
        my $checked = "";
        my $selected = "";
        if ($item-&gt;getChecked()) {
            $checked = " +checked";
        }
        my $padding = " " x $indent;
        for (my $i = 0; $i &lt; $selection-&gt;length; ++$i) {
            if ($selection-&gt;at($i) eq $item) {
                $selected = " +selected";
                last;
            }
        }
        test::log("|$padding'" . $item-&gt;getText() . "'$checked$selected");
    }
    else {
        $indent = -4;
    }
    for (my $row = 0; $row &lt; $item-&gt;getItemCount(); ++$row) {
        my $child = $item-&gt;getItem($row);
        checkAnItem($indent + 4, $child, $selection);
    }
}

sub main()
{
    startApplication("\"$ENV{'SQUISH_PREFIX'}/examples/java/itemviews_swt/ItemViewsSWT.jar\"");
    my $treeWidgetName = ":Item Views_org.eclipse.swt.widgets.Tree";
    my $treeWidget = waitForObject($treeWidgetName);
    checkAnItem(-1, $treeWidget, $treeWidget-&gt;getSelection());
}

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">
# encoding: UTF-8
require 'squish'
include Squish

def checkAnItem(indent, item, selection)
    if indent &gt; -1
        checked = selected = ""
        if item.getChecked()
            checked = " +checked"
        end
        for i in 0...selection.length
            if selection.at(i) == item
                selected = " +selected"
                break
            end
        end
        Test.log("|%s'%s'%s%s" % [" " * indent, item.getText(), checked,
            selected])
    else
        indent = -4
    end
    for row in 0...item.getItemCount()
        child = item.getItem(row)
        checkAnItem(indent + 4, child, selection)
    end
end

def main
    startApplication("\"#{ENV['SQUISH_PREFIX']}/examples/java/itemviews_swt/ItemViewsSWT.jar\"")
    treeWidgetName = ":Item Views_org.eclipse.swt.widgets.Tree"
    treeWidget = waitForObject(treeWidgetName)
    checkAnItem(-1, treeWidget, treeWidget.getSelection())
end

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">
proc checkAnItem {indent item selection} {
    if {$indent &gt; -1} {
        set checked ""
        set selected ""
        if {[invoke $item getChecked]} {
            set checked " +checked"
        }
        set offset [string repeat " " $indent]
        for {set i 0} {$i &lt; [property get $selection length]} {incr i} {
            if {[invoke [invoke $selection at $i] toString] == \
                [invoke $item toString]} {
                set selected " +selected"
                break
            }
        }
        set text [invoke $item getText]
        test log "|$offset'$text'$checked$selected"
    } else {
        set indent -4
    }
    for {set row 0} {$row &lt; [invoke $item getItemCount]} {incr row} {
        set child [invoke $item getItem $row]
        set offset [expr $indent + 4]
        checkAnItem $offset $child $selection
    }
}
        
proc main {} {
    startApplication "\"$::env(SQUISH_PREFIX)/examples/java/itemviews_swt/ItemViewsSWT.jar\""
    set treeWidgetName ":Item Views_org.eclipse.swt.widgets.Tree"
    set treeWidget [waitForObject $treeWidgetName]
    checkAnItem -1 $treeWidget [invoke $treeWidget getSelection]
}

</pre></div></div></div><br class="example-break"></br><p>
The key difference from List and Table is that since Trees are recursive
it is easiest if we ourselves use recursion to iterate over all the
items. Unfortunately, the Java/SWT Tree's API does not allow us to ask
if a particular item is selected, so for each item we must iterate over
the array of selected items returned by
the <code class="code">Tree.getSelection</code> method. To do this we pass the array to the
<code class="code">checkAnItem</code> function in the <code class="code">selection</code>
parameter. Then we use the array's <code class="code">length</code> property to see
how many items we can iterate over, and its <code class="code">at</code> method to
retrieve each item in turn. If we find a matching item we know that it
is selected so we add this information to the text we print. (See also,
<a class="xref" href="ugs-javaapi.html#ugsjava-arrays" title="5.4.5. How to Create and Access Java™ Arrays">How to Create and Access <span class="trademark">Java</span>™ Arrays (Section 5.4.5)</a>.)
</p><p>
Just as with the previous examples, all the output goes to <span class="emphasis"><em>Squish</em></span>'s
log, although it is easy to adapt the script to perform other tests.
</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ug-testing-table-using-external-data"></a>5.4.6.2.3. How to Test the Table Widget and Use External Data Files
(Java/SWT)</h5></div></div></div><p>
In this section we will see how to test the
<code class="filename">CsvTableSWT.java</code> program shown below. This program
uses a Table to present the contents of a <code class="filename">.csv</code>
(comma-separated values) file, and provides some basic functionality for
manipulating the data—inserting and deleting rows and swapping
columns.
<sup>[<a href="ugs-qtapi.html#ftn.test.data.format.footnote" class="footnoteref">20</a>]</sup>
As we review the tests we will learn how to import test data, manipulate
the data, and compare what the Table shows with what we expect its
contents to be. And since the CSV Table program is a main-window-style
application, we will also learn how to test that menu options behave as
expected.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/ug-csvtable-java-swt.png" align="middle"></img><div class="caption">The CSV Table program.</div></div></div><p>
The source code for this example is in the directory
<code class="filename">SQUISHDIR/examples/java/csvtable_swt</code>, and the test
suites are in subdirectories underneath—for example, the Python
version of the tests is in the directory
<code class="filename">SQUISHDIR/examples/java/csvtable_swt/suite_py</code>, and
the JavaScript version of the tests is in
<code class="filename">SQUISHDIR/examples/java/csvtable_swt/suite_js</code>, and
so on.
</p><p>
The first test we will look at is deceptively simple and consists of
just a few statements. This simplicity is achieved by putting almost all
of the functionality into a shared script, to avoid code duplication.
Here is the code:
</p><div class="example"><a id="idp45907008"></a><p class="title"><b>Example 5.36. The tst_loading Test Script</b></p><div class="example-contents"><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">
import os

def main():
    startApplication('"' + os.environ["SQUISH_PREFIX"] + '/examples/java/csvtable_swt/CsvTableSWT.jar"')
    source(findFile("scripts", "common.py"))
    filename = "before.csv"
    doFileOpen(filename, "")
    table = waitForObject("{isvisible='true' "
        "type='org.eclipse.swt.widgets.Table'}")
    compareTableWithDataFile(table, filename)
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">
function main()
{
    startApplication('"' + OS.getenv("SQUISH_PREFIX") + '/examples/java/csvtable_swt/CsvTableSWT.jar"');
    source(findFile("scripts", "common.js"));
    var filename = "before.csv";
    doFileOpen(filename, "");
    var table = waitForObject("{isvisible='true' " +
        "type='org.eclipse.swt.widgets.Table'}");
    compareTableWithDataFile(table, filename);
}

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

sub main
{
    startApplication("\"$ENV{'SQUISH_PREFIX'}/examples/java/csvtable_swt/CsvTableSWT.jar\"");
    source(findFile("scripts", "common.pl"));
    my $filename = "before.csv";
    doFileOpen($filename);
    my $table = waitForObject("{isvisible='true' " .
        "type='org.eclipse.swt.widgets.Table'}");
    compareTableWithDataFile($table, $filename);
}

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">
# encoding: UTF-8
require 'squish'
include Squish

def main
    startApplication("\"#{ENV['SQUISH_PREFIX']}/examples/java/csvtable_swt/CsvTableSWT.jar\"")
    require findFile("scripts", "common.rb")
    filename = "before.csv"
    doFileOpen(filename, "")
    table = waitForObject("{isvisible='true' " +
    "type='org.eclipse.swt.widgets.Table'}")
    compareTableWithDataFile(table, filename)
end

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">
proc main {} {
    startApplication "\"$::env(SQUISH_PREFIX)/examples/java/csvtable_swt/CsvTableSWT.jar\""
    source [findFile "scripts" "common.tcl"]
    set filename "before.csv"
    doFileOpen $filename ""
    set table [waitForObject "{isvisible='true' \
        type='org.eclipse.swt.widgets.Table'}"]
    compareTableWithDataFile $table $filename
}

</pre></div></div></div><br class="example-break"></br><p>
We begin by starting the application—in the case of Java/SWT
programs this is a shell script or <code class="code">.bat</code> file that sets up
the correct environment and executes the AUT. Once the AUT is running we
next load the script that contains common functionality, just as we did
in an earlier section. Then we call a custom <code class="code">doFileOpen</code>
function that tells the program to open the given file—and this is
done through the user interface as we will see. (The first argument is
the name of the file to open and the second argument is the name of the
current file, which in this case is an empty string since we are
starting the AUT from scratch.) Next we get a reference to the Table
using the <a class="xref" href="rgs-squish.html#waitForObject-function"><code class="function">waitForObject</code></a> function, and finally
we check that the Table's contents match the contents of the data file
held amongst the test suite's test data. Note that both the CSV Table
program and <span class="emphasis"><em>Squish</em></span> load and parse the data file using their own
completely independent code. (See <a class="xref" href="ug-shareddata.html" title="5.23. How to Create and Use Shared Data and Shared Scripts">How to Create and Use Shared Data and Shared Scripts (Section 5.23)</a> for
how to import test data into <span class="emphasis"><em>Squish</em></span>.)
</p><p>
Now we will look at the custom functions we have used in the above test.
</p><div class="example"><a id="idp45915632"></a><p class="title"><b>Example 5.37. Extracts from the Shared Scripts</b></p><div class="example-contents"><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

def doFileOpen(fileToOpen, currentFile):
    invokeMenuItem("File", "Open...", currentFile)
    chooseFile(waitForObject(":SWT"), fileToOpen)

def invokeMenuItem(menu, item, filename):
    if filename:
        filename = " - " + filename
    menuName = ("{caption='%s' container=':CSV Table%s_org."
        "eclipse.swt.widgets.Menu' "
        "type='org.eclipse.swt.widgets.MenuItem'}" % (menu, filename))
    waitForObject(menuName)
    activateItem(menuName)
    menuItemName = ("{caption='%s' type='org.eclipse.swt.widgets.MenuItem'}" % item)
    waitForObject(menuItemName)
    activateItem(menuItemName)

def compareTableWithDataFile(table, filename):
    for row, record in enumerate(testData.dataset(filename)):
        item = table.getItem(row)
        for column, name in enumerate(testData.fieldNames(record)):
            test.compare(testData.field(record, name), item.getText(column))
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

function doFileOpen(fileToOpen, currentFile)
{
    invokeMenuItem("File", "Open...", currentFile);
    chooseFile(waitForObject(":SWT"), fileToOpen);
}

function invokeMenuItem(menu, item, filename)
{
    if (filename) {
        filename = " - " + filename;
    }
    var menuName = "{caption='" + menu + "'" +
            " container=':CSV Table" + filename +
            "_org.eclipse.swt.widgets.Menu' " +
            "type='org.eclipse.swt.widgets.MenuItem'}";
    waitForObject(menuName);
    activateItem(menuName);
    var menuItemName = "{caption='" + item + "'" +
            " type='org.eclipse.swt.widgets.MenuItem'}";
    waitForObject(menuItemName);
    activateItem(menuItemName);
}

function compareTableWithDataFile(table, filename)
{
    var records = testData.dataset(filename);
    for (var row = 0; row &lt; records.length; ++row) {
        var item = table.getItem(row);
        columnNames = testData.fieldNames(records[row]);
        for (var column = 0; column &lt; columnNames.length; ++column) {
            test.compare(testData.field(records[row], column),
                item.getText(column));
        }
    }
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

sub doFileOpen
{
    my ($fileToOpen, $currentFile) = @_;
    invokeMenuItem("File", "Open...", $currentFile);
    chooseFile(waitForObject(":SWT"), $fileToOpen);
}

sub invokeMenuItem
{
    my ($menu, $item, $filename) = @_;
    if ($filename) {
        $filename = " - " . $filename;
    }
    my $menuName = "{caption='$menu' " .
            "container=':CSV Table${filename}_org.eclipse.swt." .
            "widgets.Menu' type='org.eclipse.swt.widgets.MenuItem'}";
    waitForObject($menuName);
    activateItem($menuName);
    my $menuItemName = "{caption='$item' " .
        "type='org.eclipse.swt.widgets.MenuItem'}";
    waitForObject($menuItemName);
    activateItem($menuItemName);
}

sub compareTableWithDataFile
{
    my ($table, $filename) = @_;
    my @records = testData::dataset($filename);
    for (my $row = 0; $row &lt; scalar(@records); $row++) {
        my $item = $table-&gt;getItem($row);
        my @columnNames = testData::fieldNames($records[$row]);
        for (my $column = 0; $column &lt; scalar(@columnNames); $column++) {
            test::compare(testData::field($records[$row], $column),
                $item-&gt;getText($column));
        }
    }
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

def doFileOpen(fileToOpen, currentFile)
    invokeMenuItem("File", "Open...", currentFile)
    chooseFile(waitForObject(":SWT"), fileToOpen)
end

def invokeMenuItem(menu, item, filename)
    if filename and filename != ""
        filename = " - " + filename
    end
    menuName = "{caption='#{menu}' container=':CSV Table#{filename}_org." +
    "eclipse.swt.widgets.Menu' type='org.eclipse.swt.widgets.MenuItem'}"
    waitForObject(menuName)
    activateItem(menuName)
    menuItemName = "{caption='#{item}' type='org.eclipse.swt.widgets.MenuItem'}"
    waitForObject(menuItemName)
    activateItem(menuItemName)
end

def compareTableWithDataFile(table, filename)
    TestData.dataset(filename).each_with_index do
        |record, row|
        item = table.getItem(row)
        for column in 0...TestData.fieldNames(record).length
            Test.compare(TestData.field(record, column), item.getText(column))
        end
    end
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

proc doFileOpen {fileToOpen currentFile} {
    invokeMenuItem "File" "Open..." $currentFile
    invoke chooseFile [waitForObject ":SWT"] $fileToOpen
}

proc invokeMenuItem {menu item filename} {
    if {$filename != ""} {
        set filename " - $filename"
    }
    set menuName "{caption='$menu' \
        container=':CSV Table${filename}_org.eclipse.swt.widgets.Menu' \
        type='org.eclipse.swt.widgets.MenuItem'}"
    waitForObject $menuName
    invoke activateItem $menuName
    set menuItemName "{caption='$item' \
        type='org.eclipse.swt.widgets.MenuItem'}"
    waitForObject $menuItemName
    invoke activateItem $menuItemName
}

proc compareTableWithDataFile {table filename} {
    set data [testData dataset $filename]
    for {set row 0} {$row &lt; [llength $data]} {incr row} {
        set item [invoke $table getItem $row]
        set columnNames [testData fieldNames [lindex $data $row]]
        for {set column 0} {$column &lt; [llength $columnNames]} \
            {incr column} {
            test compare [testData field [lindex $data $row] $column] \
                [invoke $item getText $column]
	   }
    }
}
</pre></div></div></div><br class="example-break"></br><p>
The <code class="code">doFileOpen</code> function begins by opening a file through
the user interface. This is done by using the custom
<code class="code">invokeMenuItem</code> function that we first saw in the
tutorial. The file dialog used may not be the same on all platforms but
<span class="emphasis"><em>Squish</em></span> generalises it by providing the Java/SWT-specific
<a class="xref" href="rgs-javaconvenience.html#java-chooseFile-function"><code class="function">chooseFile</code></a> function.
</p><p>
The
<code class="code">invokeMenuItem</code> function in effect simulates the user
clicking
<span class="keycap"><strong>Alt</strong></span>+<span class="keycap"><strong><span class="emphasis"><em>k</em></span></strong></span>
(where <span class="emphasis"><em>k</em></span> is a character, for example "F" for the
file menu), and then the character that corresponds to the required
action, (for example, "o" for "Open").
</p><p>
An alternative to invoking menu options is to use toolbar items. For
example, the CsvTableSWT example has a toolbar with New, Open, and Save
tool items, so for our custom <code class="code">doFileOpen</code> function, we
could replace the call to our custom <code class="code">invokeMenuItem</code>
function with the lines:
</p><pre class="programlisting">
waitForObject(":Open_org.eclipse.swt.widgets.ToolItem");
mouseClick(":Open_org.eclipse.swt.widgets.ToolItem");
</pre><p>
These lines wait for the Open tool item to be ready and then click it.
The lines will work in JavaScript, Python, Ruby, and Perl, and it should be
easy to see how we could parametrize them by replacing the
“<span class="quote">Open</span>” text with the text of whatever tool item we were
interested in.
</p><p>
When the file is opened, the program is expected to load the file's
data. We check that the data has been loaded correctly by comparing the
data shown in the Table and the data in the file. This comparison
is done by the custom <code class="code">compareTableWithDataFile</code> function.
This function uses <span class="emphasis"><em>Squish</em></span>'s <a class="xref" href="rgs-squish.html#testData.dataset-function"><code class="function">testData.dataset</code></a> function to load in the data so
that it can be accessed through the <span class="emphasis"><em>Squish</em></span> API. We expect the text of
every cell in the table to match the corresponding item in the data, and
we check that this is the case using the <a class="xref" href="rgs-squish.html#test.compare-function"><code class="function">test.compare</code></a> function.
</p><p>
Now that we know how to compare a table's data with the data in a file
we can perform some more ambitious tests. We will load in the
<code class="filename">before.csv</code> file, delete a few rows, insert a new
row in the middle, and append a new row at the end. Then we will swap a
few pairs of columns. At the end the data should match the
<code class="filename">after.csv</code> file.
</p><p>
Rather than writing code to do all these things we can simply record a
test script that opens the file and performs all the deletions,
insertions, and column swaps. Then we can edit the recorded test script
to add a few lines of code near the end to compare the actual results
with the expected results. Shown below is an extract from the test script
starting one line above the hand written code and continuing to the end
of the script:
</p><div class="example"><a id="idp45936728"></a><p class="title"><b>Example 5.38. Extracts from the tst_editing Script</b></p><div class="example-contents"><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

#    closeWindow(":CSV Table - Swap Columns_org.eclipse.swt.widgets.Shell")
    # Added by Hand
    source(findFile("scripts", "common.py"))
    table = waitForObject("{isvisible='true' "
        "type='org.eclipse.swt.widgets.Table'}")
    test.verify(table.getColumnCount() == 5)
    test.verify(table.getItemCount() == 12)
    compareTableWithDataFile(table, "after.csv")
    # End of Added by Hand
    waitForObject(":File_org.eclipse.swt.widgets.MenuItem_2")
    activateItem(":File_org.eclipse.swt.widgets.MenuItem_2")
    waitForObject(":Quit_org.eclipse.swt.widgets.MenuItem_2")
    activateItem(":Quit_org.eclipse.swt.widgets.MenuItem_2")
    waitForObject(":SWT")
    closeMessageBox(":SWT", SWT.NO)
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

    //closeWindow(":CSV Table - Swap Columns_org.eclipse.swt.widgets.Shell");
    // Added by Hand
    source(findFile("scripts", "common.js"));
    var table = waitForObject("{isvisible='true' " +
        "type='org.eclipse.swt.widgets.Table'}");
    test.verify(table.getColumnCount() == 5);
    test.verify(table.getItemCount() == 12);
    compareTableWithDataFile(table, "after.csv");
    // End of Added by Hand
    waitForObject(":File_org.eclipse.swt.widgets.MenuItem_2");
    activateItem(":File_org.eclipse.swt.widgets.MenuItem_2");
    waitForObject(":Quit_org.eclipse.swt.widgets.MenuItem");
    activateItem(":Quit_org.eclipse.swt.widgets.MenuItem");
    waitForObject(":SWT");
    closeMessageBox(":SWT", SWT.NO);
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

    #    closeWindow(":CSV Table - Swap Columns_org.eclipse.swt.widgets.Shell");
    # Added by Hand
    source(findFile("scripts", "common.pl"));
    my $table = waitForObject("{isvisible='true' " .
        "type='org.eclipse.swt.widgets.Table'}");
    test::verify($table-&gt;getColumnCount() == 5);
    test::verify($table-&gt;getItemCount() == 12);
    compareTableWithDataFile($table, "after.csv");
    # End of Added by Hand
    waitForObject(":File_org.eclipse.swt.widgets.MenuItem_2");
    activateItem(":File_org.eclipse.swt.widgets.MenuItem_2");
    waitForObject(":Quit_org.eclipse.swt.widgets.MenuItem_2");
    activateItem(":Quit_org.eclipse.swt.widgets.MenuItem_2");
    waitForObject(":SWT");
    closeMessageBox(":SWT", SWT::NO);
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

    #		closeWindow(":CSV Table - Swap Columns_org.eclipse.swt.widgets.Shell")
    # Added by Hand
    require findFile("scripts", "common.rb")
    table = waitForObject("{isvisible='true' " +
    "type='org.eclipse.swt.widgets.Table'}")
    Test.verify(table.getColumnCount() == 5)
    Test.verify(table.getItemCount() == 12)
    compareTableWithDataFile(table, "after.csv")
    # End of Added by Hand
    waitForObject(":File_org.eclipse.swt.widgets.MenuItem_2")
    activateItem(":File_org.eclipse.swt.widgets.MenuItem_2")
    waitForObject(":Quit_org.eclipse.swt.widgets.MenuItem_2")
    activateItem(":Quit_org.eclipse.swt.widgets.MenuItem_2")
    closeMessageBox(waitForObject(":SWT"), SWT::NO)
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

    #    invoke closeWindow ":CSV Table - Swap Columns_org.eclipse.swt.widgets.Shell" 
    # Added by Hand
    source [findFile "scripts" "common.tcl"]
    set table [waitForObject "{isvisible='true' \
        type='org.eclipse.swt.widgets.Table'}"]
    test compare [invoke $table getColumnCount] 5
    test compare [invoke $table getItemCount] 12
    compareTableWithDataFile $table "after.csv"
    # End of Added by Hand
    waitForObject ":File_org.eclipse.swt.widgets.MenuItem_2"
    invoke activateItem ":File_org.eclipse.swt.widgets.MenuItem_2" 
    waitForObject ":Quit_org.eclipse.swt.widgets.MenuItem_2"
    invoke activateItem ":Quit_org.eclipse.swt.widgets.MenuItem_2" 
    waitForObject ":SWT"
    invoke closeMessageBox ":SWT" [enum SWT NO] 
}
</pre></div></div></div><br class="example-break"></br><p>
Note that it is quite common to need to comment out
<code class="code">closeWindow()</code> calls for dialogs that provide a static
<code class="code">open</code> method that creates the dialog and calls
the <code class="code">dispose</code> function when the user has finished with it (e.g., by
clicking <span class="guibutton">OK</span> or <span class="guibutton">Cancel</span>) as
is done in <code class="filename">CsvTableSWT.java</code>.
</p><p>
As the extract indictates, the added lines are not inserted at the
<span class="emphasis"><em>end</em></span> of the recorded test script, but rather just
before the program is terminated—after all, we need the program to
be running to query its Table. (The reason that the row counts differ
is that slightly different interactions were recorded for each
scripting language.)
</p><p>
This example shows the power of combining recording with hand editing.
If at a later date a new feature was added to the program we could
incorporate tests for it in a number of ways. The simplest would be to
just add another test script, do the recording, and then add in the
lines needed to compare the table with the expected data. Another
approach would be to record the use of the new feature in a temporary
test and then copy and paste the recording into the existing test at a
suitable place and then change the file to be compared at the end to one
that accounts for all the changes to the original data and also the
changes that are a result of using the new feature. Or we could record a
test snippet directly into an existing test.
</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ugsjavaw-list"></a>5.4.6.3. How to Test List and ComboBoxes Using Proxies</h4></div></div></div><p>
Although the different <acronym class="acronym">GUI</acronym> <span class="trademark">Java</span>™ toolkits that <span class="emphasis"><em>Squish</em></span>
supports have different implementations for list and comboboxes, their items
are wrapped by <span class="emphasis"><em>Squish</em></span> in <code class="code">ItemProxy</code> objects. These objects
act as child objects of the list or combobox object. The child objects are
called <code class="code">item_0</code>, <code class="code">item_1</code> and so on.
</p><p>
The <code class="code">ItemProxy</code> objects have the properties <code class="code">text</code> and
<code class="code">selected</code>. For the <acronym class="acronym">SWT</acronym> based List and Combo
widgets, there is an extra property called <code class="code">control</code>. The
<acronym class="acronym">AWT</acronym>/Swing based ones have an extra property called
<code class="code">component</code>.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/ugsjavaw-itemproxy.png" align="middle"></img><div class="caption"><p>
In the spy you get for each item an <code class="code">ItemProxy</code> derived object.
  </p></div></div></div><p>
In <acronym class="acronym">SWT</acronym>, the List and Combo widget have the method
<code class="function">getSelectionIndex</code>. <span class="emphasis"><em>Squish</em></span> uses this method to
generate <code class="code">selectionindex</code> property calls. So for the
<acronym class="acronym">SWT</acronym> toolkit, these two tests are equivalent:
</p><pre class="programlisting">
test.compare(list.selectionindex, 2);
test.verify(list.item_2.selected);
</pre><p>
Note however that the second test gives a script error if the list has
less then three items. And that the first test only gives one of the
selections if the list supports multiple selections. In that case you
can only use the generated <code class="code">ItemProxy</code> objects for
verification points.
</p><p>

</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ugsjavaw-geflist"></a>5.4.6.4. How to Test GEF applications</h4></div></div></div><p>
<span class="emphasis"><em>Squish</em></span> exposes Figures and FigureCanvas from the GEF (Graphical
Editing Framework) library. The Figure hierarchy of the FigureCanvas is
exposed and can be inspected in the <span class="application">Spy</span>. Properties of the Figure
items can be tested like this:
</p><pre class="programlisting">
item = waitForObject(":First_FigureItem")
test.verify(item.visible);
test.verify(item.enabled);
</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ug-how.to.use.the.java.GestureBuilder"></a>5.4.7. How to Use the GestureBuilder class</h3></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></img></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
This sections only applies to JavaFX running on Windows 8 or higher.
</p></td></tr></table></div><p>
An instance of this class is returned by
<a class="xref" href="rgs-javaconvenience.html#java-readGesture-function"><code class="function">readGesture</code></a>. When however the recorded
gesture doesn't fit on the window, a scaling and/or translation can be done.
</p><p>
It might be useful to get the <span class="emphasis"><em>scene</em></span> sizes. Here an
example how to get these in pixels, using the <span class="trademark">Java</span>™ script bindings.
</p><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">
var fx_node = findObject(":A_JavaFX_Node");
var scene = fx_node.getScene();
var w = scene.getWidth();
var h = scene.getHeight();
</pre></div><p>
Suppose the gesture was recorded on a 4:3 display full-screen. And when
replayed on a wide monitor, the gesture might be too large and too much to the
bottom-left. Then a <a class="xref" href="rgs-javaconvenience.html#java-GestureBuilder.scale-function"><code class="function">GestureBuilder.scale</code></a> and
<a class="xref" href="rgs-javaconvenience.html#java-GestureBuilder.translate-function"><code class="function">GestureBuilder.translate</code></a> towards the
top-right is a possible solution.
</p><div class="mediaobject" align="center"><img src="images/transformations.png" align="middle"></img><div class="caption">The effect of a rotation, scale and translate transformation.
</div></div><p>
For instance, scale it 3/4 in size and 50 pixels to the right and 10 pixels
upwards.
</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></img></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>
When using the <span class="application">Squish IDE</span>, use the <a class="xref" href="ide.views.html#ide.the-console.view" title="8.2.3. Console view">Console view (Section 8.2.3)</a> when at
a breakpoint in your script, to experiment with gesture transformations.
</p></td></tr></table></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">
gesture(waitForObject(":some_object"), readGesture("Gesture_1").scale(0.75).translate(50,-10));
</pre></div><p>
Another approach could be to only scale with an origin in the top-right corner.
</p><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">
var gst = readGesture("Gesture_1");
gesture(waitForObject(":some_object"), gst.scale(0.75, 0.75, gst.areaWidth, 0));
</pre></div><p>
In some cases dynamic created gestures are required, e.g. for more accurate
control or dependency on runtime state information. Then the
<a class="xref" href="rgs-javaconvenience.html#java-GestureBuilder-create-functions" title="6.7.2.1. Gesture creation">Gesture creation (Section 6.7.2.1)</a> methods can be used.
</p><p>
Here an example of a pitch gesture, two finger gesture making a curved
counter clockwise movement on a 800x1200 pixel screen in one second.
</p><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">
var tb = new GestureBuilder(800, 1280, GestureBuilder.Pixel);
tb.addStroke( 600, 400 );
tb.curveTo(1000, 500, 300, 300, 300, 200, 400 );
tb.addStroke( 200, 800 );
tb.curveTo(1000, 300, 900, 500, 900, 600, 800);
tb.build();
gesture(waitForObject(":some_object"), tb);
</pre></div><p>
And here an example of a zoom gesture, two finger gesture moving away from
each other, also in one second. This time written as one statement.
</p><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">
gesture(waitForObject(":some_object"),
        new GestureBuilder(800, 1280, GestureBuilder.Pixel)
           .addStroke( 500, 400 )
           .lineTo(1000, 700, 100 )
           .addStroke( 300, 700 )
           .lineTo(1000, 100, 1000)
           .build());
</pre></div><p>
In the above two examples, the coordinate values are based on the area size
of 800x1280. For different <span class="emphasis"><em>scene</em></span> sizes or different
size or position of the widget on which the gesture should replay, some
calculations is needed to get these values. Next, a strategy that can help
to keep the complexity under control when having to deal with that.
</p><div class="itemizedlist"><ul type="disc"><li><p>
Create a gesture given the screen dimensions, within the boundary of
x-axis [-0.5,0.5] and y-axis [-0.5,0.5] and a duration of 1s.
</p></li><li><p>
Translate it to the center of the target widget.
</p></li><li><p>
Scale it with a maximum of the widget size, using the center of this widget as origin.
</p></li><li><p>
Adjust the duration.
</p></li></ul></div><div class="mediaobject" align="right"><img src="images/s-shape.png" align="right"></img></div><p>
Here a listing of this, in this case an S shaped figure.
</p><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">
var fx_node = findObject(":A_JavaFX_Node");
var scene = fx_node.getScene();

var tb = new GestureBuilder(scene.width, scene.height, GestureBuilder.Pixel)
             .addStroke(0, 0.5)
             .curveTo(500, -0.5, 0.5, -0.5, 0, 0, 0)
             .curveTo(500, 0.5, 0, 0.5, -0.5, 0, -0.5)
             .build();

var widget = findObject(":Some widget");
var scale = widget.width &gt; widget.height ? widget.height : widget.width;
var centerX = widget.screenX + widget.width/2;
var centerY = widget.screenY + widget.height/2;
gesture(widget,
        tb.translate(centerX, centerY)
          .scale(scale, -scale, centerX, centerY)
          .accelerate(1/2))
      </pre></div><p>
Note that this example defines the figure with the positive y-axis upwards.
In order to not get the figure up-side-down, a mirror in the x-axis is
needed. The trick is to use a negative scale factor in the vertical direction.
</p><p>
To keep the defined gesture within the -0.5 to 0.5 boundary has the advantage
that the total size is 1. Thus it can be scaled with the widget sizes without
being scaled outside the screen boundaries. Having (0, 0) in the center, makes
the translation simple, just to the center of the widget.
</p></div></div><script xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" type="text/javascript" src="ScriptingLanguage.js"></script><script xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format">setScriptingLanguage();</script><div class="navfooter"><hr></hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ugs-webapi.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="users-guide.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ug-how.to.use.the.windows.nativeobject.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">5.3. How to Use the Web API </td><td width="20%" align="center"><a accesskey="h" href="index-noframes.html">Home</a></td><td width="40%" align="right" valign="top"> 5.5. How to Use the Windows <code class="code">nativeObject</code> API</td></tr></table></div></body>
<!-- Mirrored from ugs-javaapi.html by HTTrack Website Copier/3.x [XR&CO'2013], Wed, 06 Jul 2022 13:29:03 GMT -->
</html>
