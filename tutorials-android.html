<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- Mirrored from tutorials-android.html by HTTrack Website Copier/3.x [XR&CO'2013], Wed, 06 Jul 2022 13:28:59 GMT -->
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>4.12. Squish for Android Tutorials</title><link rel="stylesheet" href="manual.css" type="text/css"></link><meta name="generator" content="DocBook XSL Stylesheets V1.73.2"></meta><link rel="start" href="index-noframes.html" title="Squish Manual"></link><link rel="up" href="tutorials.html" title="Chapter 4. Tutorials"></link><link rel="prev" href="tutorials-gdc.html" title="4.11. Squish for GDC Tutorials"></link><link rel="next" href="tutorials-flex.html" title="4.13. Squish for Flex Tutorials"></link><style xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" type="text/css" media="screen">
        div.toc * { margin-left: 6px; margin-right: auto; max-width: 75em; }
        div.toc span { margin-left: 0px; }
        * { margin-left: auto; margin-right: auto; max-width: 75em; }
        body { margin-left: 6px; margin-right: 6px; }
        table th { padding: .5ex }
        table td { padding: .5ex }
    </style><script xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format">
        function keyPress() {
            var e = window.event;
            if ( e == undefined ) {
                return;
            }
            /* ### does not properly scroll, yet
            if ( e.keyCode == 32 ) {
            var l = document.links;
            for ( var i = 0; i < l.length; i++ ) {
                if ( l[i].innerText == "Next" ) {
                location.href = l[i].href;
                }
            }
            } else
                */
                if ( e.keyCode == 0x08 ) {
            var l = document.links;
            for ( var i = 0; i < l.length; i++ ) {
                if ( l[i].innerText == "Prev" ) {
                location.href = l[i].href;
                }
            }
            }
        }
        document.onkeypress = keyPress;
    </script></head><body><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="tutorials-android"></a>4.12. Squish for Android Tutorials</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="tutorials-android.html#tutorial-getting-started-android">4.12.1. Tutorial: Starting to Test Android Applications</a></span></dt><dt><span class="section"><a href="tutorials-android.html#tutorial-bdd-android">4.12.2. Tutorial: Designing Behavior Driven Development (BDD) Tests</a></span></dt><dt><span class="section"><a href="tutorials-android.html#tutorial-migration-bdd-android">4.12.3. Tutorial: Migration of existing tests to BDD</a></span></dt></dl></div><p>
	Learn how to test Android applications.
	</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-getting-started-android"></a>4.12.1. Tutorial: Starting to Test Android Applications</h3></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="tutorials-android.html#tgs-concepts-android">4.12.1.1. Squish Concepts</a></span></dt><dt><span class="section"><a href="tutorials-android.html#tut-android-creating-a-test-suite">4.12.1.2. Creating a Test Suite</a></span></dt><dt><span class="section"><a href="tutorials-android.html#tut-android-recording-tests">4.12.1.3. Recording Tests and Verification Points</a></span></dt><dt><span class="section"><a href="tutorials-android.html#tut-android-verification-points">4.12.1.4. Inserting Additional Verification Points</a></span></dt><dt><span class="section"><a href="tutorials-android.html#tut-android-creating-manual-tests">4.12.1.5. Creating Tests by Hand</a></span></dt><dt><span class="section"><a href="tutorials-android.html#tut-android-learning-more">4.12.1.6. Learning More</a></span></dt></dl></div><p>
This tutorial will show you how to create, run, and modify tests for an
example application for Android. In the process you will learn about
<span class="emphasis"><em>Squish</em></span>'s most frequently used features so that by the end of the
tutorial you will be able to start writing your own tests for your own
applications.
</p><p>
This chapter presents most of the major concepts behind <span class="emphasis"><em>Squish</em></span> and
provides the information you need to get started using <span class="emphasis"><em>Squish</em></span> for
testing your own applications. This tutorial does not discuss all
of <span class="emphasis"><em>Squish</em></span>'s features, and those that it does cover are not covered in
full detail. After reading this tutorial we recommend reading the
<a class="xref" href="users-guide.html" title="Chapter 5. User Guide">User Guide (Chapter 5)</a>, and at least skimming the
<a class="xref" href="api.man.html" title="Chapter 6. API Reference Manual">API Reference Manual (Chapter 6)</a> and the
<a class="xref" href="ref.man.html" title="Chapter 7. Tools Reference Manual">Tools Reference Manual (Chapter 7)</a>, so that you are familiar with all the
features that <span class="emphasis"><em>Squish</em></span> has to offer, even if you don't need to use them
all straight away.
</p><p>
This tutorial is divided into several sections. If you are new to
<span class="emphasis"><em>Squish</em></span> it is best
to read all of them. If you are already using <span class="emphasis"><em>Squish</em></span> you might want to
just skim the tutorial, stopping only to read those sections that cover
any new features that you haven't used before—or you could just
skip straight to the <a class="xref" href="users-guide.html" title="Chapter 5. User Guide">User Guide (Chapter 5)</a>.
</p><p>
Whenever we show how to achieve something using the IDE we will always
follow with an explanation of how to do the same thing using the command
line tools. Using an IDE is the easiest and best way to start, but once
you build up lots of tests you will want to automate them, (e.g., doing
nightly runs of your regression test suite), so it is worth knowing how
to use the command line tools since they can be run from batch files or
shell scripts.
</p><p>
The application we will test is a very simple Address Book application.
Users can, via what are called <a class="ulink" href="https://developer.android.com/guide/components/activities/intro-activities" target="_blank">Activities</a>,
do things like <span class="guilabel">Add Address</span> via a button, or from the
Activity menu (<span class="guiicon"><img src="images/android-menu-button.png"></img></span>)
select the <span class="guilabel">Demo Data</span> to load some example
addresses. When an existing address is tapped, the user can
<span class="guilabel">Edit Address</span>, or from the menu, <span class="guilabel">Delete Address</span>.
Although the application is very simple, it has all the standard features
that you are likely to want to use in your own tests, including menus, a
list, a pop-up dialog, line edits, and buttons. Once you
know how to test any of these user interface elements you will be able to
apply the same principles to testing elements present in your own
applications that are not used in the tutorial, such as spinners and
date and time controls. (The <a class="xref" href="users-guide.html" title="Chapter 5. User Guide">User Guide (Chapter 5)</a> has
more comprehensive examples.)
</p><p>
The screenshot shows the application in action with a user adding a new
name and address.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/tut-addressbook-android.png" align="middle"></img><div class="caption"><p>The <span class="application">AddressBook</span> for Android example.
</p></div></div></div><p>
The application (i.e., the AUT—Application Under Test) can be
found with <span class="emphasis"><em>Squish</em></span>'s examples in
<code class="filename">SQUISHDIR/examples/android/AddressBook/AddressBook-debug.apk</code>.
The tests that we will discuss in the following sections are in
folders, for example, the versions of the tests using the Python
language are in
<code class="filename">SQUISHDIR/examples/android/AddressBook/suite_py</code>, with the
tests written in other languages in similarly named sub-folders.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: The Squish Directory"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></img></td><th align="left">The <span class="emphasis"><em>Squish</em></span> Directory</th></tr><tr><td align="left" valign="top"><p>
Throughout the manual, we often refer to the <code class="filename">SQUISHDIR</code>
directory. This means the directory where <span class="emphasis"><em>Squish</em></span> is installed, which
might be <code class="filename">C:\Squish</code>,
<code class="filename">/usr/local/squish</code>,
<code class="filename">/opt/local/squish</code>, or somewhere else, depending on
where you installed it. The exact location doesn't matter, so long as
you mentally translate the <code class="filename">SQUISHDIR</code> directory to
whatever the directory really is when you see paths and filenames in
this manual.
</p></td></tr></table></div><p>
In the following sections we will create a test suite and then create
some tests, but first we will very briefly review some key <span class="emphasis"><em>Squish</em></span>
concepts.
</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="tgs-concepts-android"></a>4.12.1.1. Squish Concepts</h4></div></div></div><p>
To perform testing of Android AUTs, these things are required:
</p><div class="orderedlist"><ol type="1"><li><p>An Android device connected by USB, or an Android Virtual Device
(AVD), </p></li><li><p>
an application to test—known as the Application Under Test (AUT), and
</p></li><li><p>
a test script that exercises the AUT.
</p></li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note:  USB Debugging "><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></img></td><th align="left"> USB Debugging </th></tr><tr><td align="left" valign="top"><p> For Android devices, make sure <span class="guilabel">USB Debugging</span> is
enabled after the device is connected to your PC. This usually requires first
enabling <span class="guilabel">Developer Options</span> on the device before you can see
the option under <span class="guilabel">Settings</span>. </p></td></tr></table></div><p>
In both cases, <span class="emphasis"><em>Squish</em></span> runs a small server (<span class="application">squishserver</span>) that handles the
communication between the AUT and the test script. The test script is
executed by the <span class="application">squishrunner</span> tool, which in turn connects to the
<span class="application">squishserver</span>. The <span class="application">squishserver</span> starts the instrumented AUT on the device,
which starts the <span class="emphasis"><em>Squish</em></span> hook. The hook is a small library that makes the AUT's
live running objects accessible, and allows communication with the
<span class="application">squishserver</span>. With the hook in place, the <span class="application">squishserver</span> can query AUT
objects regarding their state and can execute commands—all on
behalf of the <span class="application">squishrunner</span>. The <span class="application">squishrunner</span> directs
the AUT to perform whatever actions the test script specifies.
</p><p>
The following diagram illustrates how the individual <span class="emphasis"><em>Squish</em></span> tools work
together.
</p><div class="mediaobject" align="center"><img src="images/design_network.png" align="middle"></img></div><p>
From the test engineer's perspective this separation is not noticeable,
since all the communication is handled transparently behind the scenes.
</p><p>
Tests can be written and executed using the <span class="application">Squish IDE</span>, in which case the
<span class="application">squishserver</span> is started and stopped automatically, and the test
results are displayed in the <span class="application">Squish IDE</span>'s <a class="xref" href="ide.views.html#ide.the-test-results.view" title="8.2.18. Test Results view">Test Results view (Section 8.2.18)</a>. The following diagram illustrates
what happens behind the scenes when the <span class="application">Squish IDE</span> is used.
</p><div class="mediaobject" align="center"><img src="images/design_ide.png" align="middle"></img></div><p>
The <span class="emphasis"><em>Squish</em></span> tools can also be used from the command line without the
<span class="application">Squish IDE</span>—this is useful for those testers who prefer to use their own
tools (for example, their favorite editor), and also for performing
automatic batch testing (for example, when running regression tests
overnight). In these cases, the <span class="application">squishserver</span> must be started manually,
and stopped when all the testing is complete (or, if preferred, started
and stopped for each test).
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Terminology"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></img></td><th align="left">Terminology</th></tr><tr><td align="left" valign="top"><p>
The <span class="emphasis"><em>Squish</em></span> documentation mostly uses the term
<span class="type">Widget</span> when referring to GUI objects (i.e.,
buttons, menus, menu items, labels, table controls, etc). In
some Java toolkits, an equivalent is <span class="type">Component</span>.
</p></td></tr></table></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="tgsc_apptestable-android"></a>4.12.1.1.1. Making an Application Testable</h5></div></div></div><p>
When testing Android AUTs, the <span class="guilabel">Instrument and Deploy</span> step
causes the application to be instrumented with extra code that includes the
Squish hook. This process involves unzipping the package, adding classes, and
zipping it up again. Further details can be found in <a class="xref" href="install_android.html#android_app_instrumentation" title="3.9.1. Make the Android app testable">Make the Android app testable (Section 3.9.1)</a>.
</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="tut-android-creating-a-test-suite"></a>4.12.1.2. Creating a Test Suite</h4></div></div></div><p>
A test suite is a collection of one or more test cases
(<span class="emphasis"><em>tests</em></span>).
Using a test suite is convenient since it makes it easy to share
scripts and test data between a group of related tests.
</p><p>
Here, and throughout the tutorial, we will start by describing how to do
things using the IDE, with the information for command line users
following.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></img></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
Before going forward, make sure you have a Java
<acronym class="acronym">JDK</acronym>, version 7 or higher, installed on your system running
<span class="emphasis"><em>Squish</em></span>.
</p><p> If you are testing on an Android Virtual Device (<acronym class="acronym">AVD</acronym>)
you need to have already installed the Android <span class="application">Developer Studio</span>,
and set up a device from the <a class="ulink" href="https://developer.android.com/studio/run/managing-avds" target="_blank">AVD Manager</a>.
Otherwise, you should have a physical Android device connected via
<acronym class="acronym">USB</acronym> with <acronym class="acronym">USB</acronym> debugging enabled.
Either way, the Android device should show up in its own combobox, under the
Test Suites combobox in the <span class="guilabel">Test Suites</span> view of
<span class="application">squishide</span>.
</p></td></tr></table></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning: Other Development Environments "><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="images/warning.png"></img></td><th align="left">Other Development Environments </th></tr><tr><td align="left" valign="top"><p>
Make sure no other Android development environment is running that can
access the emulator or device. That includes Eclipse with the ADT plugin
and Android Developer Studio. These tools prevent <span class="emphasis"><em>Squish</em></span> from accessing
the AUT (the app we're going to test).
</p></td></tr></table></div><p>
To begin with start up the <span class="application">Squish IDE</span>, either by clicking or double-clicking
the <span class="application">squishide</span> icon, or by launching <span class="application">squishide</span> from the taskbar menu
or by executing <span class="application">squishide</span> on the command line—whichever you
prefer and that is suitable for the platform you are using. Once
<span class="emphasis"><em>Squish</em></span> starts up you might be greeted with a <span class="emphasis"><em>Welcome Page</em></span>
in case you're starting the <span class="application">squishide</span> for the first time. Click the
<span class="emphasis"><em>Workbench</em></span> button in the upper right to dismiss it. Then, the
<span class="application">squishide</span> will look <span class="emphasis"><em>similar</em></span> to the screenshot—but probably
slightly different depending on the windowing system, colors, fonts, and
theme that you use, and so on.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/tut-squish1.png" align="middle"></img><div class="caption">The Squish IDE with no Test Suites
</div></div></div><p>
Once <span class="emphasis"><em>Squish</em></span> has started click
<span class="guimenu">File</span>|<span class="guimenuitem">New Test Suite...</span>
to pop-up the <span class="guilabel">New Test Suite</span> wizard shown below.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/tut-squish-newtestsuite1-android.png" align="middle"></img><div class="caption">The New Test Suite wizard's Name &amp; Directory page
</div></div></div><p>
Enter a name for your test suite and choose the folder where you want
the test suite to be stored. In the screenshot we have called the test
suite <code class="filename">suite_py</code> and we have it inside an
<code class="filename">addressbook</code> folder.
Naturally, you can choose whatever name and folder you prefer. Once the
details are complete, click <span class="guibutton">Next</span> to go on to the
Toolkit (or Scripting Language) page.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/tut-squish-newtestsuite2-android.png" align="middle"></img><div class="caption">The New Test Suite wizard's Toolkit page
</div></div></div><p>
If you get this wizard page, click the toolkit your AUT uses. For this
example, we must click <span class="guilabel">Android</span> since we are testing an
application for Android. Then click <span class="guibutton">Next</span> to go to the
<span class="guilabel">Scripting Language</span> page.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/tut-squish-newtestsuite3-android.png" align="middle"></img><div class="caption">The New Test Suite wizard's Scripting Language page
</div></div></div><p>
Choose whichever scripting language you want—the only constraint
is that you can only use one scripting language per test suite. (So if
you want to use multiple scripting languages, just create multiple test
suites, one for each scripting language you want to use.) The
functionality offered by <span class="emphasis"><em>Squish</em></span> is the same for all languages. Having
chosen a scripting language, click <span class="guibutton">Next</span> once more to get
to the wizard's last page.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/tut-squish-newtestsuite4-android.png" align="middle"></img><div class="caption">The New Test Suite wizard's AUT page</div></div></div><p>
This tutorial uses <code class="code">com.froglogic.addressbook</code>, a very simple
address book application.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/tut-squish-android-instrument.png" align="middle"></img><div class="caption">The Instrument and Deploy an application dialog
</div></div></div><p>
Click the <span class="guibutton">New...</span> and fill in the missing fields.
Click on <span class="guibutton">Browse...</span> and select
<code class="filename">SQUISHDIR/examples/android/AddressBook/AddressBook-debug.apk</code>
This file contains the app <code class="code">com.froglogic.addressbook</code>.
</p><p>
You can leave the <span class="guilabel">Path to JDK</span> empty if the JDK's bin
directory is in your PATH. Typically, users working on MS Windows have to
specify this directory and Linux or Mac users can leave this field empty,
but do have to make sure <span class="trademark">Java</span>™ version 7 or higher is installed.
</p><p>
You should see one or more Android Devices listed. Select
one or more and press <span class="guibutton">Instrument and Deploy</span>.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/tut-squish-newtestsuite6-android.png" align="middle"></img><div class="caption">The Test Suite wizard's AUT page with package
</div></div></div><p>
After the AUT is deployed, the wizard will show
<code class="code">com.froglogic.addressbook</code> in the AUT combo box.
</p><p>
Finally, click <span class="guibutton">Finish</span> and <span class="emphasis"><em>Squish</em></span> will
create a sub-folder called
<code class="filename">suite_<span class="emphasis"><em>suiteName/</em></span></code> and
create a file inside that folder called <code class="filename">suite.conf</code>
that contains the test suite's configuration details. <span class="emphasis"><em>Squish</em></span> will also
register the AUT with the <span class="application">squishserver</span>. The wizard will then close and
<span class="emphasis"><em>Squish</em></span>'s IDE will look similar to the screenshot below.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/tut-squish2-android.png" align="middle"></img><div class="caption">The Squish IDE with the suite_py test suite
</div></div></div><p>
We are now ready to start creating tests. Read on to learn how to create
test suites without using the IDE, or skip ahead to <a class="xref" href="tutorials-android.html#tut-android-recording-tests" title="4.12.1.3. Recording Tests and Verification Points">Recording Tests and Verification Points (Section 4.12.1.3)</a> if you prefer.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: For command-line users"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></img></td><th align="left"><span class="emphasis"><em>For command-line users</em></span></th></tr><tr><td align="left" valign="top"><p>
To create a new test suite from the command line, three steps are
necessary: first, create a directory for the test suite; second, create
a test suite configuration file; instrument and deploy an apk file.
</p><div class="orderedlist"><ol type="1"><li><p>
Create a new directory to hold the test suite—the directory's name
should begin with <code class="code">suite</code>. In this example we have created
the <code class="filename">suite_py</code> directory for Python tests.
</p></li><li><p>
Create a plain text file (ASCII or UTF-8 encoding) called
<code class="filename">suite.conf</code> in the suite subdirectory. This is the
test suite's configuration file, and at the minimum it must identify the
AUT, the scripting language used for the tests, and the wrappers (i.e.,
the GUI toolkit or library) that the AUT uses. The format of the file is
<span class="emphasis"><em><code class="code">key</code></em></span> <code class="code">=</code>
<span class="emphasis"><em><code class="code">value</code></em></span>, with one
<span class="emphasis"><em>key–value</em></span> pair per line. For example:
</p><pre class="screen">
AUT            = com.froglogic.addressbook
LANGUAGE       = Python
WRAPPERS       = Android
OBJECTMAPSTYLE = script
</pre><p>
The <span class="property">AUT</span> for programs for Android is the full Java-language-style package
name for the application.
<sup>[<a id="idp43338536" href="#ftn.idp43338536" class="footnote">17</a>]</sup>
The <span class="property">LANGUAGE</span> can be set to whichever one
you prefer—currently <span class="emphasis"><em>Squish</em></span> is capable of supporting
JavaScript, Python, Perl, Ruby, and Tcl, but the precise
availability may be different depending on how <span class="emphasis"><em>Squish</em></span> was installed.
</p></li><li><p>
<a class="xref" href="install_android.html" title="3.9. Installing Squish for Android">Installing Squish for Android (Section 3.9)</a> describes how to instrument and deploy the
apk file in detail. Basically, from the <span class="emphasis"><em>Squish</em></span> directory run on Windows

</p><pre class="screen">
bin\apk-tool -j "C:\Program Files\Java\jdkx.y.z" -pkg "&lt;your-apk&gt;" -o "%TEMP% -d &lt;device&gt;
</pre><p>

and on Linux or Mac

</p><pre class="screen">
bin/apk-tool -pkg "&lt;your-apk&gt;" -o /tmp -d &lt;device&gt;
</pre><p>

in which the <span class="emphasis"><em><code class="code">device</code></em></span> is the target device
or emulator. Run </p><pre class="screen">squishrunner --info androidDevices
</pre><p> to get a list of all connected devices and/or emulators.

</p></li></ol></div></td></tr></table></div><p>
We are now ready to record our first test.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="tut-android-recording-tests"></a>4.12.1.3. Recording Tests and Verification Points</h4></div></div></div><p>
<span class="emphasis"><em>Squish</em></span> records tests using the scripting language that was specified
for the test suite. Once a test has been recorded, we can
<span class="emphasis"><em>run</em></span> the test and <span class="emphasis"><em>Squish</em></span> will faithfully repeat all the
actions that we performed when recording the test, but without the pauses
that humans are prone to but which computers don't need. It is also
possible—and very common—to edit recorded tests, or to copy parts of
recorded tests into manually created tests, as we will see later on in the
tutorial.
</p><p>
Recordings are made into existing test cases. We begin by
creating a <span class="guilabel">New Script Test Case</span>.
There are two ways we can do this. One way
is to click <span class="guimenu">File</span>|<span class="guimenuitem">New Test
Case...</span>. This will pop up the <a class="xref" href="ide.dialogs.html#ide.new.squish.test.case.wizard" title="8.3.10. New Squish Test Case wizard">New Squish Test Case wizard (Section 8.3.10)</a>—simply enter the name
for the test case and then click <span class="guibutton">Finish</span>. Another
way is to click the <span class="guibutton">New Script Test Case</span> (<span class="guiicon"><img src="images/ide/new_test_case.png"></img></span>) toolbar button (to
the right of the <span class="guilabel">Test Cases</span> label in the
<span class="guilabel">Test Suites</span> view); this will create a new test
case with a default name (which you can easily change). Use one of these
methods and give the new test case the name “<span class="quote">tst_general</span>”.
<span class="emphasis"><em>Squish</em></span> automatically creates a sub-folder inside the test suite's
folder with this name and also a test file, for example
<code class="filename">test.py</code>. (If we had chosen JavaScript as our
scripting language the file would be called
<code class="filename">test.js</code>, and correspondingly for Perl, Ruby, or Tcl.)
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/tut-squish3.png" align="middle"></img><div class="caption">The Squish IDE with the tst_general test case
</div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></img></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><div class="mediaobject" align="right"><img src="images/tut-squish-testcase-type.png" align="right"></img></div><p>
If you get a sample <code class="filename">.feature</code> file instead of a "Hello
World" script, then click on the arrow left of the <span class="guibutton">Run Test Suite</span> (<span class="guiicon"><img src="images/ide/run_test_suite.png"></img></span>)
and select <span class="guibutton">New Script Test Case</span> (<span class="guiicon"><img src="images/ide/new_test_case.png"></img></span>).
</p></td></tr></table></div><p>
To make the test script file (e.g., <code class="filename">test.js</code>) appear
in an <a class="xref" href="ide.views.html#ide.the-editor.view" title="8.2.6. Editor view">Editor view (Section 8.2.6)</a>, click—or double-click
depending on the <span class="guimenuitem">Preferences</span>|<span class="guimenuitem">General</span>|<span class="guimenuitem">Open mode</span>
setting—the test case. This selects the Script as the active one
and makes visible its corresponding <span class="guibutton">Record</span> (<span class="guiicon"><img src="images/ide/record.png"></img></span>) and <span class="guibutton">Run Test</span> (<span class="guiicon"><img src="images/ide/run.png"></img></span>) buttons.
</p><p>
The checkboxes are used to control which test cases are
run when the <span class="guibutton">Run Test Suite</span> (<span class="guiicon"><img src="images/ide/run_test_suite.png"></img></span>) toolbar button is clicked; we can also run
a single test case by clicking its <span class="guibutton">Run Test</span> (<span class="guiicon"><img src="images/ide/run.png"></img></span>) button. If the test case is not
currently active, the button may be invisible until the mouse is hovered over
it.
</p><p> Initially, the
script's <code class="function">main()</code> logs "Hello World" to the test results. If
we were to create a test manually (as we will do later on in the tutorial), we
<span class="emphasis"><em>must</em></span> create a <code class="function">main</code> function, and we
should import the same imports at the top.
The name "main" is special to <span class="emphasis"><em>Squish</em></span>. Tests may contain as many functions
and other code as we like (providing it is legal for the scripting language), but when the
test is executed (i.e., run), <span class="emphasis"><em>Squish</em></span> always executes the
<code class="function">main</code> function. It is also possible to share commonly used code
between test scripts—this is covered in the <a class="xref" href="users-guide.html" title="Chapter 5. User Guide">User Guide (Chapter 5)</a>. (In fact, two other function names are special
to <span class="emphasis"><em>Squish</em></span>, <code class="function">cleanup</code> and <code class="function">init</code>; see <a class="xref" href="api.special.functions.html" title="6.1. Tester-Created Special Functions">Tester-Created Special Functions (Section 6.1)</a> for details.)
</p><p>
Once the new test case has been created, we are free to write
test code manually, or to record a test. Clicking on the test case's
<span class="guibutton">Record</span> (<span class="guiicon"><img src="images/ide/record.png"></img></span>) replaces the test's code with a new recording.
It is also possible to record snippets and insert them into existing test
cases, but that is not covered in this tutorial.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: For command-line users"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></img></td><th align="left"><span class="emphasis"><em>For command-line users</em></span></th></tr><tr><td align="left" valign="top"><p>
Creating a new test case from the command line is an easy two-step
process: first, create a test case directory; and second, create a
test case script with the same elements (imports, main() function)
that the IDE does when it creates a hello-world script in that language.
</p><div class="orderedlist"><ol type="1"><li><p>
Create a new subdirectory inside the test suite directory. For example,
inside the
<code class="filename">SQUISHDIR/examples/android/AddressBook/suite_py</code>
directory, we have a <code class="filename">tst_general</code> directory.
</p></li><li><p>
Inside the test case's directory create a file called
<code class="filename">test.py</code> (or <code class="filename">test.js</code> if you are
using the JavaScript scripting language, and similarly for the other
languages).
</p></li></ol></div></td></tr></table></div><p>
Before we dive into recording let's briefly review our very simple test scenario:
</p><div class="orderedlist"><ol type="1"><li><p>
Load addresses.
</p></li><li><p>
Edit the surname of the second address entry.
</p></li><li><p>
Navigate to the first address and remove it.
</p></li></ol></div><p>
We are now ready to record our first test. Click the <span class="guibutton">Record</span> (<span class="guiicon"><img src="images/ide/record.png"></img></span>)
to the right of the <code class="code">tst_general</code> test case shown in the <a class="xref" href="ide.views.html#ide.the-test-suites.view" title="8.2.19. Test Suites view">Test Suites view (Section 8.2.19)</a>'s Test Cases list. This will cause
<span class="emphasis"><em>Squish</em></span> to run the AUT so that we can interact with it. Once the AUT is
running perform the following actions—and don't worry about how
long it takes since <span class="emphasis"><em>Squish</em></span> doesn't record idle time:
</p><div class="orderedlist"><ol type="1"><li><p>
Tap the menu button on the device and tap
<span class="guimenuitem">Demo Data</span>
</p></li><li><p>
Tap the second row, the Edit Address page will open. Then tap the second
line edit somewhere right of the text, tap the backspace a few times and
type "Doe". Don't worry about typing mistakes—just backspace delete
as normal and fix them. Finally, tap the
<span class="guibutton">Save</span> button—just press the back button when
the on-screen keyboard is in the way. The second row should now have the
adjusted Surname you typed in.
</p></li><li><p>
Now tap the first row. On the Edit Address page, tap the menu button
and then tap
<span class="guimenuitem">Delete Address</span>,
and then tap the <span class="guibutton">Delete</span> button in the message box.
The first row should be gone, so the modified "Doe" entry should now be
the first one.
</p></li><li><p>
Click on the <span class="guibutton">Verify</span> toolbar button in
the <span class="emphasis"><em>Squish</em></span> <a class="xref" href="ide.main.window.html#ide-the-controlbar-window" title="8.1.3. Control Bar Window">Control Bar Window (Section 8.1.3)</a> (the second
button from the left) and select <span class="guibutton">Properties</span>.</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/controlbar-verify-props.png" align="middle"></img></div></div><p>This will make the <span class="application">Squish IDE</span> appear. In the Application Objects view,
expand the <code class="classname">AddressBook</code> object and repeat until
the <code class="classname">ListView</code> first <code class="classname">LinearLayout</code>
object is expanded. For the emulator used in this tutorial, that requires also expanding the
<code class="classname">FrameLayout</code> object and then the
<code class="classname">LinearLayout</code> object.
Click the <code class="code">Doe</code> object to make its properties appear in the
<a class="xref" href="ide.views.html#ide.the-properties.view" title="8.2.12. Properties view">Properties view (Section 8.2.12)</a>, and then check the
<span class="property">text</span> property's checkbox.

</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/android-tut-vp1.png" align="middle"></img><div class="caption">The Squish IDE a verification point about to be inserted
</div></div></div><p>

Finally, click the <span class="guibutton">Save and Insert Verifications</span>
(at the bottom of the <a class="xref" href="ide.views.html#ide.verification.point.creator.view" title="8.2.22. Verification Point Creator view">Verification Point Creator view (Section 8.2.22)</a>) button to have
the surname verification for the first row inserted into
the recorded test script. (See the screenshot below.) Once the
verification points are inserted the <span class="application">Squish IDE</span>'s window will be hidden again
and the Control Bar window and the AUT will be back in view.
</p></li><li><p>
We've now completed the test, so in the AUT, press the menu button
and tap
<span class="guimenuitem">Quit</span>. Finally, if the
Control Bar is still there, click the <span class="guibutton">Stop Recording</span>
button in it.
</p></li></ol></div><p>
Once we quit the AUT, the recorded test will appear in <span class="emphasis"><em>Squish</em></span>'s IDE as
the screenshot illustrates. (Note that the exact code that is recorded
will vary depending on how you interact. For example, you might invoke
menu options by clicking them or by using key sequences—it doesn't
matter which you use, but since they are different, <span class="emphasis"><em>Squish</em></span> will record
them differently.)
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/android-tut-squish1.png" align="middle"></img><div class="caption">The Squish IDE showing the recorded tst_general test
</div></div></div><p>
If the recorded test doesn't appear, click (or double-click depending on
your platform and settings) the <code class="filename">tst_general</code> test
case; this will make <span class="emphasis"><em>Squish</em></span> show the test's
<code class="filename">test.py</code> file in an editor window as shown in the
screenshot.
</p><p>
Now that we've recorded the test we are able to play it back, i.e.,
run it. This in itself is useful in that if the play back failed it
might mean that the application has been broken. Furthermore, the
verification that we inserted will be checked on play back (as shown
in the screenshot above).
</p><p>
Inserting verification points during test recording is very convenient.
Here we inserted only one, but we can insert as many as we like as
often as we like during the test recording process. However, sometimes
we might forget to insert a verification, or later on we might want to
insert a new verification. We can easily insert additional verifications
into a recorded test script as we will see in the next section, <a class="xref" href="tutorials-android.html#tut-android-verification-points" title="4.12.1.4. Inserting Additional Verification Points">Inserting Additional Verification Points (Section 4.12.1.4)</a>.
</p><p>
Before going further we will look at how to record a test from the
command line. Then we will see how to run a test, and we will also
look at some of the code that <span class="emphasis"><em>Squish</em></span> generated to record the test and
discuss some of its features.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: For command-line users"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></img></td><th align="left"><span class="emphasis"><em>For command-line users</em></span></th></tr><tr><td align="left" valign="top"><p>
First and foremost, the <span class="application">squishserver</span> must always be running when
recording or running a test. This is handled automatically by the <span class="application">Squish IDE</span>,
but for command line users the <span class="application">squishserver</span> must be started manually.
(See <a class="xref" href="rg-cmdline.html#rgc-squishserver" title="7.4.4. squishserver">squishserver (Section 7.4.4)</a> for further details.)
</p><p>
To record a test from the command line we execute the <span class="application">squishrunner</span>
program and specify the test suite we want to record inside and the name
we want to give to the test case. For example (assuming we are in the
directory that contains the test suite's directory):
</p><pre class="screen">
squishrunner --testsuite suite_AddressBook_py --record tst_general --useWaitFor
</pre><p>
It is always best to record using the <code class="option">--useWaitFor</code>
option since this records calls to the <a class="xref" href="rgs-squish.html#waitForObject-function"><code class="function">waitForObject</code></a> function which is more reliable
than using the <a class="xref" href="rgs-squish.html#snooze-function"><code class="function">snooze</code></a> function which for
historical reasons is the default. (Note that the <span class="application">Squish IDE</span> automatically
uses the <a class="xref" href="rgs-squish.html#waitForObject-function"><code class="function">waitForObject</code></a> function.)
</p><p>
When you have multiple devices and/or emulators attached, then you
need to specify the target using <code class="option">--device <span class="emphasis"><em>some-device</em></span></code>
</p></td></tr></table></div><h5><a id="idp43409264"></a> Running the Test </h5><p>
To run a test case in the IDE just click the <span class="guibutton">Run Test</span> (<span class="guiicon"><img src="images/ide/run.png"></img></span>) that appears
when the test case is hovered or selected in the <a class="xref" href="ide.views.html#ide.the-test-suites.view" title="8.2.19. Test Suites view">Test Suites view (Section 8.2.19)</a>.
When we have two or more test cases, we can run them all, one after another,
(or only those that are checked) by clicking <span class="guibutton">Run Test Suite</span> (<span class="guiicon"><img src="images/ide/run_test_suite.png"></img></span>).
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: For command-line users"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></img></td><th align="left"><span class="emphasis"><em>For command-line users</em></span></th></tr><tr><td align="left" valign="top"><p>
As noted earlier, the <span class="application">squishserver</span> must always be running when
recording or running a test, or the <code class="code">--local</code> option
be provided to <span class="application">squishrunner</span>. (See <a class="xref" href="rg-cmdline.html#rgc-squishserver" title="7.4.4. squishserver">squishserver (Section 7.4.4)</a>
for further details.)
</p><p>
To play back a recorded test from the command line we execute the
<span class="application">squishrunner</span> program and specify the test suite our recorded script is
in and the test case we want to play. For example (assuming we are in
the directory that contains the test suite's directory):
</p><pre class="screen">
squishrunner --testsuite suite_AddressBook_py --testcase tst_general --local
</pre><p>
When you have multiple devices and/or emulators attached, then you
need to specify the target using <code class="option">--device some-device</code>
</p></td></tr></table></div><p>
If you look at the code in the screenshot (or the code snippet shown
below) you will see that it consists of lots of <a class="xref" href="rgs-squish.html#waitForObject-function"><code class="function">waitForObject</code></a> calls as parameters to various
other calls such as <a class="xref" href="rgs-androidconvenience.html#android-openMenu-function"><code class="function">openMenu</code></a>,
<a class="xref" href="rgs-androidconvenience.html#android-tapMenuItem-function"><code class="function">tapMenuItem</code></a>, <a class="xref" href="rgs-androidconvenience.html#android-tapObject-function"><code class="function">tapObject</code></a>, and <a class="xref" href="rgs-androidconvenience.html#android-type-function"><code class="function">type</code></a>. The <a class="xref" href="rgs-squish.html#waitForObject-function"><code class="function">waitForObject</code></a> function waits until a GUI object
is ready to be interacted with (i.e., becomes visible and enabled), and
is then followed by some function that interacts with the object. The
typical interactions are activate (pop-up) a menu, tap a menu option
or a button, or type in some text. (For a complete overview of
<span class="emphasis"><em>Squish</em></span>'s script commands see the <a class="xref" href="users-guide.html" title="Chapter 5. User Guide">User Guide (Chapter 5)</a>, the
<a class="xref" href="api.man.html" title="Chapter 6. API Reference Manual">API Reference Manual (Chapter 6)</a>, and the <a class="xref" href="ref.man.html" title="Chapter 7. Tools Reference Manual">Tools Reference Manual (Chapter 7)</a>. Objects are
identified by names that <span class="emphasis"><em>Squish</em></span> generates. (See <a class="xref" href="ug-accessing-objects.html" title="5.1. How to Identify and Access Objects">How to Identify and Access Objects (Section 5.1)</a> for full details.)
</p><p>
The generated code is about 23 lines of code. Here's an extract that
just shows how <span class="emphasis"><em>Squish</em></span> records tapping an address entry, changing
the surname, and tapping Save at the end to close the page and update
the table.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Scripting Language Support"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></img></td><th align="left">Scripting Language Support</th></tr><tr><td align="left" valign="top"><p>
Although the screenshots only show the Python test suite in action, for
the code snippets quoted here and throughout the tutorial, we show the
code for all the scripting languages that <span class="emphasis"><em>Squish</em></span> supports. In practice
you would normally only use one of them of course, so feel free to just
look at the snippets in the language you are interested in and skip the
others. (In the HTML version of this manual you can use the combobox at
the top of the page to select the language you use—this will hide
the code snippets in other languages.)
</p></td></tr></table></div><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

    tapObject(waitForObject(names.abdulWahhabText), 34, 10);
    tapObject(waitForObject(names.editAddressSurnameEdit), 150, 15);
    type(waitForObject(names.editAddressSurnameEdit), "&lt;Backspace&gt;");
    type(waitForObject(names.editAddressSurnameEdit), "&lt;Backspace&gt;");
    type(waitForObject(names.editAddressSurnameEdit), "&lt;Backspace&gt;");
    type(waitForObject(names.editAddressSurnameEdit), "&lt;Backspace&gt;");
    type(waitForObject(names.editAddressSurnameEdit), "&lt;Backspace&gt;");
    type(waitForObject(names.editAddressSurnameEdit), "&lt;Backspace&gt;");
    type(waitForObject(names.editAddressForenameEdit), "Doe");
    tapObject(waitForObject(names.editAddressSaveButton), 20, 10);
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

    tapObject(waitForObject($Names::abdul_wahhab_text), 34, 10);
    tapObject(waitForObject($Names::edit_address_surname_edit), 150, 15);
    type(waitForObject($Names::edit_address_surname_edit), "&lt;Backspace&gt;");
    type(waitForObject($Names::edit_address_surname_edit), "&lt;Backspace&gt;");
    type(waitForObject($Names::edit_address_surname_edit), "&lt;Backspace&gt;");
    type(waitForObject($Names::edit_address_surname_edit), "&lt;Backspace&gt;");
    type(waitForObject($Names::edit_address_surname_edit), "&lt;Backspace&gt;");
    type(waitForObject($Names::edit_address_surname_edit), "&lt;Backspace&gt;");
    type(waitForObject($Names::edit_address_forename_edit), "Doe");
    tapObject(waitForObject($Names::edit_address_save_button), 20, 10);
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

    tapObject(waitForObject(names.abdul_Wahhab_Text), 34, 10)
    tapObject(waitForObject(names.edit_Address_Surname_Edit), 150, 15)
    type(waitForObject(names.edit_Address_Surname_Edit), "&lt;Backspace&gt;")
    type(waitForObject(names.edit_Address_Surname_Edit), "&lt;Backspace&gt;")
    type(waitForObject(names.edit_Address_Surname_Edit), "&lt;Backspace&gt;")
    type(waitForObject(names.edit_Address_Surname_Edit), "&lt;Backspace&gt;")
    type(waitForObject(names.edit_Address_Surname_Edit), "&lt;Backspace&gt;")
    type(waitForObject(names.edit_Address_Surname_Edit), "&lt;Backspace&gt;")
    type(waitForObject(names.edit_Address_Forename_Edit), "Doe")
    tapObject(waitForObject(names.edit_Address_Save_Button), 20, 10)
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

    tapObject(waitForObject(Names::Abdul_Wahhab_Text), 34, 10)
    tapObject(waitForObject(Names::Edit_Address_Surname_Edit), 150, 15)
    type(waitForObject(Names::Edit_Address_Surname_Edit), "&lt;Backspace&gt;")
    type(waitForObject(Names::Edit_Address_Surname_Edit), "&lt;Backspace&gt;")
    type(waitForObject(Names::Edit_Address_Surname_Edit), "&lt;Backspace&gt;")
    type(waitForObject(Names::Edit_Address_Surname_Edit), "&lt;Backspace&gt;")
    type(waitForObject(Names::Edit_Address_Surname_Edit), "&lt;Backspace&gt;")
    type(waitForObject(Names::Edit_Address_Surname_Edit), "&lt;Backspace&gt;")
    type(waitForObject(Names::Edit_Address_Forename_Edit), "Doe")
    tapObject(waitForObject(Names::Edit_Address_Save_Button), 20, 10)
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

    invoke tapObject [waitForObject $names::Abdul_Wahhab_Text] 34 10
    invoke tapObject [waitForObject $names::Edit_Address_Surname_Edit] 150 15
    invoke type [waitForObject $names::Edit_Address_Surname_Edit] "&lt;Backspace&gt;"
    invoke type [waitForObject $names::Edit_Address_Surname_Edit] "&lt;Backspace&gt;"
    invoke type [waitForObject $names::Edit_Address_Surname_Edit] "&lt;Backspace&gt;"
    invoke type [waitForObject $names::Edit_Address_Surname_Edit] "&lt;Backspace&gt;"
    invoke type [waitForObject $names::Edit_Address_Surname_Edit] "&lt;Backspace&gt;"
    invoke type [waitForObject $names::Edit_Address_Surname_Edit] "&lt;Backspace&gt;"
    invoke type [waitForObject $names::Edit_Address_Forename_Edit] "Doe"
    invoke tapObject [waitForObject $names::Edit_Address_Save_Button] 20 10
</pre></div><p>
As you can see the tester used touch to set the input focus on an edit
field. If the tester had
moved the focus by using the cursor keys from a hardware keyboard, the
outcome would be the same, but of course <span class="emphasis"><em>Squish</em></span> will
have recorded the actual actions that were taken.
</p><p>
Notice in the code snippet that there are no explicit delays. (It is
possible to force a delay using <span class="emphasis"><em>Squish</em></span>'s <a class="xref" href="rgs-squish.html#snooze-function"><code class="function">snooze</code></a> function.) This is because the <a class="xref" href="rgs-squish.html#waitForObject-function"><code class="function">waitForObject</code></a> function delays until the object it
is given is ready—thus allowing <span class="emphasis"><em>Squish</em></span> to run as fast as the GUI
toolkit can cope with, but no faster.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note:  Object Names "><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></img></td><th align="left"> Object Names </th></tr><tr><td align="left" valign="top"><p>
Squish recordings refer to objects using variables that begin with a
<code class="code">names.</code> prefix.
This identifies them as <em class="firstterm">Symbolic Names</em>.
Each variable contains, as a value, the corresponding
<em class="firstterm">Real Name</em>, which can be string-based, or implemented as a
key-value mapping of properties to values. <span class="emphasis"><em>Squish</em></span> supports several naming
schemes, all of which can be used—and mixed—in scripts. The
advantage of using symbolic names is that if the application changes in
a way that results in different names being needed, we can simply
update <span class="emphasis"><em>Squish</em></span>'s Object Map (which relates symbolic names to real
names), and thereby avoid the need to change our test scripts. (See the
<a class="xref" href="rg-objectmap.html" title="7.11. Object Map">Object Map (Section 7.11)</a> and the <a class="xref" href="ide.views.html#ide.the-object-map.view" title="8.2.10. Object Map view">Object Map view (Section 8.2.10)</a> for more about the Object Map.)
</p></td></tr></table></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip:  Editor Context Menu "><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></img></td><th align="left"> Editor Context Menu </th></tr><tr><td align="left" valign="top"><p> When a Symbolic Name is under the cursor, the editor's context menu
allows you to <span class="guimenuitem">Open Symbolic Name</span>, showing its
entry in the <span class="guilabel">Object Map</span>, or <span class="guimenuitem">Convert to Real
Name</span>, which places an inline mapping in your desired script
language at the cursor, allowing you to hand-edit the properties in the script
itself.
</p></td></tr></table></div><p>
Now that we have seen how to record and play back a test and have seen
the code that <span class="emphasis"><em>Squish</em></span> generates, let's go a step further and make sure
that at particular points in the test's execution certain conditions hold.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="tut-android-verification-points"></a>4.12.1.4. Inserting Additional Verification Points</h4></div></div></div><p>
In the previous section we saw how easy it is to insert verification
points during the recording of test scripts. Verification points can
also be inserted into existing test scripts, either by setting a
breakpoint and using the <span class="application">Squish IDE</span>, or simply by editing a test script and
putting in calls to <span class="emphasis"><em>Squish</em></span>'s test functions such as <a class="xref" href="rgs-squish.html#test.compare-function"><code class="function">test.compare</code></a> and <a class="xref" href="rgs-squish.html#test.verify-function"><code class="function">test.verify</code></a>.
</p><p>
<span class="emphasis"><em>Squish</em></span> supports many kinds of verification points: those that verify
that object properties have particular values—known as "Object Property
Verifications"; those that verify that an entire table has the contents
we expect—known as "Table Verifications"; those that verify
that two images match—known as "Screenshot Verifications"; and
a hybrid verification type that includes properties and screenshots
from multiple objects, known as "Visual Verifications".
In addition, it is possible to verify that a search image exists somewhere
on the screen, or that certain text is found by OCR.
The most commonly used kind is object property verifications, and it is
these that we will cover in the tutorial. For further reading, see <a class="xref" href="ug-vps.html" title="5.22. How to Create and Use Verification Points">How to Create and Use Verification Points (Section 5.22)</a>).
</p><p>
In fact, <em class="firstterm">Scriptified property verifications</em> are
simply calls to the <a class="xref" href="rgs-squish.html#test.compare-function"><code class="function">test.compare</code></a> function, with two
arguments—the value of a particular property for a particular
object, and an expected value. We can manually insert calls to the <a class="xref" href="rgs-squish.html#test.compare-function"><code class="function">test.compare</code></a> function in a recorded or hand
written script, or we can get <span class="emphasis"><em>Squish</em></span> to insert them for us using the
IDE. In the previous section we showed how to use the <span class="application">Squish IDE</span> to insert
verifications during recording. Here we will first show how to use the
<span class="application">Squish IDE</span> to insert verifications into an existing test script, and then we
will show how to insert a verification by hand.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note:  New test case: add_address"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></img></td><th align="left"> New test case: add_address</th></tr><tr><td align="left" valign="top"><p>
In preparation for the next step, create a <span class="guibutton">New Script Test Case</span> (<span class="guiicon"><img src="images/ide/new_test_case.png"></img></span>) called
<code class="literal">add_address</code>, and <span class="guibutton">Record</span> (<span class="guiicon"><img src="images/ide/record.png"></img></span>) the adding of an
example entry (<code class="literal">Zikra Glen</code> is the name we picked), then
quitting the AUT. Our subsequent exercises will develop based on this script.
</p></td></tr></table></div><p>
To insert a verification point using the IDE we start by putting a break
point in the script at the point where we want to verify.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/tut-android-breakpoint.png" align="middle"></img><div class="caption"><p>The <span class="application">Squish IDE</span> showing the tst_add_address test case with a breakpoint
</p></div></div></div><p>
As the above screenshot shows, we have set a breakpoint at line 16.
This is done simply by double-clicking, or right-clicking in the gutter (next to
the line number in the editor) and selecting the
<span class="guimenuitem">Add Breakpoint</span> context menu item.
We chose this line because it follows the script lines
where the address is saved, so at this point (just before
invoking the menu to quit the application), the first address
should be that of "Zikra Glen". (Note that your line number may be
different if you recorded the test in a different way, for example,
using keyboard shortcuts rather than clicking menu items.)
</p><p>
Having set the breakpoint, we now run the test as usual by clicking the
<span class="guibutton">Run Test</span> (<span class="guiicon"><img src="images/ide/run.png"></img></span>) button, or by clicking the
<span class="guimenu">Run</span>|<span class="guimenuitem">Run Test Case
</span> menu option. Unlike a normal test run, the
test will stop when the breakpoint is reached (i.e., at line 16, or at
whatever line you set), and <span class="emphasis"><em>Squish</em></span>'s main window will reappear (which
will probably obscure the AUT). At this point the <span class="application">Squish IDE</span> will
automatically switch to the <a class="xref" href="ide.main.window.html#ide.squish.test.debugging.perspective" title="8.1.2.3. Squish Test Debugging Perspective">Squish Test Debugging Perspective (Section 8.1.2.3)</a>.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Perspectives and Views"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></img></td><th align="left">Perspectives and Views</th></tr><tr><td align="left" valign="top"><p>
The <span class="application">Squish IDE</span> works just like the <a class="ulink" href="https://en.wikipedia.org/wiki/Eclipse_(software)" target="_blank">
Eclipse IDE</a>. This provides a sophisticated user interface.
If you aren't used to Eclipse it is crucial to understand one key concept:
<span class="emphasis"><em>Views</em></span> and <span class="emphasis"><em>Perspectives</em></span>. In
Eclipse (and therefore in the <span class="application">Squish IDE</span>), a
<span class="emphasis"><em>View</em></span> is essentially a child window (perhaps a dock
window, or a tab in an existing window). And a
<span class="emphasis"><em>Perspective</em></span> is a collection of Views arranged
together. Both are accessible through the
<span class="guimenuitem">Window</span> menu.
</p><p>
The <span class="application">Squish IDE</span> is supplied with three Perspectives—the <a class="xref" href="ide.main.window.html#ide.squish.test.management.perspective" title="8.1.2.2. Squish Test Management Perspective">Squish Test Management Perspective (Section 8.1.2.2)</a> (which is the
Perspective that the <span class="application">Squish IDE</span> starts with, and the one we have seen in all
previous screenshots), <a class="xref" href="ide.main.window.html#ide.squish.test.debugging.perspective" title="8.1.2.3. Squish Test Debugging Perspective">Squish Test Debugging Perspective (Section 8.1.2.3)</a>, and <a class="xref" href="ide.main.window.html#ide.squish.spy.perspective" title="8.1.2.1. Squish Spy Perspective">Squish Spy Perspective (Section 8.1.2.1)</a>. You can change these
Perspectives to include additional Views (or to get rid of any Views
that you don't want), and you can create your own Perspectives with
exactly the Views you want. So if your windows change dramatically it
just means that the Perspective changed; you can always use the
<span class="guimenuitem">Window</span> menu to change back to the Perspective
you want. In practice, <span class="emphasis"><em>Squish</em></span> will automatically change perspective to
reflect the current situation, so it isn't really necessary to change
perspective manually.
</p></td></tr></table></div><p>
As the screenshot below shows, when <span class="emphasis"><em>Squish</em></span> stops at a breakpoint
the <span class="application">Squish IDE</span> automatically changes to the <a class="xref" href="ide.main.window.html#ide.squish.test.debugging.perspective" title="8.1.2.3. Squish Test Debugging Perspective">Squish Test Debugging Perspective (Section 8.1.2.3)</a>. The perspective shows
the <a class="xref" href="ide.views.html#ide.the-variables.view" title="8.2.21. Variables view">Variables view (Section 8.2.21)</a>, the <a class="xref" href="ide.views.html#ide.the-editor.view" title="8.2.6. Editor view">Editor view (Section 8.2.6)</a>, the <a class="xref" href="ide.views.html#ide.the-debug.view" title="8.2.5. Debug view">Debug view (Section 8.2.5)</a>, the <a class="xref" href="ide.views.html#ide.the-application-objects.view" title="8.2.1. Application Objects view">Application Objects view (Section 8.2.1)</a>, and the <a class="xref" href="ide.views.html#ide.the-properties.view" title="8.2.12. Properties view">Properties view (Section 8.2.12)</a>, <a class="xref" href="ide.views.html#ide.the-methods.view" title="8.2.9. Methods view">Methods view (Section 8.2.9)</a>, and <a class="xref" href="ide.views.html#ide.the-test-results.view" title="8.2.18. Test Results view">Test Results view (Section 8.2.18)</a>.
</p><p>
To insert a property verification point we must first decide (by selecting)
which object contains the property of interest, and then we must
<span class="emphasis"><em>check</em></span> the property of interest.
We can expand items in the <span class="guilabel">Application Objects</span> view until
we find the object we want to verify, or use the <a class="xref" href="ide.views.html#object-picker">Object Picker</a> (<span class="guiicon"><img src="images/ide/pick-application-object.png"></img></span>) to find it visually in the GUI.
In this example, we want to verify the first row's <span class="property">text</span>, so
we expand the <code class="code">AddressBook</code> item, and its child items
until we find the <code class="classname">ListView</code>, and within that search for
the objects we are interested in.
Once we click the Zikra object, its properties are shown
in the <a class="xref" href="ide.views.html#ide.the-properties.view" title="8.2.12. Properties view">Properties view (Section 8.2.12)</a> as the screenshot shows.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/tut-android-breakpoint-hit.png" align="middle"></img><div class="caption">Finding an object to verify in the Application Objects view
</div></div></div><p>
The normal <a class="xref" href="ide.main.window.html#ide.squish.test.management.perspective" title="8.1.2.2. Squish Test Management Perspective">Squish Test Management Perspective (Section 8.1.2.2)</a> can
be returned to at any time by choosing it from the
<span class="guimenuitem">Window</span> menu (or by clicking its toolbar
button), although the <span class="application">Squish IDE</span> will automatically return to it if you stop
the script or run it to completion.
</p><p>
Here, we can see that the <span class="property">text</span> property of this
<code class="code">TextView</code> item has the value “<span class="quote">Zikra</span>”. To make sure that
this is verified every time the test is run, click this
<code class="code">TextView</code> item in the <a class="xref" href="ide.views.html#ide.the-application-objects.view" title="8.2.1. Application Objects view">Application Objects view (Section 8.2.1)</a> to make its properties
appear, and then click the <span class="property">text</span> property to check its
check box. After we check it, the <a class="xref" href="ide.views.html#ide.verification.point.creator.view" title="8.2.22. Verification Point Creator view">Verification Point Creator view (Section 8.2.22)</a> appears as shown in the
screenshot.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/tut-android-add-vp1.png" align="middle"></img><div class="caption">Choosing a property value to verify
</div></div></div><p>
At this point, the verification point has <span class="emphasis"><em>not</em></span> yet been
added to the test script. We could easily add it by clicking the
<span class="guibutton">Save and Insert Verifications</span> button.
But before doing that we'll add one more thing to be verified.
</p><p>
Scroll down and click the “<span class="quote">Glen</span>” <code class="classname">TextView</code> item
in the <a class="xref" href="ide.views.html#ide.the-application-objects.view" title="8.2.1. Application Objects view">Application Objects view (Section 8.2.1)</a>; then click its
<span class="property">text</span> property. Now both verifications will appear in the
<a class="xref" href="ide.views.html#ide.verification.point.creator.view" title="8.2.22. Verification Point Creator view">Verification Point Creator view (Section 8.2.22)</a> as the screenshot shows.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/tut-android-add-vp2.png" align="middle"></img><div class="caption">Choosing several property values to verify
</div></div></div><p>
We have now said that we expect these properties to have the values
shown, that is, a forename of “<span class="quote">Zikra</span>” and surname of
“<span class="quote">Glen</span>”. We <span class="emphasis"><em>must</em></span> click the
<span class="guibutton">Insert</span> button to actually insert the verification
point, so do that now.
</p><p>
We don't need to continue running the test now, so we can either stop
running the test at this point (by clicking the
<span class="guibutton">Stop</span> toolbar button), or we can continue (by
clicking the <span class="guibutton">Resume</span> button).
</p><p>
Once we have finished inserting verifications and stopped or finished
running the test we should now disable the break point. Just right click
the break point and click the <span class="guimenuitem">Disable Breakpoint</span>
menu option in the context menu. We are now ready to run the test without any
breakpoints but with the verification points in place. Click the
<span class="guibutton">Run Test</span> button. This time we will get some additional
test results—as the screenshot shows—one of which we have expanded
to show its details. (We have also selected the lines of code that <span class="emphasis"><em>Squish</em></span>
inserted to perform the verifications—notice that the code is structurally
identical to the code inserted during recording.)
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/tut-android-run-vp1.png" align="middle"></img><div class="caption">The newly inserted verification points in action
</div></div></div><p>
These particular verification points generate two tests comparing
the forename and surname of the newly inserted entry.
</p><p>
Another way to insert verification points is to insert them in code
form. In theory we can just add our own calls to <span class="emphasis"><em>Squish</em></span>'s test
functions such as <a class="xref" href="rgs-squish.html#test.compare-function"><code class="function">test.compare</code></a> and <a class="xref" href="rgs-squish.html#test.verify-function"><code class="function">test.verify</code></a> anywhere we like in an existing
script. In practice it is best to make sure that <span class="emphasis"><em>Squish</em></span> knows about
the objects we want to verify first so that it can find them when the
test is run. This involves a very similar procedure to inserting them using the <span class="application">Squish IDE</span>.
First we set a breakpoint where we intend adding our verifications. Then
we run the test script until it stops. Next, we navigate in the
<a class="xref" href="ide.views.html#ide.the-application-objects.view" title="8.2.1. Application Objects view">Application Objects view (Section 8.2.1)</a> until we find the
object we want to verify. At this point it is wise to right-click the object we
are interested in and click the <span class="guimenuitem">Add to Object Map</span>
context menu action. This will ensure that <span class="emphasis"><em>Squish</em></span> can access the object. Then
right click again and select the
<span class="guimenuitem">Copy Symbolic Name</span> context menu
action—this gives us the name of the object that <span class="emphasis"><em>Squish</em></span>
will use to identify it. Now we can edit the test script to add in our
own verification and finish the execution. (Don't forget to disable the break
point once it isn't needed any more.)
</p><p>
Although we can write our test script code to be exactly the same style
as the automatically generated code, it is usually clearer and easier to
do things in a slightly different style, as we will explain in a moment.
</p><p>
For our manual verifications we want to check the number of addresses
present in the list after inserting an entry. The screenshot
shows two of the lines of code we entered to get the
verification, plus the results of running the test script.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/tut-android-run-vp2.png" align="middle"></img><div class="caption">Manually entered verification points in action
</div></div></div><p>
When writing scripts by hand, we use <span class="emphasis"><em>Squish</em></span>'s <code class="code">test</code>
module's functions to verify conditions at certain points during our
test script's execution. As the screenshot shows, we begin by retrieving
a reference to the object we are interested
in. Using the <a class="xref" href="rgs-squish.html#waitForObject-function"><code class="function">waitForObject</code></a> function is
standard practice for manually written test scripts. This function waits
for the object to be available (i.e., visible and enabled), and then
returns a reference to it. (Otherwise it times out and raises a
catchable exception.) We then use this reference to access the item's
properties—in this case the <code class="classname">ListView</code>'s
<span class="property">rowCount</span>—and <code class="function">test.compare</code> its
value to what we expect it to be.
</p><p>
The coding pattern is very simple: we retrieve a reference to the object
we are interested in and then verify its properties using one of
<span class="emphasis"><em>Squish</em></span>'s verification functions. And we can, of course, call methods
on the object to interact with it if we wish.
</p><p>
We will see more examples of manually written code shortly, in the
<a class="xref" href="tutorials-android.html#tut-android-creating-manual-tests" title="4.12.1.5. Creating Tests by Hand">Creating Tests by Hand (Section 4.12.1.5)</a> section, and
further examples are in the <a class="xref" href="users-guide.html" title="Chapter 5. User Guide">User Guide (Chapter 5)</a>.
</p><p>
For complete coverage of verification points, see <a class="xref" href="ug-vps.html" title="5.22. How to Create and Use Verification Points">How to Create and Use Verification Points (Section 5.22)</a> in the <a class="xref" href="users-guide.html" title="Chapter 5. User Guide">User Guide (Chapter 5)</a>.
</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="test-results-android.1"></a>4.12.1.4.1. Test Results</h5></div></div></div><p>
After each test run finishes, the test results—including those
for the verification points—are shown in the Test Results view at
the bottom of the <span class="application">Squish IDE</span>.
</p><p>
This is a detailed report of the test run and would also contain details
of any failures or errors, etc. If you click on a <span class="guilabel">Test
Results</span> item, the <span class="application">Squish IDE</span> highlights the script line which generated
the test result. And if you expand a Test Results item, you can see additional
details of the test.
</p><div class="sidebar"><p class="title"><b>Processing Test Results</b></p><p>
<span class="emphasis"><em>Squish</em></span>'s interface for test results is very flexible. By implementing
custom report generators it is possible to process test results in many
different ways, for example to store them in a database, or to output
them as HTML files. The default report generator simply prints the
results to <code class="filename">stdout</code> when <span class="emphasis"><em>Squish</em></span> is run from the
command line, or to the Test Results view when <span class="emphasis"><em>Squish</em></span>'s IDE is being
used. You can save the test results from the <span class="emphasis"><em>Squish</em></span> IDE as XML by
right clicking on the Test Results and choosing the <span class="guimenuitem">Export
Results...</span> menu option. For a list of report generators,
see <a class="xref" href="rg-cmdline.html#rg-squishrunner-report-generators" title="7.4.3.6.  squishrunner --reportgen: Generating Reports"> <code class="option">squishrunner --reportgen</code>: Generating Reports (Section 7.4.3.6)</a>. It is also possible to
log test results directly to a database; see <a class="xref" href="how.to.access.databases.from.squish.test.scripts.html" title="5.18. How to Access Databases from Squish Test Scripts">How to Access Databases from Squish Test Scripts (Section 5.18)</a>.
</p><p>
If you run tests on the command line using <span class="application">squishrunner</span>, you can also
export the results in different formats and save them to files. See the
sections <a class="xref" href="rg-regressiontesting.html#rgr-processresults" title="7.1.3. Processing Test Results">Processing Test Results (Section 7.1.3)</a> and <a class="xref" href="ugs-teststatements.html" title="5.9. How to Use Test Statements">How to Use Test Statements (Section 5.9)</a> in the <a class="xref" href="users-guide.html" title="Chapter 5. User Guide">User Guide (Chapter 5)</a> for
more information.
</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="tut-android-creating-manual-tests"></a>4.12.1.5. Creating Tests by Hand</h4></div></div></div><p>
Now that we have seen how to record a test and modify it by inserting
verification points, we are ready to see how to create tests manually.
The easiest way to do this is to modify and refactor recorded tests,
although it is also perfectly possible to create manual tests from
scratch.
</p><p>
Potentially the most challenging part of writing manual tests is to use
the right object names, but in practice, this is rarely a problem. We
can either copy the symbolic names that <span class="emphasis"><em>Squish</em></span> has already added to
the Object Map when recording previous tests, or we can copy object
names directly from recorded tests. And if we haven't recorded any tests
and are starting from scratch we can use the <span class="application">Spy</span>. We do this by
clicking the <span class="guibutton">Launch AUT</span> toolbar button. This
starts the AUT and switches to the <a class="xref" href="ide.main.window.html#ide.squish.spy.perspective" title="8.1.2.1. Squish Spy Perspective">Squish Spy Perspective (Section 8.1.2.1)</a>. We can then interact with the
AUT until the object we are interested in is visible. Then, inside the
<span class="application">Squish IDE</span> we can navigate to the object in the Application Objects view and
use the context menu to both add the object to the Object Map (so that
<span class="emphasis"><em>Squish</em></span> will remember it) and to the clipboard (so that we can paste it
into our test script). And at the end we can click the <span class="guibutton">Quit
AUT</span> toolbar button to terminate the AUT and return <span class="emphasis"><em>Squish</em></span>
to the <a class="xref" href="ide.main.window.html#ide.squish.test.management.perspective" title="8.1.2.2. Squish Test Management Perspective">Squish Test Management Perspective (Section 8.1.2.2)</a>. (See
<a class="xref" href="ug-editdebug.html#uged-spy" title="5.21.3. How to Use the Spy">How to Use the Spy (Section 5.21.3)</a> in the <a class="xref" href="users-guide.html" title="Chapter 5. User Guide">User Guide (Chapter 5)</a> for more
details on using the <span class="application">Spy</span>.)
</p><p>
We can open the <span class="guilabel">Object Map</span> editor by clicking the
<span class="guibutton">Object Map</span> (<span class="guiicon"><img src="images/ide/object_map_button.png"></img></span>) toolbar button (see also, the <a class="xref" href="ide.views.html#ide.the-object-map.view" title="8.2.10. Object Map view">Object Map view (Section 8.2.10)</a>). Every application object that
<span class="emphasis"><em>Squish</em></span> interacts with is listed here, either as a top-level object, or
as a child object (the view is a tree view). We can retrieve the
symbolic name used by <span class="emphasis"><em>Squish</em></span> in recorded scripts by right-clicking the
object we are interested in and then clicking the context menu's
<span class="guimenuitem">Copy Symbolic Name</span> action. This is useful for when we
want to modify existing test scripts or when we want to create test scripts from
scratch, as we will see later on in the tutorial.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/tut-android-omap.png" align="middle"></img><div class="caption"><p><span class="emphasis"><em>Squish</em></span>'s Object Map
</p></div></div></div><p>
Alternatively, real names can be used, also by right-clicking the
object we are interested in and then clicking the context menu's
<span class="guimenuitem">Copy Real Name</span>. For this <code class="classname">List</code>
object the 'real name' is a mapping of native script-language key-value pairs.
Since object references (e.g. for <span class="property">container</span>) can use
symbolic or real names for values, the following three
<code class="function">waitForObject</code> calls are in the context of this test suite
equivalent:
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">
waitForObject(names.address_Book_List)
waitForObject({"container": names.address_Book_Activity, "type": "List", "visible": True})
waitForObject({"container": {"text": "Address Book", "type": "Activity", "visible": True}, "type": "List", "visible": True})
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">
waitForObject(names.addressBookList);
waitForObject({"container": names.addressBookActivity, "type": "List", "visible": true});
waitForObject({"container": {"text": "Address Book", "type": "Activity", "visible": true}, "type": "List", "visible": true});
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">
waitForObject($Names::address_book_list);
waitForObject({"container" =&gt; $Names::address_book_activity, "type" =&gt; "List", "visible" =&gt; "true"});
waitForObject({"container" =&gt; {"text" =&gt; "Address Book", "type" =&gt; "Activity", "visible" =&gt; "true"}, "type" =&gt; "List", "visible" =&gt; "true"});
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">
waitForObject(Names::Address_Book_List))
waitForObject({:container =&gt; Names::Address_Book_Activity, :type =&gt; "List", :visible =&gt; true}))
waitForObject({:container =&gt; {:text =&gt; "Address Book", :type =&gt; "Activity", :visible =&gt; true}, :type =&gt; "List", :visible =&gt; true}))
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">
waitForObject $names::Address_Book_List
waitForObject [::Squish::ObjectName container $names::Address_Book_Activity type List visible true]
waitForObject [::Squish::ObjectName container [::Squish::ObjectName text {Address Book} type Activity visible true] type List visible true]
</pre></div><p>
This can be useful when dynamically creating object names.
When using real names directly, no entry from the object map is needed. See
<a class="xref" href="ug-accessing-objects.html#ug-how-to-access-named-objects" title="5.1.1. How to Access Named Objects">How to Access Named Objects (Section 5.1.1)</a> for more information.
</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="tut-android-modifying-and-refactoring-recorded-tests"></a>4.12.1.5.1. Modifying and Refactoring Recorded Tests</h5></div></div></div><p>
Suppose we want to test the AUT's Add functionality by adding three new
addresses. We could of course record such a test, but it is just as easy
to do everything in code. The steps we need the test script to do are:
</p><div class="orderedlist"><ol type="1"><li><p> tap the “<span class="quote">Add Address</span>” button </p></li><li><p> fill in the fields </p></li><li><p> tap the “<span class="quote">Save</span>” button </p></li></ol></div><p> We also want to
verify at the start that there are no rows of data and at the end that
there are three rows. We will refactor as we go, to make our code
as neat and modular as possible.
</p><p>
Lets start with the “<span class="quote">tst_add_address</span>” script we created
earlier, and turn this into a function that gets field values as arguments.
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

def addNameAndAddress(fields):
    forname,surname,email,phone = fields
    tapObject(waitForObject(names.address_Book_Add_Address_Button))
    tapObject(waitForObject(names.edit_Address_Forename_Edit))
    type(waitForObject(names.edit_Address_Forename_Edit), forname)
    tapObject(waitForObject(names.edit_Address_Surname_Edit))
    type(waitForObject(names.edit_Address_Surname_Edit), surname)
    tapObject(waitForObject(names.edit_Address_Phone_Edit))
    type(waitForObject(names.edit_Address_Phone_Edit), phone)
    tapObject(waitForObject(names.edit_Address_Email_Edit))
    type(waitForObject(names.edit_Address_Email_Edit), email)
    tapObject(waitForObject(names.edit_Address_Save_Button))
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

function addNameAndAddress(fields)
{
    tapObject(waitForObject(names.addressBookAddAddressButton));
    tapObject(waitForObject(names.editAddressForenameEdit));
    type(waitForObject(names.editAddressForenameEdit), fields[0]);
    tapObject(waitForObject(names.editAddressSurnameEdit));
    type(waitForObject(names.editAddressSurnameEdit), fields[1]);
    tapObject(waitForObject(names.editAddressPhoneEdit));
    type(waitForObject(names.editAddressPhoneEdit), fields[3]);
    tapObject(waitForObject(names.editAddressEmailEdit));
    type(waitForObject(names.editAddressEmailEdit), fields[2]);
    tapObject(waitForObject(names.editAddressSaveButton));
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

sub addNameAndAddress {
    my ($forname,$surname,$email,$phone) = @_;
    tapObject(waitForObject($Names::address_book_add_address_button));
    tapObject(waitForObject($Names::edit_address_forename_edit));
    type(waitForObject($Names::edit_address_forename_edit), $forname);
    tapObject(waitForObject($Names::edit_address_surname_edit));
    type(waitForObject($Names::edit_address_surname_edit), $surname);
    tapObject(waitForObject($Names::edit_address_phone_edit));
    type(waitForObject($Names::edit_address_phone_edit), $phone);
    tapObject(waitForObject($Names::edit_address_email_edit));
    type(waitForObject($Names::edit_address_email_edit), $email);
    tapObject(waitForObject($Names::edit_address_save_button));
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

def addNameAndAddress(fields)
    tapObject(waitForObject(Names::Address_Book_Add_Address_Button))
    tapObject(waitForObject(Names::Edit_Address_Forename_Edit))
    type(waitForObject(Names::Edit_Address_Forename_Edit), fields[0])
    tapObject(waitForObject(Names::Edit_Address_Surname_Edit))
    type(waitForObject(Names::Edit_Address_Surname_Edit), fields[1])
    tapObject(waitForObject(Names::Edit_Address_Phone_Edit))
    type(waitForObject(Names::Edit_Address_Phone_Edit), fields[3])
    tapObject(waitForObject(Names::Edit_Address_Email_Edit))
    type(waitForObject(Names::Edit_Address_Email_Edit), fields[2])
    tapObject(waitForObject(Names::Edit_Address_Save_Button))
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

proc addNameAndAddress {fields} {
    invoke tapObject [waitForObject $names::Address_Book_Add_Address_Button]
    invoke tapObject [waitForObject $names::Edit_Address_Forename_Edit]
    invoke type [waitForObject $names::Edit_Address_Forename_Edit] [lindex $fields 0]
    invoke tapObject [waitForObject $names::Edit_Address_Surname_Edit]
    invoke type [waitForObject $names::Edit_Address_Surname_Edit] [lindex $fields 1]
    invoke tapObject [waitForObject $names::Edit_Address_Phone_Edit]
    invoke type [waitForObject $names::Edit_Address_Phone_Edit] [lindex $fields 3]
    invoke tapObject [waitForObject $names::Edit_Address_Email_Edit]
    invoke type [waitForObject $names::Edit_Address_Email_Edit] [lindex $fields 2]
    invoke tapObject [waitForObject $names::Edit_Address_Save_Button]
}
</pre></div><p>
Next we call this function with an array of list of fields from the
<code class="function">main</code> function.
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

import names

def main():
    startApplication("com.froglogic.addressbook")
    table = waitForObject(names.address_Book_List)
    test.verify(table.rowCount == 0)
    data = [("Andy", "Beach", "andy.beach@nowhere.com", "555 123 6786"),
            ("Candy", "Deane", "candy.deane@nowhere.com", "555 234 8765"),
            ("Ed", "Fernleaf", "ed.fernleaf@nowhere.com", "555 876 4654")]
    for fields in data:
        addNameAndAddress(fields)
    test.compare(table.rowCount, len(data))
    openMenu(waitForObject(names.address_Book_Activity))
    tapMenuItem(waitForObject(names.address_Book_Activity), "Quit")
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

import * as names from 'names.js';

function main()
{
    startApplication("com.froglogic.addressbook");
    var table = waitForObject(names.addressBookList);
    test.verify(table.rowCount == 0);
    var data = [["Andy", "Beach", "andy.beach@nowhere.com", "555 123 6786"],
            ["Candy", "Deane", "candy.deane@nowhere.com", "555 234 8765"],
            ["Ed", "Fernleaf", "ed.fernleaf@nowhere.com", "555 876 4654"]];
    for (var row = 0; row &lt; data.length; ++row) {
        addNameAndAddress(data[row]);
    }
    test.compare(table.rowCount, data.length);
    openMenu(waitForObject(names.addressBookActivity));
    tapMenuItem(waitForObject(names.addressBookActivity), "Quit");
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

require 'names.pl';

sub main() {
    startApplication("com.froglogic.addressbook");
    my $table = waitForObject($Names::address_book_list);
    test::verify($table-&gt;rowCount == 0);
    my @data = (['Andy', 'Beach', 'andy.beach@nowhere.com', '555 123 6786'],
            ['Candy', 'Deane', 'candy.deane@nowhere.com', '555 234 8765'],
            ['Ed', 'Fernleaf', 'ed.fernleaf@nowhere.com', '555 876 4654']);
    foreach $line (@data) {
        addNameAndAddress(@$line);
    }
    test::compare($table-&gt;rowCount, scalar(@data));
    openMenu(waitForObject($Names::address_book_activity));
    tapMenuItem(waitForObject($Names::address_book_activity), "Quit");
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

require 'names';
require 'squish'
include Squish

def main
    startApplication("com.froglogic.addressbook")
    table = waitForObject(Names::Address_Book_List)
    Test.verify(table.rowCount == 0)
    data = [["Andy", "Beach", "andy.beach@nowhere.com", "555 123 6786"],
            ["Candy", "Deane", "candy.deane@nowhere.com", "555 234 8765"],
            ["Ed", "Fernleaf", "ed.fernleaf@nowhere.com", "555 876 4654"]]
    data.each do |address|
        addNameAndAddress(address)
    end
    Test.compare(table.rowCount, data.length)
    openMenu(waitForObject(Names::Address_Book_Activity))
    tapMenuItem(waitForObject(Names::Address_Book_Activity), "Quit")
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

source [findFile "scripts" "names.tcl"]

proc main {} {
    startApplication "com.froglogic.addressbook"
    set table [waitForObject $names::Address_Book_List]
    test compare [property get $table rowCount] 0
    set data [list \
        [list "Andy" "Beach" "andy.beach@nowhere.com" "555 123 6786"]   \
        [list "Candy" "Deane" "candy.deane@nowhere.com" "555 234 8765"] \
        [list "Ed" "Fernleaf" "ed.fernleaf@nowhere.com" "555 876 4654"] ]
    for {set i 0} {$i &lt; [llength $data]} {incr i} {
        addNameAndAddress [lindex $data $i]
    }
    test compare [property get $table rowCount] [llength $data]
    invoke openMenu [waitForObject $names::Address_Book_Activity]
    invoke tapMenuItem [waitForObject $names::Address_Book_Activity] "Quit"
}
</pre></div><p>
However, one aspect of the test case is not very satisfactory. Although
embedding test data as we did here is sensible for small amounts, it is
rather limiting, especially when we want to use a lot of test data.
In the next section we will create a new version of this test, only this
time we will pull in the data from an external data source.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="tut-android-creating-data-driven-tests"></a>4.12.1.5.2. Creating Data Driven Tests</h5></div></div></div><p>
In the previous section we put three hard-coded names and addresses in
our test. But what if we want to test <span class="emphasis"><em>lots</em></span> of data?
One approach is to import a dataset into <span class="emphasis"><em>Squish</em></span> and use the dataset as
the source of the values we insert into our tests. <span class="emphasis"><em>Squish</em></span> can import
data in
<code class="filename">.tsv</code> (tab-separated values format),
<code class="filename">.csv</code> (comma-separated values format),
<code class="filename">.xls</code>, or <code class="filename">.xlsx</code>  (<span class="trademark">Microsoft</span>® <span class="trademark">Excel</span>™ spreadsheet formats).
<sup>[<a id="idp43561912" href="#ftn.idp43561912" class="footnote">18</a>]</sup>
</p><p>
For the <span class="application">addressbook</span> application we want to
import the <code class="filename">MyAddresses.tsv</code> data file
(Copies of this file are located under
<code class="filename">SQUISHDIR/examples/android/AddressBook/suite_xy/shared/testdata</code>).
To do this we click
<span class="guimenu">File</span>|<span class="guimenuitem">Import Test Resource</span>
to pop-up the <a class="xref" href="ide.dialogs.html#ide.import.squish.resource.dialog" title="8.3.7. Import Squish Resource dialog">Import Squish Resource dialog (Section 8.3.7)</a>.
Inside the dialog click the <span class="guibutton">Browse</span> button to choose the file to
import—in this case <code class="filename">MyAddresses.tsv</code>. Make
sure that the <span class="guilabel">Import As</span> combobox is set to
“<span class="quote">TestData</span>”. By default the <span class="application">Squish IDE</span> will import the test data
just for the current test case, but we want the test data to be
available to all the test suite's test cases: to do this, check the
<span class="guibutton">Copy the file into the Test Suite for Sharing</span> radio
button. Now click <span class="guibutton">Finish</span>. You can now see the file
listed in the <span class="guilabel">Test Suite Resources</span> view (in the
<span class="guilabel">Test Data</span> tab), and if you click the file's name it will be
shown in an <a class="xref" href="ide.views.html#ide.the-editor.view" title="8.2.6. Editor view">Editor view (Section 8.2.6)</a>. The screenshot shows <span class="emphasis"><em>Squish</em></span>
after the test data has been added.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: For command-line users"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></img></td><th align="left"><span class="emphasis"><em>For command-line users</em></span></th></tr><tr><td align="left" valign="top"><p>
It is also possible to import test data outside the <span class="application">Squish IDE</span> using a file
manager (such as File Explorer) or console commands. To do this, create
a directory inside the test suite's directory called
<code class="filename">shared</code>. Now make a directory inside the
<code class="filename">shared</code> directory called
<code class="filename">testdata</code>. Now copy the data file (in this example,
<code class="filename">MyAddresses.tsv</code>) into the
<code class="filename">shared/testdata</code> directory. Now quit the <span class="application">Squish IDE</span> if it
is running and start it up again. If you click the Test Suite Resources
view's Test Data tab you should see the data file. Click the file's name
to see it in an <a class="xref" href="ide.views.html#ide.the-editor.view" title="8.2.6. Editor view">Editor view (Section 8.2.6)</a>.
</p></td></tr></table></div><div class="screenshot"><div class="mediaobject" align="center"><img src="images/tut-android-data-table.png" align="middle"></img><div class="caption"><p><span class="emphasis"><em>Squish</em></span> with some imported test data
</p></div></div></div><p>
Although in real life we would modify our
<code class="filename">tst_add_address</code> test case to use the test data, for the
purpose of the tutorial we will make a new test case called
<code class="filename">tst_adding_data</code> that is a copy of
<code class="filename">tst_add_address</code> and which we will modify to make use of
the test data.
</p><p>
The only function we have to change is <code class="code">main</code>, where
instead of iterating over hard-coded items of data, we iterate over all
the records in the dataset. We also need to update the expected row
count at the end since we are adding a lot more records now.
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

import names

def main():
    startApplication("com.froglogic.addressbook")
    table = waitForObject(names.address_Book_List)
    test.verify(table.rowCount == 0)
    limit = 10 # To avoid testing 100s of rows since that would be boring
    for row, record in enumerate(testData.dataset("MyAddresses.tsv")):
        fields = testData.field(record, "Forename"), testData.field(record, "Surname"), testData.field(record, "Email"), testData.field(record, "Phone")
        addNameAndAddress(fields)
        if row &gt; limit:
            break
    test.compare(table.rowCount, row+1)
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

import * as names from 'names.js';

function main()
{
    startApplication("com.froglogic.addressbook");
    var table = waitForObject(names.addressBookList);
    test.verify(table.rowCount == 0);
    var limit = 10; // To avoid testing 100s of rows since that would be boring
    var records = testData.dataset("MyAddresses.tsv");
    var row = 0;
    for (; row &lt; records.length; ++row) {
        var record = records[row];
        var line = [testData.field(record, "Forename")
                   , testData.field(record, "Surname")
                   , testData.field(record, "Email")
                   , testData.field(record, "Phone")];
        addNameAndAddress(line);
        if (row &gt; limit)
            break;
    }
    test.compare(table.rowCount, row+1);
    openMenu(waitForObject(names.addressBookActivity));
    tapMenuItem(waitForObject(names.addressBookActivity), "Quit");
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

require 'names.pl';

sub main() {
    startApplication("com.froglogic.addressbook");
    my $table = waitForObject($Names::address_book_list);
    test::verify($table-&gt;rowCount == 0);
    my $limit = 10; # To avoid testing 100s of rows since that would be boring
    my @records = testData::dataset("MyAddresses.tsv");
    my $row = 0;
    for (; $row &lt; scalar(@records); $row++) {
        my $record = $records[$row];
        my @line = ( testData::field($record, "Forename")
                   , testData::field($record, "Surname")
                   , testData::field($record, "Email")
                   , testData::field($record, "Phone") );
        addNameAndAddress(@line);
        if ($row &gt; $limit) {
            last;
        }
    }
    test::compare($table-&gt;rowCount, $row+1);
    openMenu(waitForObject($Names::address_book_activity));
    tapMenuItem(waitForObject($Names::address_book_activity), "Quit");
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

require 'squish'
require 'names';
include Squish

def main
    startApplication("com.froglogic.addressbook")
    table = waitForObject(Names::Address_Book_List)
    Test.verify(table.rowCount == 0)
    limit = 10 # To avoid testing 100s of rows since that would be boring
    rows = 0
    TestData.dataset("MyAddresses.tsv").each_with_index do
        |record, row|
        line = [TestData.field(record, "Forename"),
                TestData.field(record, "Surname"),
                TestData.field(record, "Email"),
                TestData.field(record, "Phone")]
        addNameAndAddress(line)
        break if row &gt; limit
        rows += 1
    end
    Test.compare(table.rowCount, rows+1)
    openMenu(waitForObject(Names::Address_Book_Activity))
    tapMenuItem(waitForObject(Names::Address_Book_Activity), "Quit")
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

source [findFile "scripts" "names.tcl"]

proc main {} {
    startApplication "com.froglogic.addressbook"
    set table [waitForObject $names::Address_Book_List]
    test compare [property get $table rowCount] 0
    # To avoid testing 100s of rows since that would be boring
    set limit 10
    set data [testData dataset "MyAddresses.tsv"]
    set columns [llength [testData fieldNames [lindex $data 0]]]
    set row 0
    for {} {$row &lt; [llength $data]} {incr row} {
        set record [lindex $data $row]
        set fields [list \
                    [testData field $record "Forename"]  \
                    [testData field $record "Surname"]   \
                    [testData field $record "Email"]     \
                    [testData field $record "Phone"]]
        addNameAndAddress $fields
        if {$row &gt; $limit} {
            break
        }
    }
    test compare [property get $table rowCount] [expr $row+1]
    invoke openMenu [waitForObject $names::Address_Book_Activity]
    invoke tapMenuItem [waitForObject $names::Address_Book_Activity] "Quit"
}
</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="tut-android-nativeObject"></a>4.12.1.5.3. Using the Android native API</h5></div></div></div><p>
In this section we take a quick look at the <span class="property">nativeObject</span>
property and use it to rewrite a recorded script that scrolls through
the demo list of addresses. This property allows access to the
underlying <span class="trademark">Java</span>™ object of a <span class="emphasis"><em>Squish</em></span> user interface object. The
available properties and methods of these native objects are dynamically
created on use in the scripts. The online <a class="ulink" href="http://developer.android.com/reference/packages.html" target="_blank">Android
developer reference</a> is the place to get documenation about
them.
</p><p>
When recording a test on an item in a list that is only visible when
scrolling the list, we probably get a script that contains the
<a class="xref" href="rgs-androidconvenience.html#android-touchAndDrag-function"><code class="function">touchAndDrag</code></a> function. E.g. here
a small recording:
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

function main() {
    startApplication("com.froglogic.addressbook");
    openMenu(waitForObject(names.addressBookActivity));
    tapMenuItem(waitForObject(names.addressBookActivity), "Demo Data");
    touchAndDrag(waitForObject(names.coonsText), 49, 6, 32, -451);
    touchAndDrag(waitForObject(names.mccullaghText), 105, 19, 13, -252);
    touchAndDrag(waitForObject(names.harrietText), 154, 15, -40, 365);
    touchAndDrag(waitForObject(names.dewarText), 149, 28, -51, 266);
    openMenu(waitForObject(names.addressBookList));
    tapMenuItem(waitForObject(names.addressBookActivity), "Quit");
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

sub main
{
    startApplication("com.froglogic.addressbook");
    openMenu(waitForObject($Names::address_book_activity));
    tapMenuItem(waitForObject($Names::address_book_activity), "Demo Data");
    touchAndDrag(waitForObject($Names::boardus_text), 71, 10, -26, 229);
    touchAndDrag(waitForObject($Names::puckett_text), 61, 25, 14, -257);
    touchAndDrag(waitForObject($Names::burnand_text), 61, 12, 14, -240);
    touchAndDrag(waitForObject($Names::dyson_text), 67, 32, -29, 253);
    touchAndDrag(waitForObject($Names::case_text), 71, 5, 3, 196);
    openMenu(waitForObject($Names::address_book_list));
    tapMenuItem(waitForObject($Names::address_book_activity), "Quit");
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

def main():
    startApplication("com.froglogic.addressbook")
    openMenu(waitForObject(names.address_Book_Activity))
    tapMenuItem(waitForObject(names.address_Book_Activity), "Demo Data")
    touchAndDrag(waitForObject(names.atkinson_Text), 39, 9, 8, -198)
    touchAndDrag(waitForObject(names.harriet_Text), 69, 19, 16, -195)
    touchAndDrag(waitForObject(names.address_Book_List), 582, 556, 5, -251)
    touchAndDrag(waitForObject(names.burnand_Text), 49, 4, -24, 250)
    touchAndDrag(waitForObject(names.address_Book_List), 554, 558, 23, -247)
    openMenu(waitForObject(names.address_Book_List))
    tapMenuItem(waitForObject(names.address_Book_Activity), "Quit")

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

def main
    startApplication("com.froglogic.addressbook")
    openMenu(waitForObject(Names::Address_Book_Activity))
    tapMenuItem(waitForObject(Names::Address_Book_Activity), "Demo Data")
    touchAndDrag(waitForObject(Names::Wasling_Text), 55, 18, 1, -221)
    touchAndDrag(waitForObject(Names::Hullson_Text), 53, 28, 3, -144)
    touchAndDrag(waitForObject(Names::Munford_Text), 62, 7, -12, 323)
    touchAndDrag(waitForObject(Names::Puckett_Text), 55, 6, 2, -170)
    openMenu(waitForObject(Names::Address_Book_List))
    tapMenuItem(waitForObject(Names::Address_Book_Activity), "Quit")
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

proc main {} {
    startApplication "com.froglogic.addressbook"
    invoke openMenu [waitForObject $names::Address_Book_Activity]
    invoke tapMenuItem [waitForObject $names::Address_Book_Activity] "Demo Data"
    invoke touchAndDrag [waitForObject $names::Puckett_Text] 68 4 -14 -175
    invoke touchAndDrag [waitForObject $names::Selby_Text] 65 10 -11 -196
    invoke touchAndDrag [waitForObject $names::Coons_Text] 58 30 8 202
    invoke touchAndDrag [waitForObject $names::Grieve_Text] 37 13 -6 182
    invoke openMenu [waitForObject $names::Address_Book_List]
    invoke tapMenuItem [waitForObject $names::Address_Book_Activity] "Quit"
}
</pre></div><p>
While this replays well as long as the demo list is unchanged, it is
somewhat slow on replay. Also the starting point objects of the
<a class="xref" href="rgs-androidconvenience.html#android-touchAndDrag-function"><code class="function">touchAndDrag</code></a> function may not be
there when replayed with a device or emulator having a smaller vertical
resolution.
A more robust approach would be to search through the items of the list,
scroll the list to it and then tap on the item.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/tut-android-nativeObject.png" align="middle"></img><div class="caption">nativeObject property</div></div></div><p>
We can programmatically scroll the list using the <code class="code">ListView</code>
method
<a class="ulink" href="http://developer.android.com/reference/android/widget/AbsListView.html#smoothScrollToPosition(int)" target="_blank">
smoothScrollToPosition</a>.
For finding the position to scroll to, we show three different approaches.
</p><div class="orderedlist"><ol type="1"><li><p>Using an adapter</p></li><li><p>Changing the object hierarchy during scrolling </p></li><li><p>Searching for an object name while scrolling </p></li></ol></div><p>

</p><p>
More examples for using <span class="property">nativeObject</span> can be found in the section
<a class="xref" href="ug-how.to.use.the.android.api.html#ug-how.to.use.the.android.nativeobject" title="5.7.2. How to Use the nativeObject Property">How to Use the nativeObject Property (Section 5.7.2)</a>.
</p><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a id="tut-android-listview-adapter"></a>4.12.1.5.3.1. Using the adapter of the list</h6></div></div></div><p>
We can use the adapter of this list because the adapter is a <a class="ulink" href="http://developer.android.com/reference/android/widget/SimpleAdapter.html" target="_blank">
SimpleAdapter</a>. It holds a <a class="ulink" href="http://developer.android.com/reference/java/util/List.html" target="_blank">List</a> of
<a class="ulink" href="http://developer.android.com/reference/java/util/Map.html" target="_blank">Map
</a> objects.
</p><p>
Here an example of a function that uses this approach, given a list and
a text to be found:
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

def scrollListToText1(list, text):
    adapter = list.nativeObject.adapter
    for i in range(adapter.getCount()):
        row = adapter.getItem(i)
        if (row.containsValue(text)):
            list.nativeObject.smoothScrollToPosition(i)
            break
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

function scrollListToText1(list, text) {
    var adapter = list.nativeObject.adapter;
    var total = adapter.getCount();
    for (var i = 0; i &lt; total; ++i) {
        var row = adapter.getItem(i);
        if (row.containsValue(text)) {
            list.nativeObject.smoothScrollToPosition(i);
            break;
        }
    }
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

sub scrollListToText1 {
    my ($list, $text) = @_;
    my $adapter = $list-&gt;nativeObject-&gt;adapter;
    my $total = $adapter-&gt;getCount();
    for (my $i = 0; $i &lt; $total; ++$i) {
        my $row = $adapter-&gt;getItem($i);
        if ($row-&gt;containsValue($text)) {
            $list-&gt;nativeObject-&gt;smoothScrollToPosition($i);
            last;
        }
    }
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

def scrollListToText1(list, text)
    adapter = list.nativeObject.adapter
    total = adapter.getCount();
    i = 0
    while i &lt; total
        row = adapter.getItem(i)
        if (row.containsValue(text))
            list.nativeObject.smoothScrollToPosition(i)
            break
        end
        i += 1
    end
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

proc scrollListToText1 {lst text} {
    set adapter [property get [property get $lst nativeObject] adapter]
    set total [invoke $adapter getCount]
    for {set i 0} {$i &lt; $total} {incr i} {
        set row [invoke $adapter getItem $i]
        if {[invoke $row containsValue $text]} {
            invoke [property get $lst nativeObject] smoothScrollToPosition $i
            break
        }
    }
}
</pre></div><p>
Note that although according the API documentation the <a class="ulink" href="http://developer.android.com/reference/android/widget/SimpleAdapter.html#getItem(int)" target="_blank">
getItem</a> member returns an <code class="code">java.lang.Object</code>, the actually
value is a <code class="code">java.util.Map</code> and thus we can just call <a class="ulink" href="http://developer.android.com/reference/java/util/Map.html#containsValue(java.lang.Object)" target="_blank">
containsValue</a> on it.
</p><p>
This is the simplest approach but only works when a list has this
<a class="ulink" href="http://developer.android.com/reference/android/widget/SimpleAdapter.html" target="_blank">
SimpleAdapter</a> type set as data source. For other types, a variation can
be written of course. Here the <code class="function">main</code> function
using <code class="function">scrollListToText</code>. </p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

import names

def main():
    startApplication("com.froglogic.addressbook")
    openMenu(waitForObject(names.address_Book_Activity))
    tapMenuItem(waitForObject(names.address_Book_Activity), "Demo Data")
    list = waitForObject(names.address_Book_List)

    scrollListToText3(list, "Nataniel")
    tapObject(waitForObject(names.nataniel_Text))

    openMenu(waitForObject(names.edit_Address_Forename_Edit))
    tapMenuItem(waitForObject(names.edit_Address_Activity), "Cancel")
    openMenu(waitForObject(names.address_Book_List))
    tapMenuItem(waitForObject(names.address_Book_Activity), "Quit")
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

import * as names from 'names.js';

function main() {
    startApplication("com.froglogic.addressbook");
    openMenu(waitForObject(names.addressBookActivity));
    tapMenuItem(waitForObject(names.addressBookActivity), "Demo Data");
    list = waitForObject(names.addressBookList);

    scrollListToText2(list, "Nataniel");
    tapObject(waitForObject(names.natanielText));

    openMenu(waitForObject(names.editAddressForenameEdit));
    tapMenuItem(waitForObject(names.editAddressActivity), "Cancel");
    openMenu(waitForObject(names.addressBookList));
    tapMenuItem(waitForObject(names.addressBookActivity), "Quit");
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

require 'names.pl';

sub scrollListToText1 {
    my ($list, $text) = @_;
    my $adapter = $list-&gt;nativeObject-&gt;adapter;
    my $total = $adapter-&gt;getCount();
    for (my $i = 0; $i &lt; $total; ++$i) {
        my $row = $adapter-&gt;getItem($i);
        if ($row-&gt;containsValue($text)) {
            $list-&gt;nativeObject-&gt;smoothScrollToPosition($i);
            last;
        }
    }
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

require 'squish'
require 'names';
include Squish

def main()
    startApplication("com.froglogic.addressbook")
    openMenu(waitForObject(Names::Address_Book_Activity))
    tapMenuItem(waitForObject(Names::Address_Book_Activity), "Demo Data")
    list = waitForObject(Names::Address_Book_List)

    scrollListToText2(list, "Nataniel")
    tapObject(waitForObject(Names::Nataniel_Text))

    openMenu(waitForObject(Names::Edit_Address_Forename_Edit))
    tapMenuItem(waitForObject(Names::Edit_Address_Activity), "Cancel")
    openMenu(waitForObject(Names::Address_Book_List))
    tapMenuItem(waitForObject(Names::Address_Book_Activity), "Quit")
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

source [findFile "scripts" "names.tcl"]

proc main {} {
    startApplication "com.froglogic.addressbook"
    invoke openMenu [waitForObject $names::Address_Book_Activity]
    invoke tapMenuItem [waitForObject $names::Address_Book_Activity] "Demo Data"
    set lst [waitForObject $names::Address_Book_List]

    scrollListToText3 $lst "Nataniel"
    invoke tapObject [waitForObject $names::Nataniel_Text]

    invoke openMenu [waitForObject $names::Edit_Address_Forename_Edit]
    invoke tapMenuItem [waitForObject $names::Edit_Address_Activity] "Cancel"
    invoke openMenu [waitForObject $names::Address_Book_List]
    invoke tapMenuItem [waitForObject $names::Address_Book_Activity] "Quit"
}
</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a id="tut-android-object-hierarchy"></a>4.12.1.5.3.2. Using the object hierarchy inside the list</h6></div></div></div><p>
Next we try to scroll using the <a class="xref" href="rgs-squish.html#object.children-function"><code class="function">object.children</code></a>
function traversing the <span class="emphasis"><em>Squish</em></span>
<a class="link" href="ide.views.html#ide.the-application-objects.view" title="8.2.1. Application Objects view">object hierarchy</a>.
As we can see in the
<a class="link" href="tutorials-android.html#tut-android-nativeObject-property">object tree</a>, the
list has for each row a <code class="code">Panel</code> object with two <code class="code">Text</code>
objects. Only the rows visible are in this hierarchy. So this list changes
when scrolling down. With that knowledge we can try to scroll to an item as
follows:
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

def scrollListToText2(list, text):
    total = list.rowCount
    current = 0
    while current &lt; total:
        list.nativeObject.smoothScrollToPosition(current)
        rows = object.children(list)
        for row in rows:
            for textview in object.children(row):
                if textview.text == text:
                    return
        current += len(rows)
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

function scrollListToText2(list, text) {
    var total = list.rowCount;
    var current = 0;
    while (current &lt; total) {
        list.nativeObject.smoothScrollToPosition(current);
        var rows = object.children(list);
        for (var r = 0; r &lt; rows.length; ++r) {
            var columns = object.children(rows[r]);
            for (var c = 0; c &lt; columns.length; ++c) {
                if (columns[c].text == text)
                    return;
            }
        }
        current += rows.length;
    }
    list.nativeObject.smoothScrollToPosition(total-1);
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

sub scrollListToText2 {
    my ($list, $text) = @_;
    my $total = $list-&gt;rowCount;
    my $current = 0;
    while ($current &lt; $total) {
        $list-&gt;nativeObject-&gt;smoothScrollToPosition($current);
        my @rows = object::children($list);
        for my $row (@rows) {
            for my $textview (object::children($row)) {
                if ($textview-&gt;text eq $text) {
                    return;
                }
            }
        }
        $current += $#rows;
    }
    $list-&gt;nativeObject-&gt;smoothScrollToPosition($total-1);
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

def scrollListToText2(list, text)
    total = list.rowCount
    current = 0
    while current &lt; total
        list.nativeObject.smoothScrollToPosition(current)
        rows = Squish::Object.children(list)
        rows.each do |row|
            for textview in Squish::Object.children(row)
                if textview.text == text
                    return
                end
            end
        end
        current += rows.length
    end
    list.nativeObject.smoothScrollToPosition(total-1)
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

proc scrollListToText2 {lst text} {
    set total [property get $lst rowCount]
    set current 0
    while {$current &lt; $total} {
        invoke [property get $lst nativeObject] smoothScrollToPosition $current
        set rows [object children $lst]
        foreach row $rows {
            set columns [object children $row]
            foreach textview $columns {
                set tmp [property get $textview text]
                if {$tmp == $text} {
                    return
                }
            }
        }
        incr current [llength $rows]
    }
    invoke [property get $lst nativeObject] smoothScrollToPosition [expr $total - 1]
}
</pre></div><p>
Using this method of scrolling to a certain <code class="code">Text</code> object is very
dependent on the exact hierarchy layout and will break when a layer is
added or removed.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a id="tut-android-object-name-search"></a>4.12.1.5.3.3. Using object name search</h6></div></div></div><p>
Just like <a class="xref" href="tutorials-android.html#tut-android-object-hierarchy" title="4.12.1.5.3.2. Using the object hierarchy inside the list">Using the object hierarchy inside the list (Section 4.12.1.5.3.2)</a> we let the object
hierarchy change with scrolling but this time we just search for an
object name  using the <a class="xref" href="rgs-squish.html#object.exists-function"><code class="function">object.exists</code></a> function:
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

def scrollListToText3(list, text):
    objectname = {"container": names.address_Book_List, "text": text, "type": "Text", "visible": True}
    total = list.rowCount
    current = 0
    page = list.nativeObject.getLastVisiblePosition() - list.nativeObject.getFirstVisiblePosition()
    while current &lt; total:
        list.nativeObject.smoothScrollToPosition(current)
        if object.exists(objectname):
            return
        current += page
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

function scrollListToText3(list, text) {
    var objectname = {"container": names.addressBookList, "text": text, "type": "Text", "visible": true}
    var total = list.rowCount;
    var current = 0;
    var page = list.nativeObject.getLastVisiblePosition() - list.nativeObject.getFirstVisiblePosition();
    while (current &lt; total) {
        list.nativeObject.smoothScrollToPosition(current);
        if (object.exists(objectname))
            return;
        current += page;
    }
    list.nativeObject.smoothScrollToPosition(total-1);
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

sub scrollListToText3 {
    my ($list, $text) = @_;
    my $objectname = {"container" =&gt; $Names::address_book_list, "text" =&gt; $text, "type" =&gt; "Text", "visible" =&gt; "true"};
    my $total = $list-&gt;rowCount;
    my $current = 0;
    my $page = $list-&gt;nativeObject-&gt;getLastVisiblePosition() - $list-&gt;nativeObject-&gt;getFirstVisiblePosition();
    while ($current &lt; $total) {
        $list-&gt;nativeObject-&gt;smoothScrollToPosition($current);
        if (object::exists($objectname)) {
            return;
        }
        $current += $page;
    }
    $list-&gt;nativeObject-&gt;smoothScrollToPosition($total-1);
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

def scrollListToText3(list, text)
    objectname = {:container =&gt; Names::Address_Book_List, :text =&gt; text, :type =&gt; "Text", :visible =&gt; true}
    total = list.rowCount
    current = 0
    page = list.nativeObject.getLastVisiblePosition() - list.nativeObject.getFirstVisiblePosition()
    while current &lt; total
        list.nativeObject.smoothScrollToPosition(current)
        if Squish::Object.exists(objectname)
            return
        end
        current += page
    end
    list.nativeObject.smoothScrollToPosition(total-1)
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

proc scrollListToText3 {lst text} {
    set objectname [::Squish::ObjectName container $names::Address_Book_List text $text type Text visible true]
    set total [property get $lst rowCount]
    set current 0
    set page [expr [invoke [property get $lst nativeObject] getLastVisiblePosition] - [invoke [property get $lst nativeObject] getFirstVisiblePosition]]
    while {$current &lt; $total} {
        invoke [property get $lst nativeObject] smoothScrollToPosition $current
        if {[object exists $objectname]} {
            return
        }
        incr current $page
    }
    invoke [property get $lst nativeObject] smoothScrollToPosition [expr $total - 1]
}
</pre></div><p>
This method of scrolling to a certain <code class="code">Text</code> object is the most
robust of the three presented. When the object hierarchy changes in a later version
of the app, it likely will still work because the object name only requires a
<code class="code">Text</code> object in a <code class="code">List</code> object.
</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="tut-android-learning-more"></a>4.12.1.6. Learning More</h4></div></div></div><p>
We have now completed the tutorial! <span class="emphasis"><em>Squish</em></span> can of course do
<span class="emphasis"><em>much</em></span> more than we have shown here, but the aim has
been to get you started with basic testing as quickly and easily as
possible. The <a class="xref" href="users-guide.html" title="Chapter 5. User Guide">User Guide (Chapter 5)</a> provides many more examples,
including those that show how tests can interact with particular widgets
such as spinners, comboboxes, and line editors, and of course with view
widgets and their underlying models.
</p><p>
The <a class="xref" href="api.man.html" title="Chapter 6. API Reference Manual">API Reference Manual (Chapter 6)</a> and <a class="xref" href="ref.man.html" title="Chapter 7. Tools Reference Manual">Tools Reference Manual (Chapter 7)</a> give full
details of <span class="emphasis"><em>Squish</em></span>'s testing API and the numerous functions it offers
to make testing as easy and efficient as possible. It is well worth
reading the <a class="xref" href="users-guide.html" title="Chapter 5. User Guide">User Guide (Chapter 5)</a> and at least skimming the
<a class="xref" href="api.man.html" title="Chapter 6. API Reference Manual">API Reference Manual (Chapter 6)</a> and <a class="xref" href="ref.man.html" title="Chapter 7. Tools Reference Manual">Tools Reference Manual (Chapter 7)</a>—especially
since the time invested will be repaid because you'll know what
functionality <span class="emphasis"><em>Squish</em></span> provides out of the box and can avoid reinventing
things that are already available.
</p><p>
<span class="emphasis"><em>Squish</em></span> for Android supports recording and replaying of gestures. As
well as a powerful API to create or manipulate them in your scripts. See
<a class="xref" href="ug-how.to.use.the.android.api.html#ug-how.to.use.the.android.GestureBuilder" title="5.7.3. How to Use the GestureBuilder class">How to Use the GestureBuilder class (Section 5.7.3)</a> for further
reading.
</p><p>
The key Android examples with links to the places they are used
are given below.
</p><div class="itemizedlist"><ul type="disc"><li><p>
The <span class="emphasis"><em>AddressBook</em></span>
 shows how to test some Android widgets such as:
 <code class="code">Button</code>, <code class="code">TextEdit</code>, <code class="code">ListView</code>,
 and <code class="code">Menu</code>
</p></li><li><p>
The <span class="emphasis"><em>WebBrowserHost</em></span>
 shows how to test with an embedded Android <code class="code">WebView</code> widget.
</p></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-bdd-android"></a>4.12.2. Tutorial: Designing Behavior Driven Development (BDD) Tests</h3></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="tutorials-android.html#tut-bdd-android-intro">4.12.2.1. Introduction to Behavior Driven Development</a></span></dt><dt><span class="section"><a href="tutorials-android.html#tut-bdd-android-gherkin">4.12.2.2. Gherkin syntax</a></span></dt><dt><span class="section"><a href="tutorials-android.html#tut-bdd-android-test-impl">4.12.2.3. Test implementation</a></span></dt><dt><span class="section"><a href="tutorials-android.html#tut-bdd-android-test-exec">4.12.2.4. Test execution</a></span></dt><dt><span class="section"><a href="tutorials-android.html#tut-bdd-android-test-debug">4.12.2.5. Test debugging</a></span></dt><dt><span class="section"><a href="tutorials-android.html#tut-bdd-android-step-reuse">4.12.2.6. Re-using Step definitions</a></span></dt></dl></div><p>
This tutorial will show you how to create, run, and modify Behavior Driven Development (BDD)
tests for an example application. You will learn about Squish's most frequently used features.
By the end of the tutorial you will be able to write your own tests for your own applications.
</p><p>
For this chapter we will use a simple Address Book application as our Application Under
Test (AUT). This is a very basic application that allows users to add, edit, and remove entries.
The screenshot shows the application in action with a user adding a new entry.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/bdd-tutorial-android-addressbook.png" align="middle"></img><div class="caption"><p>The Android <code class="code">addressbook</code> example.
</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="tut-bdd-android-intro"></a>4.12.2.1. Introduction to Behavior Driven Development</h4></div></div></div><p>
Behavior-Driven Development (BDD) is an extension of the Test-Driven Development approach
which puts the definition of acceptance criteria at the beginning of the development
process as opposed to writing tests after the software has been developed. With possible
cycles of code changes done after testing.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/bdd-tutorial-process.png" align="middle"></img><div class="caption">BDD process</div></div></div><p>
Behavior Driven Tests are built out of a set of <code class="literal">Feature</code> files, which
describe product features through the expected application behavior in one or many
<code class="literal">Scenarios</code>. Each <code class="literal">Scenario</code> is built out of a sequence
of steps which represent actions or verifications that need to be
tested for that <code class="literal">Scenario</code>.
</p><p>
BDD focuses on expected application behavior, not on implementation details. Therefore
BDD tests are described in a human-readable Domain Specific Language (DSL). As this
language is not technical, such tests can be created not only by programmers, but also by
product owners, testers or business analysts. Additionally, during the product
development, such tests serve as living product documentation. For <span class="emphasis"><em>Squish</em></span> usage, BDD
tests shall be created using Gherkin syntax. The previously written product specification
(BDD tests) can be turned into executable tests. This step by step tutorial presents
automating BDD tests with <span class="application">Squish IDE</span> support.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="tut-bdd-android-gherkin"></a>4.12.2.2. Gherkin syntax</h4></div></div></div><p>
Gherkin files describe product features through the expected application behavior
in one or many Scenarios. An example showing the "Filling of addressbook" feature
of the addressbook example application.
</p><pre class="screen">

Feature: Filling of addressbook
    As a user I want to fill the addressbook with entries

    Scenario: Initial state of created address book
        Given addressbook application is running
        Then addressbook should have zero entries

    Scenario: State after adding one entry
        Given addressbook application is running
        When I add a new person 'John','Doe','john@m.com','500600700' to address book
        Then '1' entries should be present

    Scenario: State after adding two entries
        Given addressbook application is running
        When I add new persons to address book
            | forename  | surname  | email        | phone  |
            | John      | Smith    | john@m.com   | 123123 |
            | Alice     | Thomson  | alice@m.com  | 234234 |
        Then '2' entries should be present

    Scenario: Forename and surname is added to table
        Given addressbook application is running
        When I add a new person 'Bob','Doe','Bob@m.com','123321231' to address book
        Then previously entered forename and surname shall be at the top

</pre><p>
Most of the above is free form text (does not have to be English). It's just the
<code class="literal">Feature</code>/<code class="literal">Scenario</code> structure and the leading keywords
like "Given", "And", "When" and "Then" that are fixed. Each of those keywords marks a
step defining preconditions, user actions and expected results. Above application
behavior description can be passed to software developers to implement these features and
at the same time the same description can be passed to software testers to implement
automated tests.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="tut-bdd-android-test-impl"></a>4.12.2.3. Test implementation</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="tut-bdd-android-create-testsuite"></a>4.12.2.3.1. Creating Test Suite</h5></div></div></div><p>
First, we need to create a Test Suite, which is a container for all Test Cases.
Start the <span class="application">squishide</span> and select <span class="guimenu">File</span>|<span class="guimenuitem">New Test Suite...</span>.
Please follow the New Test Suite wizard, provide a Test Suite name,
choose the Android Toolkit and scripting language of your choice and finally
register Address Book application as AUT. Please refer to <a class="xref" href="tutorials-android.html#tut-android-creating-a-test-suite" title="4.12.1.2. Creating a Test Suite">Creating a Test Suite (Section 4.12.1.2)</a> for more details about creating
new Test Suite. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="tut-bdd-android-create-testcase"></a>4.12.2.3.2. Creating Test Case</h5></div></div></div><p>
<span class="emphasis"><em>Squish</em></span> offers two types of Test Cases: <em class="firstterm">Script Test Case</em>
and <em class="firstterm">BDD Test Case</em>. As "Script Test Case" is the default
one, in order to create new "BDD Test Case" we need to
use the context menu by clicking on the expander next to
<span class="guibutton">New Script Test Case</span> (<span class="guiicon"><img src="images/ide/new_test_case.png"></img></span>) and choosing <span class="guimenuitem">New BDD Test Case</span>.
The <span class="application">Squish IDE</span> will remember your choice and the BDD Test Case will become the
default when clicking on the button in the future.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/bdd-tutorial-new-testcase.png" align="middle"></img><div class="caption">Creating new BDD Test Case</div></div></div><p>
The newly created BDD Test Case consists of a <code class="filename">test.feature</code> file
(filled with a Gherkin template while creating a new BDD test case), a file named
<code class="filename">test.(py|js|pl|rb|tcl)</code> which will drive the execution
(there is no need to edit this file), and a file in Test Suite Resources named
<code class="filename">steps/steps.(py|js|pl|rb|tcl)</code> where step
implementation code will be placed.
</p><p>We need to replace the Gherkin template with a <code class="literal">Feature</code>
for the addressbook example application. To do this, copy the <code class="literal">Feature</code>
description below and paste it into the <code class="literal">Feature</code> file.
</p><pre class="screen">

Feature: Filling of addressbook
    As a user I want to fill the addressbook with entries

    Scenario: Initial state of created address book
        Given addressbook application is running
        Then addressbook should have zero entries

</pre><p>
When editing the <code class="filename">test.feature</code> file, a <code class="literal">Feature</code> file
warning <span class="errortext">No implementation found</span> is displayed for each
undefined step. The implementations are in the
<code class="filename">steps</code> subdirectory, in <span class="guilabel">Test Case Resources</span>,
or in <span class="guilabel">Test Suite Resources</span>. Running our
<code class="literal">Feature</code> test now will currently fail at the first step with a
<span class="errortext">No Matching Step Definition</span> and the following
steps will be skipped.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="tut-bdd-android-record-step"></a>4.12.2.3.3. Recording Step implementation</h5></div></div></div><p>
In order to record the <code class="literal">Scenario</code>, press the
<span class="guibutton">Record</span> button next to the respective <code class="literal">Scenario</code> that
is listed in the <span class="guilabel">Scenarios</span> tab in <span class="guilabel">Test Case Resources</span> view.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/bdd-tutorial-record-scenario.png" align="middle"></img><div class="caption">Record Scenario</div></div></div><p>
This will cause <span class="emphasis"><em>Squish</em></span> to run the AUT so that we can interact with it. Additionally,
the Control Bar is displayed with a list of all steps that need to be
recorded. Now all interaction with the AUT or any verification points added to
the script will be recorded under the first step <code class="code">Given addressbook application is
running</code> (which is bolded in the Step list on the Control Bar). In order to verify that
this precondition is met, we will add a Verification Point. To do this, click on
<span class="guibutton">Verify</span> in the Control Bar and select
<span class="guibutton">Properties</span>.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/bdd-tutorial-android-control-bar.png" align="middle"></img><div class="caption">Control Bar</div></div></div><p>
As a result the <span class="application">Squish IDE</span> is put into Spy perspective, which displays views for
<span class="guilabel">Application Objects</span> and <span class="guilabel">Properties</span>.
In the <span class="guilabel">Application Objects</span> tree, select the
AddressBook <code class="classname">Activity</code>. Selecting it will update the
<span class="guilabel">Properties</span> view on the right side.
Next click on the checkbox in front of the <span class="property">enabled</span>
in the <span class="guilabel">Properties</span> view. Finally, click on the button
<span class="guibutton">Save and Insert Verifications</span>. The <span class="application">Squish IDE</span> disappears and
the Control Bar is shown again.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/bdd-tutorial-android-squish-spy.png" align="middle"></img><div class="caption">Inserting Verification Point</div></div></div><p>
When we are done with each step, we can move to the next
undefined step (playing back the ones that were previously defined)
by clicking on the <span class="guibutton">Finish Recording Step...</span> (<span class="guiicon"><img src="images/bdd-tutorial-next-step-button.png"></img></span>) arrow button in the Control Bar that is
located to the left of the current step.
</p><p>Next, for the step <code class="code">Then addressbook should have zero entries</code> verify that
the table containing the address entries is empty. To record this verification,
click on <span class="guibutton">Verify</span> while recording, select
<span class="guibutton">Properties</span>. In the <span class="guilabel">Application Objects</span>
view, navigate or use the <a class="xref" href="ide.views.html#object-picker">Object Picker</a> (<span class="guiicon"><img src="images/ide/pick-application-object.png"></img></span>) tool to select the
<code class="classname">Table</code> object containing the address book entries (in our
case this table is empty). Check the <span class="property">rowCount</span> property from
the <span class="guilabel">Properties</span> view and click
<span class="guibutton">Save and Insert Verifications</span>.
Finally, click on the last <span class="guibutton">Finish Recording Step...</span> (<span class="guiicon"><img src="images/bdd-tutorial-next-step-button.png"></img></span>) arrow button in the Control Bar.
</p><p>
As a result, <span class="emphasis"><em>Squish</em></span> will generate the following step
definitions in the <code class="filename">steps.*</code> file (at
<span class="guilabel">Test Suites</span>+<span class="guilabel">Test Suite
Resources</span>):
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

@Given("addressbook application is running")
def step(context):
    startApplication("com.froglogic.addressbook")
    test.compare(waitForObjectExists(names.address_Book_Activity).enabled, True)

@Then("addressbook should have zero entries")
def step(context):
    test.compare(waitForObjectExists(names.address_Book_addressList_List).rowCount, 0)

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

Given("addressbook application is running", function(context) {
    startApplication("com.froglogic.addressbook");
    test.compare(waitForObjectExists(names.addressBookActivity).enabled, true);
});

Then("addressbook should have zero entries", function(context) {
    test.compare(waitForObjectExists(names.addressBookAddressListList).rowCount, 0);
});

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

Given("addressbook application is running", sub {
    my $context = shift;
    startApplication("com.froglogic.addressbook");
    test::compare(waitForObjectExists($Names::address_book_activity)-&gt;enabled, 1);
});

Then("addressbook should have zero entries", sub {
    my $context = shift;
    test::compare(waitForObjectExists($Names::address_book_addresslist_list)-&gt;rowCount, 0);
});

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

Given("addressbook application is running") do |context|
    startApplication("com.froglogic.addressbook")
    Test.compare(waitForObjectExists(Names::Address_Book_Activity).enabled, true)
end

Then("addressbook should have zero entries") do |context|
    Test.compare(waitForObjectExists(Names::Address_Book_addressList_List).rowCount, 0)
end

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

Given "addressbook application is running" {context} {
    startApplication "com.froglogic.addressbook"
    test compare [property get [waitForObjectExists $names::Address_Book_Activity] enabled] true
}

Then "addressbook should have zero entries" {context} {
    test compare [property get [waitForObjectExists $names::Address_Book_addressList_List] rowCount] 0
}

</pre></div><p>
The application is automatically started at the beginning of the first step due
to the recorded <code class="function">startApplication()</code> call. At the end of each
Scenario, the <code class="function">onScenarioEnd</code> hook is called, causing
<code class="function">detach()</code> to be called on the application context.
Because the AUT was started with <code class="function">startApplication()</code>,
this causes it to terminate.
This hook function is found in the file <code class="filename">bdd_hooks.(py|js|pl|rb|tcl)</code>,
which is located in the <span class="guilabel">Scripts</span> tab of the <span class="guilabel">Test
Suite Resources</span> view. You can define additional hook functions here.
For a list of all available hooks, please refer to <a class="xref" href="api.bdt.functions.html#api.bdt.functions.hooks" title="6.19.10. Performing Actions During Test Execution Via Hooks">Performing Actions During Test Execution Via Hooks (Section 6.19.10)</a>.
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">
@OnScenarioEnd
def OnScenarioEnd():
    for ctx in applicationContextList():
        ctx.detach()

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">
OnScenarioEnd(function(context) {
    applicationContextList().forEach(function(ctx) { ctx.detach(); });
});

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">
OnScenarioEnd(sub {
    foreach (applicationContextList()) {
        $_-&gt;detach();
    }
});
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">
OnScenarioEnd do |context|
    applicationContextList().each { |ctx| ctx.detach() }
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">
OnScenarioEnd {context} {
    foreach ctx [applicationContextList] {
        applicationContext $ctx detach
    }
}
</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="tut-bdd-android-step-parametrization"></a>4.12.2.3.4. Step parametrization</h5></div></div></div><p>
So far, our steps did not use any parameters and all values were
hardcoded. <span class="emphasis"><em>Squish</em></span> has different types of parameters like
<code class="code">any</code>, <code class="code">integer</code> or <code class="code">word</code>, allowing our
step definitions to be more reusable. Let us add a
new <code class="literal">Scenario</code> to our <code class="literal">Feature</code> file which will provide
step parameters for both the Test Data and the expected results.
Copy the below section into your Feature file.

</p><pre class="screen">

    Scenario: State after adding one entry
        Given addressbook application is running
        When I add a new person 'John','Doe','john@m.com','500600700' to address book
        Then '1' entries should be present

</pre><p>

After auto-saving
the <code class="literal">Feature</code> file, the <span class="application">Squish IDE</span> provides a hint that only 2
steps need to be implemented: <code class="code">When I add a new person 'John',
'Doe','john@m.com','500600700' to address book</code> and <code class="code">Then '1' entries should
be present</code>. The remaining steps already have a matching
step implementation.
</p><p>
To record the missing steps, hit the record button next to the
test case name in the Test Suites view. The script will play until it gets to the missing
step and then prompt you to implement it. If you select the Add
button, then you can type in the information for a new entry. Click on the
<span class="guibutton">Finish Recording Step...</span> (<span class="guiicon"><img src="images/bdd-tutorial-next-step-button.png"></img></span>) button to move to the next step. For the second missing
step, we could record an object property verification like we did with the
step <code class="code">Then addressbook should have zero entries</code>.
Or we could copy that step's implementation in the
<code class="filename">steps.(py|js|pl|rb|tcl)</code> file and increment the number at
the end of the <code class="code">test.compare</code> line. Instead of testing for zero
items, we are testing for one item.
</p><p>
Now we parametrize the generated <code class="literal">When</code> step implementation by
replacing the values with parameter types.
Since we want to be able to add different names, replace 'John' with '|word|'.
Note that each parameter will be passed to the step implementation function in the order of
appearance in the descriptive name of the step. Finish parametrizing by editing the typed values
into keywords, to look like this example step
<code class="code">When I add a new person 'John', 'Doe','john@m.com','500600700'</code> to address book:
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

@When("I add a new person '|word|','|word|','|any|','|integer|' to address book")
def step(context, forename, surname, email, phone):
    tapObject(waitForObject(names.address_Book_Add_Address_Button))
    tapObject(waitForObject(names.edit_Address_Forename_Edit))
    type(waitForObject(names.edit_Address_Forename_Edit), forename)
    tapObject(waitForObject(names.edit_Address_Surname_Edit))
    type(waitForObject(names.edit_Address_Surname_Edit), surname)
    tapObject(waitForObject(names.edit_Address_Phone_Edit))
    type(waitForObject(names.edit_Address_Phone_Edit), phone)
    tapObject(waitForObject(names.edit_Address_Email_Edit))
    type(waitForObject(names.edit_Address_Email_Edit), email)
    tapObject(waitForObject(names.edit_Address_Save_Button))
    context.userData = {}
    context.userData['forename'] = forename
    context.userData['surname'] = surname

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

When("I add a new person '|word|','|word|','|any|','|integer|' to address book", function(context, forename, surname, email, phone) {
    tapObject(waitForObject(names.addressBookAddAddressButton));
    tapObject(waitForObject(names.editAddressForenameEdit));
    type(waitForObject(names.editAddressForenameEdit), forename);
    tapObject(waitForObject(names.editAddressSurnameEdit));
    type(waitForObject(names.editAddressSurnameEdit), surname);
    tapObject(waitForObject(names.editAddressPhoneEdit));
    type(waitForObject(names.editAddressPhoneEdit), phone);
    tapObject(waitForObject(names.editAddressEmailEdit));
    type(waitForObject(names.editAddressEmailEdit), email);
    tapObject(waitForObject(names.editAddressSaveButton));
    context.userData = {};
    context.userData['forename'] = forename;
    context.userData['surname'] = surname;
});

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

When("I add a new person '|word|','|word|','|any|','|integer|' to address book", sub {
    my ($context, $forename, $surname, $email, $phone) = @_;
    tapObject(waitForObject($Names::address_book_add_address_button));
    tapObject(waitForObject($Names::edit_address_forename_edit));
    type(waitForObject($Names::edit_address_forename_edit), $forename);
    tapObject(waitForObject($Names::edit_address_surname_edit));
    type(waitForObject($Names::edit_address_surname_edit), $surname);
    tapObject(waitForObject($Names::edit_address_phone_edit));
    type(waitForObject($Names::edit_address_phone_edit), $phone);
    tapObject(waitForObject($Names::edit_address_email_edit));
    type(waitForObject($Names::edit_address_email_edit), $email);
    tapObject(waitForObject($Names::edit_address_save_button));
    $context-&gt;{userData}{'forename'} = $forename;
    $context-&gt;{userData}{'surname'} = $surname;
});

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

When("I add a new person '|word|','|word|','|any|','|integer|' to address book") do |context, forename, surname, email, phone|
    tapObject(waitForObject(Names::Address_Book_Add_Address_Button))
    tapObject(waitForObject(Names::Edit_Address_Forename_Edit))
    type(waitForObject(Names::Edit_Address_Forename_Edit), forename)
    tapObject(waitForObject(Names::Edit_Address_Surname_Edit))
    type(waitForObject(Names::Edit_Address_Surname_Edit), surname)
    tapObject(waitForObject(Names::Edit_Address_Phone_Edit))
    type(waitForObject(Names::Edit_Address_Phone_Edit), phone)
    tapObject(waitForObject(Names::Edit_Address_Email_Edit))
    type(waitForObject(Names::Edit_Address_Email_Edit), email)
    tapObject(waitForObject(Names::Edit_Address_Save_Button))
    context.userData = Hash.new
    context.userData[:forename] = forename
    context.userData[:surname] = surname
end

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

When "I add a new person '|word|','|word|','|any|','|integer|' to address book" {context forename surname email phone} {
    invoke tapObject [waitForObject $names::Address_Book_Add_Address_Button]
    invoke tapObject [waitForObject $names::Edit_Address_Forename_Edit]
    invoke type [waitForObject $names::Edit_Address_Forename_Edit] $forename
    invoke tapObject [waitForObject $names::Edit_Address_Surname_Edit]
    invoke type [waitForObject $names::Edit_Address_Surname_Edit] $surname
    invoke tapObject [waitForObject $names::Edit_Address_Phone_Edit]
    invoke type [waitForObject $names::Edit_Address_Phone_Edit] $phone
    invoke tapObject [waitForObject $names::Edit_Address_Email_Edit]
    invoke type [waitForObject $names::Edit_Address_Email_Edit] $email
    invoke tapObject [waitForObject $names::Edit_Address_Save_Button]
    $context userData [dict create forename $forename surname $surname]
}

</pre></div><p> If we recorded the final <code class="literal">Then</code> as a missing step, and
verified the <span class="property">rowCount</span> is 1 in the table, we can modify the
step so that it takes a parameter, so it can verify other integer values later.
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

@Then("'|integer|' entries should be present")
def step(context, count):
    test.compare(waitForObjectExists(names.address_Book_addressList_List).rowCount, count)

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

Then("'|integer|' entries should be present", function(context, count) {
    test.compare(waitForObjectExists(names.addressBookAddressListList).rowCount, count);
});

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

Then("'|integer|' entries should be present", sub {
    my ($context, $count) = @_;
    test::compare(waitForObjectExists($Names::address_book_addresslist_list)-&gt;rowCount, $count);
});

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

Then("'|integer|' entries should be present") do |context, count|
    Test.compare(waitForObjectExists(Names::Address_Book_addressList_List).rowCount, count)
end

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

Then "'|integer|' entries should be present" {context count} {
    test compare [property get [waitForObjectExists $names::Address_Book_addressList_List] rowCount] $count
}

</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="tut-bdd-android-provide-parameters"></a>4.12.2.3.5. Provide parameters for Step in table</h5></div></div></div><p>
The next <code class="literal">Scenario</code> will test adding multiple entries to the address
book. We could use step <code class="code">When I add a new person John','Doe','john@m.com','500600700'
to address book</code> multiple times just with different data. But lets instead define a
new step called <code class="code">When I add a new person to address book</code>
which will handle data from a table.
</p><pre class="screen">

        When I add new persons to address book
            | forename  | surname  | email        | phone  |
            | John      | Smith    | john@m.com   | 123123 |
            | Alice     | Thomson  | alice@m.com  | 234234 |
</pre><p>
The step implementation to handle such tables looks like this:
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

@When("I add new persons to address book")
def step(context):
    table = context.table
    # Drop initial row with column headers
    table.pop(0)
    for (forename, surname, email, phone) in table:
        tapObject(waitForObject(names.address_Book_Add_Address_Button))
        tapObject(waitForObject(names.edit_Address_Forename_Edit))
        type(waitForObject(names.edit_Address_Forename_Edit), forename)
        tapObject(waitForObject(names.edit_Address_Surname_Edit))
        type(waitForObject(names.edit_Address_Surname_Edit), surname)
        tapObject(waitForObject(names.edit_Address_Phone_Edit))
        type(waitForObject(names.edit_Address_Phone_Edit), phone)
        tapObject(waitForObject(names.edit_Address_Email_Edit))
        type(waitForObject(names.edit_Address_Email_Edit), email)
        tapObject(waitForObject(names.edit_Address_Save_Button))

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

When("I add new persons to address book", function(context) {
    var table = context.table;

    // Skip initial row with column headers by starting at index 1
    for (var i = 1; i &lt; table.length; ++i) {
        var forename = table[i][0];
        var surname = table[i][1];
        var email = table[i][2];
        var phone = table[i][3];
        tapObject(waitForObject(names.addressBookAddAddressButton));
        tapObject(waitForObject(names.editAddressForenameEdit));
        type(waitForObject(names.editAddressForenameEdit), forename);
        tapObject(waitForObject(names.editAddressSurnameEdit));
        type(waitForObject(names.editAddressSurnameEdit), surname);
        tapObject(waitForObject(names.editAddressPhoneEdit));
        type(waitForObject(names.editAddressPhoneEdit), phone);
        tapObject(waitForObject(names.editAddressEmailEdit));
        type(waitForObject(names.editAddressEmailEdit), email);
        tapObject(waitForObject(names.editAddressSaveButton));
    }
});

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

When("I add new persons to address book", sub {
    my $context = shift;
    my $table = $context-&gt;{'table'};
    # Drop initial row with column headers
    shift(@{$table});
    for my $row (@{$table}) {
        my ($forename, $surname, $email, $phone) = @{$row};
        tapObject(waitForObject($Names::address_book_add_address_button));
        tapObject(waitForObject($Names::edit_address_forename_edit));
        type(waitForObject($Names::edit_address_forename_edit), $forename);
        tapObject(waitForObject($Names::edit_address_surname_edit));
        type(waitForObject($Names::edit_address_surname_edit), $surname);
        tapObject(waitForObject($Names::edit_address_phone_edit));
        type(waitForObject($Names::edit_address_phone_edit), $phone);
        tapObject(waitForObject($Names::edit_address_email_edit));
        type(waitForObject($Names::edit_address_email_edit), $email);
        tapObject(waitForObject($Names::edit_address_save_button));
    }
});

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

When("I add new persons to address book") do |context|
    table = context.table
    # Drop initial row with column headers
    table.shift
    for forename, surname, email, phone in table do
        tapObject(waitForObject(Names::Address_Book_Add_Address_Button))
        tapObject(waitForObject(Names::Edit_Address_Forename_Edit))
        type(waitForObject(Names::Edit_Address_Forename_Edit), forename)
        tapObject(waitForObject(Names::Edit_Address_Surname_Edit))
        type(waitForObject(Names::Edit_Address_Surname_Edit), surname)
        tapObject(waitForObject(Names::Edit_Address_Phone_Edit))
        type(waitForObject(Names::Edit_Address_Phone_Edit), phone)
        tapObject(waitForObject(Names::Edit_Address_Email_Edit))
        type(waitForObject(Names::Edit_Address_Email_Edit), email)
        tapObject(waitForObject(Names::Edit_Address_Save_Button))
    end
end

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

When "I add new persons to address book" {context} {
    set table [$context table]
    # Drop initial row with column headers
    foreach row [lreplace $table 0 0] {
        foreach {forename surname email phone} $row break
        invoke tapObject [waitForObject $names::Address_Book_Add_Address_Button]
        invoke tapObject [waitForObject $names::Edit_Address_Forename_Edit]
        invoke type [waitForObject $names::Edit_Address_Forename_Edit] $forename
        invoke tapObject [waitForObject $names::Edit_Address_Surname_Edit]
        invoke type [waitForObject $names::Edit_Address_Surname_Edit] $surname
        invoke tapObject [waitForObject $names::Edit_Address_Phone_Edit]
        invoke type [waitForObject $names::Edit_Address_Phone_Edit] $phone
        invoke tapObject [waitForObject $names::Edit_Address_Email_Edit]
        invoke type [waitForObject $names::Edit_Address_Email_Edit] $email
        invoke tapObject [waitForObject $names::Edit_Address_Save_Button]
    }
}

</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="tut-bdd-android-sharing"></a>4.12.2.3.6. Sharing data between Steps and Scenarios</h5></div></div></div><p>
Lets add a new <code class="literal">Scenario</code> to the <code class="literal">Feature</code> file. This
time we would like to check not the number of entries in address book list, but if this
list contains proper data. Because we enter data into the address book in one
step and verify them in another, we must share information about
entered data among those steps in order to perform a verification.
</p><pre class="screen">

    Scenario: Forename and surname is added to table
        Given addressbook application is running
        When I add a new person 'Bob','Doe','Bob@m.com','123321231' to address book
        Then previously entered forename and surname shall be at the top
</pre><p>
To share this data, <span class="property">context.userData</span> can be used.
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

@When("I add a new person '|word|','|word|','|any|','|integer|' to address book")
def step(context, forename, surname, email, phone):
    tapObject(waitForObject(names.address_Book_Add_Address_Button))
    tapObject(waitForObject(names.edit_Address_Forename_Edit))
    type(waitForObject(names.edit_Address_Forename_Edit), forename)
    tapObject(waitForObject(names.edit_Address_Surname_Edit))
    type(waitForObject(names.edit_Address_Surname_Edit), surname)
    tapObject(waitForObject(names.edit_Address_Phone_Edit))
    type(waitForObject(names.edit_Address_Phone_Edit), phone)
    tapObject(waitForObject(names.edit_Address_Email_Edit))
    type(waitForObject(names.edit_Address_Email_Edit), email)
    tapObject(waitForObject(names.edit_Address_Save_Button))
    context.userData = {}
    context.userData['forename'] = forename
    context.userData['surname'] = surname

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

When("I add a new person '|word|','|word|','|any|','|integer|' to address book", function(context, forename, surname, email, phone) {
    tapObject(waitForObject(names.addressBookAddAddressButton));
    tapObject(waitForObject(names.editAddressForenameEdit));
    type(waitForObject(names.editAddressForenameEdit), forename);
    tapObject(waitForObject(names.editAddressSurnameEdit));
    type(waitForObject(names.editAddressSurnameEdit), surname);
    tapObject(waitForObject(names.editAddressPhoneEdit));
    type(waitForObject(names.editAddressPhoneEdit), phone);
    tapObject(waitForObject(names.editAddressEmailEdit));
    type(waitForObject(names.editAddressEmailEdit), email);
    tapObject(waitForObject(names.editAddressSaveButton));
    context.userData = {};
    context.userData['forename'] = forename;
    context.userData['surname'] = surname;
});

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

When("I add a new person '|word|','|word|','|any|','|integer|' to address book", sub {
    my ($context, $forename, $surname, $email, $phone) = @_;
    tapObject(waitForObject($Names::address_book_add_address_button));
    tapObject(waitForObject($Names::edit_address_forename_edit));
    type(waitForObject($Names::edit_address_forename_edit), $forename);
    tapObject(waitForObject($Names::edit_address_surname_edit));
    type(waitForObject($Names::edit_address_surname_edit), $surname);
    tapObject(waitForObject($Names::edit_address_phone_edit));
    type(waitForObject($Names::edit_address_phone_edit), $phone);
    tapObject(waitForObject($Names::edit_address_email_edit));
    type(waitForObject($Names::edit_address_email_edit), $email);
    tapObject(waitForObject($Names::edit_address_save_button));
    $context-&gt;{userData}{'forename'} = $forename;
    $context-&gt;{userData}{'surname'} = $surname;
});

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

When("I add a new person '|word|','|word|','|any|','|integer|' to address book") do |context, forename, surname, email, phone|
    tapObject(waitForObject(Names::Address_Book_Add_Address_Button))
    tapObject(waitForObject(Names::Edit_Address_Forename_Edit))
    type(waitForObject(Names::Edit_Address_Forename_Edit), forename)
    tapObject(waitForObject(Names::Edit_Address_Surname_Edit))
    type(waitForObject(Names::Edit_Address_Surname_Edit), surname)
    tapObject(waitForObject(Names::Edit_Address_Phone_Edit))
    type(waitForObject(Names::Edit_Address_Phone_Edit), phone)
    tapObject(waitForObject(Names::Edit_Address_Email_Edit))
    type(waitForObject(Names::Edit_Address_Email_Edit), email)
    tapObject(waitForObject(Names::Edit_Address_Save_Button))
    context.userData = Hash.new
    context.userData[:forename] = forename
    context.userData[:surname] = surname
end

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

When "I add a new person '|word|','|word|','|any|','|integer|' to address book" {context forename surname email phone} {
    invoke tapObject [waitForObject $names::Address_Book_Add_Address_Button]
    invoke tapObject [waitForObject $names::Edit_Address_Forename_Edit]
    invoke type [waitForObject $names::Edit_Address_Forename_Edit] $forename
    invoke tapObject [waitForObject $names::Edit_Address_Surname_Edit]
    invoke type [waitForObject $names::Edit_Address_Surname_Edit] $surname
    invoke tapObject [waitForObject $names::Edit_Address_Phone_Edit]
    invoke type [waitForObject $names::Edit_Address_Phone_Edit] $phone
    invoke tapObject [waitForObject $names::Edit_Address_Email_Edit]
    invoke type [waitForObject $names::Edit_Address_Email_Edit] $email
    invoke tapObject [waitForObject $names::Edit_Address_Save_Button]
    $context userData [dict create forename $forename surname $surname]
}

</pre></div><p>
All data stored in <span class="property">context.userData</span> can be accessed in all
steps and <code class="literal">Hooks</code> in all <code class="literal">Scenarios</code>
of the given <code class="literal">Feature</code>. Finally, we need to implement
the step <code class="code">Then previously entered forename and surname shall be at the top</code>.
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">

@Then("previously entered forename and surname shall be at the top")
def step(context):
    list = waitForObject(names.address_Book_addressList_List)
    rows = object.children(list)
    row_0 = rows[0]
    columns_row_0 = object.children(row_0)
    test.compare(columns_row_0[0].text, context.userData["forename"])
    test.compare(columns_row_0[1].text, context.userData["surname"])

</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">

Then("previously entered forename and surname shall be at the top", function(context) {
    var list = waitForObject(names.addressBookAddressListList);
    var rows = object.children(list);
    var row_0 = rows[0];
    var columns_row_0 = object.children(row_0);
    test.compare(columns_row_0[0].text, context.userData["forename"]);
    test.compare(columns_row_0[1].text, context.userData["surname"]);
});
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">

Then("previously entered forename and surname shall be at the top", sub {
    my $context = shift;
    my $list = waitForObject($Names::address_book_addresslist_list);
    my @rows = object::children($list);
    my $row_0 = $rows[0];
    my @columns_row_0 = object::children($row_0);
    test::compare($columns_row_0[0]-&gt;text, $context-&gt;{userData}{'forename'}, "forename?");
    test::compare($columns_row_0[1]-&gt;text, $context-&gt;{userData}{'surname'}, "surname?");
});
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">

Then("previously entered forename and surname shall be at the top") do |context|
    list = waitForObject(Names::Address_Book_addressList_List)
    rows = Squish::Object.children(list)
    row_0 = rows[0]
    columns_row_0 = Squish::Object.children(row_0)
    Test.compare(columns_row_0[0].text, context.userData[:forename])
    Test.compare(columns_row_0[1].text, context.userData[:surname])
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">

Then "previously entered forename and surname shall be at the top" {context} {
    set list [waitForObject $names::Address_Book_addressList_List]
    set rows [object children $list]
    set row_0 [lindex $rows 0]
    set columns_row_0 [object children $row_0]
    test compare [property get [lindex $columns_row_0 0] text] [dict get [$context userData] "forename"]
    test compare [property get [lindex $columns_row_0 1] text] [dict get [$context userData] "surname"]
}
</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="tut-bdd-android-scenario-outline"></a>4.12.2.3.7. Scenario Outline</h5></div></div></div><p>
Assume our <code class="literal">Feature</code> contains the following two <code class="literal">Scenarios</code>:
</p><pre class="screen">
Scenario: State after adding one entry
    Given addressbook application is running
    When I add a new person 'John','Doe','john@m.com','500600700' to address book
    Then "1" entries should be present

Scenario: State after adding one entry
    Given addressbook application is running
    When I add a new person 'Bob','Koo','bob@m.com','500600800' to address book
    Then "1" entries should be present
</pre><p>
As we can see, those <code class="literal">Scenarios</code> perform the same actions using different
test data. The same can be achieved by using a <code class="literal">Scenario Outline</code> (a
<code class="literal">Scenario</code> template with placeholders) and Examples (a table with
parameters).
</p><pre class="screen">
Scenario Outline: Adding single entries multiple time
    Given addressbook application is running
    When I add a new person '&lt;forename&gt;','&lt;surname&gt;','&lt;email&gt;','&lt;phone&gt;' to address book
    Then '1' entries should be present
    Examples:
        | forename | surname  | email       | phone     |
        | John     | Doe      | john@m.com  | 500600700 |
        | Bob      | Koo      | bob@m.com   | 500600800 |
</pre><p>
Please note that the <code class="code">OnScenarioEnd</code> hook will be executed at the end of
each loop iteration in a <code class="literal">Scenario Outline</code>.
</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="tut-bdd-android-test-exec"></a>4.12.2.4. Test execution</h4></div></div></div><p>
In the <span class="application">Squish IDE</span>, users can execute all <code class="literal">Scenarios</code> in a
<code class="literal">Feature</code>, or execute only one selected <code class="literal">Scenario</code>. In
order to execute all <code class="literal">Scenarios</code>, the proper Test Case has to be
executed by clicking on the <span class="guibutton">Play</span> button in the Test Suites view.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/bdd-tutorial-execute-all.png" align="middle"></img><div class="caption">Execute all Scenarios from Feature</div></div></div><p>
In order to execute only one <code class="literal">Scenario</code>, you need to open the
<code class="literal">Feature</code> file, right-click on the given <code class="literal">Scenario</code> and
choose <span class="guibutton">Run Scenario</span>. An alternative approach is to click on the
<span class="guibutton">Play</span> button next to the respective <code class="literal">Scenario</code> in
the <span class="guilabel">Scenarios</span> tab in <span class="guilabel">Test Case Resources</span>.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/bdd-tutorial-execute-one.png" align="middle"></img><div class="caption">Execute one Scenario from Feature</div></div></div><p>
After a <code class="literal">Scenario</code> is executed, the <code class="literal">Feature</code> file is
colored according to the execution results. More detailed information (like logs) can
be found in the Test Results View.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/bdd-tutorial-results.png" align="middle"></img><div class="caption">Execution results in Feature file</div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="tut-bdd-android-test-debug"></a>4.12.2.5. Test debugging</h4></div></div></div><p>
<span class="emphasis"><em>Squish</em></span> offers the possibility to pause an execution of a Test Case at any point in
order to check script variables, spy application objects or run custom
code in the <span class="emphasis"><em>Squish</em></span> script console. To do this, a breakpoint has to be placed before
starting the execution, either in the <code class="literal">Feature</code> file at any line
containing a step or at any line of executed code (i.e. in middle of
step definition code).
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/bdd-tutorial-breakpoint.png" align="middle"></img><div class="caption">Breakpoint in Feature file</div></div></div><p>
After the breakpoint is reached, you can inspect all application objects and their
properties. If a breakpoint is placed at a step definition or a hook
is reached, then you can additionally add Verification Points or record code snippets.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="tut-bdd-android-step-reuse"></a>4.12.2.6. Re-using Step definitions</h4></div></div></div><p>
BDD test maintainability can be increased by reusing step definitions
in test cases located in another directory. For more information, see
<a class="xref" href="api.bdt.functions.html#api.bdt.functions.collectstepdefinitions">collectStepDefinitions()</a>.
</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-migration-bdd-android"></a>4.12.3. Tutorial: Migration of existing tests to BDD</h3></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="tutorials-android.html#bdd-migration-android-extend">4.12.3.1. Extend existing tests to BDD</a></span></dt><dt><span class="section"><a href="tutorials-android.html#bdd-migration-android-convert">4.12.3.2. Convert existing tests to BDD</a></span></dt></dl></div><p>
This chapter is for users that have existing <span class="emphasis"><em>Squish</em></span> tests and who would
like to introduce Behavior Driven Testing. The first section describes how to keep the
existing tests and simply add new tests with the BDD approach. The second section
describes how to convert script-based tests to BDD tests.
</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="bdd-migration-android-extend"></a>4.12.3.1. Extend existing tests to BDD</h4></div></div></div><p>
The first option is to keep existing <span class="emphasis"><em>Squish</em></span> tests and add new BDD tests.
It's possible to have a <code class="literal">Test Suite</code> containing
script-based and BDD Test Cases. Simply open an existing
<code class="literal">Test Suite</code> and choose the
<span class="guimenuitem">New BDD Test Case</span> option from the drop down menu to the right of
the <span class="guibutton">New Script Test Case</span> (<span class="guiicon"><img src="images/ide/new_test_case.png"></img></span>) toolbar button. </p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/bdd-tutorial-new-testcase.png" align="middle"></img><div class="caption">Creating new BDD Test Case</div></div></div><p>
Assuming your existing Test Cases make use of a library and you are calling
shared functions to interact with the AUT, those functions can also be used from
BDD Test Cases. In the example below, a function is called from multiple
script-based Test Cases:
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">
def deleteFirstEntry():
    #...
    pass
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">
function deleteFirstEntry(){
    //...
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">
sub deleteFirstEntry{
    #...
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">
def deleteFirstEntry
  #...
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">
proc deleteFirstEntry {} {
    #...
}
</pre></div><p>
New BDD Test Cases can easily use the same function:
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">
@When("I delete the first entry")
def step(context):
    deleteFirstEntry()
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">
When("I delete the first entry", function(context){
    deleteFirstEntry()
});
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">
When("I delete the first entry", sub {
    deleteFirstEntry();
});
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">
When("I delete the first entry") do |context|
  deleteFirstEntry
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">
When "I delete the first entry" {context} {
    deleteFirstEntry
}
</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="bdd-migration-android-convert"></a>4.12.3.2. Convert existing tests to BDD</h4></div></div></div><p>
The second option is to convert an existing <code class="literal">Test Suite</code> that contains
script-based Test Cases into behavior driven tests. Since a <code class="literal">Test
Suite</code> can contain script-based and BDD Test Cases, migration can be
done gradually. A <code class="literal">Test Suite</code> containing a mix
of both Test Case types can be executed and results analyzed without
any extra effort required.
</p><p>
The first step is to review all Test Cases of the existing <code class="literal">Test Suite</code>
and group them by the <code class="literal">Feature</code> they test. Each script-based Test Case will
be transformed into a <code class="literal">Scenario</code>, which is a part of a
<code class="literal">Feature</code>. For example, assume we have 5 script-based Test Cases. After
analysis, we realize that they examine two <code class="literal">Features</code>.
Therefore, when migration is completed, our Test Suite will contain two BDD Test Cases,
each of them containing one <code class="literal">Feature</code>. Each <code class="literal">Feature</code>
will contain multiple <code class="literal">Scenarios</code>. In our example, the first
<code class="literal">Feature</code> contains three <code class="literal">Scenarios</code> and the second
<code class="literal">Feature</code> contains two <code class="literal">Scenarios</code>.
</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/bdd-tutorial-migration.png" align="middle"></img><div class="caption">Conversion Chart</div></div></div><p>
At the beginning, open a <code class="literal">Test Suite</code> in the <span class="application">Squish IDE</span> that contains
<span class="emphasis"><em>Squish</em></span> tests that are planned to be migrated to BDD. Next, create a
new Test Case by choosing <span class="guibutton">New BDD Test Case</span> option from the
context menu. Each BDD Test Case contains a <code class="filename">test.feature</code> file
that can be filled with maximum one <code class="literal">Feature</code>. Next, open the
<code class="filename">test.feature</code> file to describe the <code class="literal">Features</code>
using the Gherkin language. Following the syntax from the template, edit the
<code class="literal">Feature</code> name and optionally provide a short description. Next,
analyze which actions and verifications are performed in the script-based Test Case that
need to be migrated. This is how an example Test Case for the addressbook
application might look:
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">
def main():
    startApplication("com.froglogic.addressbook")
    test.compare(waitForObjectExists(names.address_Book_List).rowCount, 0, "Addressbook is empty?")
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">
function main(){
    startApplication("com.froglogic.addressbook");
    test.compare(waitForObjectExists(names.addressBookList).rowCount, 0, "Addressbook is empty?");
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">
sub main {
	startApplication("com.froglogic.addressbook");
    test::compare(waitForObjectExists($Names::address_book_list)-&gt;rowCount,0, "Addressbook is empty?");
}
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">
def main
  startApplication("com.froglogic.addressbook")
  Test.compare(waitForObjectExists(Names::Address_Book_List).rowCount, 0, "Addressbook is empty?")
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">
proc main {} {
    startApplication "com.froglogic.addressbook"
    test compare [property get [waitForObjectExists $names::Address_Book_List] rowCount] 0
}
</pre></div><p>
After analyzing the above script-based test, we can create
the following  <code class="literal">Scenario</code> and add it to test.feature file:
</p><pre class="screen">
Scenario: Initial state of created address book
   Given addressbook application is running
   Then addressbook should have zero entries
</pre><p>
Next, right-click on the <code class="literal">Scenario</code> and choose the option
<span class="guibutton">Create Missing Step Implementations</span> from the context menu. This
will create a skeleton of steps definitions:
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">
@Given("addressbook application is running")
def step(context):
    test.warning("TODO implement addressbook application is running")

@Then("addressbook should have zero entries")
def step(context):
    test.warning("TODO implement addressbook should have zero entries")
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">
Given("addressbook application is running", function(context) {
    test.warning("TODO implement addressbook application is running");
});

Then("addressbook should have zero entries", function(context) {
    test.warning("TODO implement addressbook should have zero entries");
});
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">
Given("addressbook application is running", sub {
    my $context = shift;
    test::warning("TODO implement addressbook application is running");
});

Then("addressbook should have zero entries", sub {
    my $context = shift;
    test::warning("TODO implement addressbook should have zero entries");
});
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">
Given("addressbook application is running") do |context|
  Test.warning "TODO implement addressbook application is running"
end

Then("addressbook should have zero entries") do |context|
  Test.warning "TODO implement addressbook should have zero entries"
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">
Given "addressbook application is running" {context} {
    test warning "TODO implement addressbook application is running"
}

Then "addressbook should have zero entries" {context} {
    test warning "TODO implement addressbook should have zero entries"
}
</pre></div><p>
Now we put code snippets from the script-based Test into respective
step definitions and remove the lines containing
<code class="code">test.warning</code>. If your script-based Tests make use of shared scripts, you
can call those functions inside of the step definition as well. For
example, the final result could look like this:
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">
@Given("addressbook application is running")
def step(context):
    startApplication("com.froglogic.addressbook")

@Then("addressbook should have zero entries")
def step(context):
    test.compare(waitForObjectExists(names.address_Book_List).rowCount, 0,  "Addressbook is empty?")
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">
Given("addressbook application is running", function(context) {
    startApplication("com.froglogic.addressbook");
});

Then("addressbook should have zero entries", function(context) {
        test.compare(waitForObjectExists(names.addressBookList).rowCount, 0);
});
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">
Given("addressbook application is running", sub {
    my $context = shift;
	startApplication("com.froglogic.addressbook");
});

Then("addressbook should have zero entries", sub {
    my $context = shift;
    test::compare(waitForObjectExists($Names::address_book_list)-&gt;rowCount,0);
});
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">
Given("addressbook application is running") do |context|
  startApplication("com.froglogic.addressbook")
end

Then("addressbook should have zero entries") do |context|
  Test.compare(waitForObjectExists(Names::Address_Book_List).rowCount, 0, "Addressbook is empty?")
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">
Given "addressbook application is running" {context} {
    startApplication "com.froglogic.addressbook"
}

Then "addressbook should have zero entries" {context} {
    test compare [property get [waitForObjectExists $names::Address_Book_List] rowCount] 0
}
</pre></div><p>
After running each <code class="literal">Scenario</code>, the AUT is terminated,
from the auto-generated <code class="code">OnScenarioEnd</code> hooks file shown below:
</p><div xmlns="" class="scriptlang"><form><select name="scriptlangcombo" onchange="javascript:changeScriptingLanguage(this)" onclick="javascript:changeScriptingLanguage(this)"><option value="all" selected>Show All</option><option value="JavaScript">Show JavaScript</option><option value="Perl">Show Perl</option><option value="Python">Show Python</option><option value="Ruby">Show Ruby</option><option value="Tcl">Show Tcl</option></select></form></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Python</span><pre class="programlisting">
@OnScenarioEnd
def hook(context):
    for ctx in applicationContextList():
        ctx.detach()
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">JavaScript</span><pre class="programlisting">
OnScenarioEnd(function(context) {
    applicationContextList().forEach(function(ctx) { ctx.detach(); });
});
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Perl</span><pre class="programlisting">
OnScenarioEnd(sub {
    foreach (applicationContextList()) {
        $_-&gt;detach();
    }
});
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Ruby</span><pre class="programlisting">
OnScenarioEnd do |context|
    applicationContextList().each { |ctx| ctx.detach() }
end
</pre></div><div xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="programlistingcontainer"><span class="programlistinglanguage">Tcl</span><pre class="programlisting">
OnScenarioEnd {context} {
    foreach ctx [applicationContextList] {
        applicationContext $ctx detach
    }
}
</pre></div><p>
The above example was simplified for this tutorial. In order to take full advantage of
Behavior Driven Testing in <span class="emphasis"><em>Squish</em></span>, please familiarize yourself with the section
<a class="xref" href="api.bdt.functions.html" title="6.19. Behavior Driven Testing">Behavior Driven Testing (Section 6.19)</a> in <a class="xref" href="api.man.html" title="Chapter 6. API Reference Manual">API Reference Manual (Chapter 6)</a>.
</p></div></div><div class="footnotes"><br></br><hr width="100" align="left"></hr><div class="footnote"><p><sup>[<a id="ftn.idp43338536" href="#idp43338536" class="para">17</a>] </sup>
Run <pre class="screen">squishrunner --info androidInstrumentation
</pre> to get a list of all possible AUT's when squishserver and your
Android emulators or devices are running.
</p></div><div class="footnote"><p><sup>[<a id="ftn.idp43561912" href="#idp43561912" class="para">18</a>] </sup>
Both <code class="filename">.csv</code> and <code class="filename">.tsv</code> files are
assumed to use the Unicode UTF-8 encoding—the same encoding used
for all test scripts.
</p></div></div></div><script xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format" type="text/javascript" src="ScriptingLanguage.js"></script><script xmlns="" xmlns:fo="http://www.w3.org/1999/XSL/Format">setScriptingLanguage();</script><div class="navfooter"><hr></hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="tutorials-gdc.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="tutorials.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="tutorials-flex.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">4.11. Squish for GDC Tutorials </td><td width="20%" align="center"><a accesskey="h" href="index-noframes.html">Home</a></td><td width="40%" align="right" valign="top"> 4.13. Squish for Flex Tutorials</td></tr></table></div></body>
<!-- Mirrored from tutorials-android.html by HTTrack Website Copier/3.x [XR&CO'2013], Wed, 06 Jul 2022 13:28:59 GMT -->
</html>
